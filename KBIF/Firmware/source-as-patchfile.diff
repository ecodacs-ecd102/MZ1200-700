diff '--exclude=.git' -uprN pico.orig/pico-examples/usb/CMakeLists.txt pico/pico-examples/usb/CMakeLists.txt
--- pico.orig/pico-examples/usb/CMakeLists.txt	2024-05-24 13:26:15.789292061 +0900
+++ pico/pico-examples/usb/CMakeLists.txt	2024-05-24 13:30:10.279213407 +0900
@@ -13,6 +13,8 @@ if (TARGET tinyusb_pico_pio_usb)
         message("Skipping TinyUSB dual examples, as TinyUSB hw/mcu/raspberry_pi/Pico-PIO-USB does not currently compile on non GCC")
     else()
         add_subdirectory(dual)
+        add_subdirectory(pet)
+        add_subdirectory(mz)
     endif()
 else ()
     message("Skipping TinyUSB dual examples, as TinyUSB hw/mcu/raspberry_pi/Pico-PIO-USB submodule unavailable")
diff '--exclude=.git' -uprN pico.orig/pico-examples/usb/mz/CMakeLists.txt pico/pico-examples/usb/mz/CMakeLists.txt
--- pico.orig/pico-examples/usb/mz/CMakeLists.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-examples/usb/mz/CMakeLists.txt	2024-05-24 13:30:10.279213407 +0900
@@ -0,0 +1,4 @@
+set(FAMILY rp2040)
+set(BOARD pico_sdk)
+set(TINYUSB_FAMILY_PROJECT_NAME_PREFIX "tinyusb_mz_")
+add_subdirectory(${PICO_TINYUSB_PATH}/examples/mz tinyusb_mz)
\ No newline at end of file
diff '--exclude=.git' -uprN pico.orig/pico-examples/usb/pet/CMakeLists.txt pico/pico-examples/usb/pet/CMakeLists.txt
--- pico.orig/pico-examples/usb/pet/CMakeLists.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-examples/usb/pet/CMakeLists.txt	2024-05-24 13:30:10.279213407 +0900
@@ -0,0 +1,4 @@
+set(FAMILY rp2040)
+set(BOARD pico_sdk)
+set(TINYUSB_FAMILY_PROJECT_NAME_PREFIX "tinyusb_pet_")
+add_subdirectory(${PICO_TINYUSB_PATH}/examples/pet tinyusb_pet)
\ No newline at end of file
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/mz/CMakeLists.txt pico/pico-sdk/lib/tinyusb/examples/mz/CMakeLists.txt
--- pico.orig/pico-sdk/lib/tinyusb/examples/mz/CMakeLists.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/mz/CMakeLists.txt	2024-05-24 13:30:10.280213410 +0900
@@ -0,0 +1,12 @@
+cmake_minimum_required(VERSION 3.5)
+
+include(${CMAKE_CURRENT_SOURCE_DIR}/../../hw/bsp/family_support.cmake)
+
+project(tinyusb_mz)
+family_initialize_project(tinyusb_mz ${CMAKE_CURRENT_LIST_DIR})
+if (FAMILY STREQUAL "rp2040" AND NOT TARGET tinyusb_pico_pio_usb)
+    message("Skipping dual host/device mode examples as Pico-PIO-USB is not available")
+else()
+    # family_add_subdirectory will filter what to actually add based on selected FAMILY
+    family_add_subdirectory(host_hid_to_device_cdc_mz)
+endif()
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/CMakeLists.txt pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/CMakeLists.txt
--- pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/CMakeLists.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/CMakeLists.txt	2024-05-31 11:12:21.290305714 +0900
@@ -0,0 +1,46 @@
+cmake_minimum_required(VERSION 3.5)
+
+include(${CMAKE_CURRENT_SOURCE_DIR}/../../../hw/bsp/family_support.cmake)
+
+# gets PROJECT name for the example (e.g. <BOARD>-<DIR_NAME>)
+family_get_project_name(PROJECT ${CMAKE_CURRENT_LIST_DIR})
+
+project(${PROJECT})
+
+# Checks this example is valid for the family and initializes the project
+family_initialize_project(${PROJECT} ${CMAKE_CURRENT_LIST_DIR})
+
+add_executable(${PROJECT})
+
+# Example source
+target_sources(${PROJECT} PUBLIC
+        ${CMAKE_CURRENT_SOURCE_DIR}/src/main.c
+        ${CMAKE_CURRENT_SOURCE_DIR}/src/usb_descriptors.c
+        )
+
+# Example include
+target_include_directories(${PROJECT} PUBLIC
+        ${CMAKE_CURRENT_SOURCE_DIR}/src
+        )
+
+# kaokun: to save settings into flash storege
+target_link_libraries(${PROJECT} PUBLIC
+	hardware_flash
+	hardware_sync
+	)
+
+# Configure compilation flags and libraries for the example... see the corresponding function
+# in hw/bsp/FAMILY/family.cmake for details.
+family_configure_dual_usb_example(${PROJECT})
+
+# due to warnings from Pico-PIO-USB
+target_compile_options(${PROJECT} PUBLIC
+        -Wno-error=shadow
+        -Wno-error=cast-align
+        -Wno-error=cast-qual
+        -Wno-error=redundant-decls
+        -Wno-error=sign-conversion
+        -Wno-error=conversion
+        -Wno-error=sign-compare
+        -Wno-error=unused-function
+        )
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/Makefile pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/Makefile
--- pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/Makefile	2024-05-24 13:30:10.280213410 +0900
@@ -0,0 +1,19 @@
+include ../../../tools/top.mk
+include ../../make.mk
+
+INC += \
+	src \
+	$(TOP)/hw \
+
+# Example source
+EXAMPLE_SOURCE += $(wildcard src/*.c)
+SRC_C += $(addprefix $(CURRENT_PATH)/, $(EXAMPLE_SOURCE))
+
+CFLAGS += -Wno-error=cast-align -Wno-error=null-dereference
+
+SRC_C += \
+	src/class/hid/hid_host.c \
+	src/host/hub.c \
+	src/host/usbh.c
+
+include ../../rules.mk
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/only.txt pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/only.txt
--- pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/only.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/only.txt	2024-05-24 13:30:10.280213410 +0900
@@ -0,0 +1,3 @@
+board:mimxrt1060_evk
+board:mimxrt1064_evk
+mcu:RP2040
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/main.c pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/main.c
--- pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/main.c	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/main.c	2024-08-08 17:42:16.229022947 +0900
@@ -0,0 +1,3813 @@
+/* 
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2019 Ha Thach (tinyusb.org)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ */
+
+// This example runs both host and device concurrently. The USB host receive
+// reports from HID device and print it out over USB Device CDC interface.
+
+// DEBUG options / DEFAULT values
+
+// Array switch debug
+#define MZ_KEYCODE_DEBUG	1
+
+// HID LED logging
+//#define HID_LED_DEBUG		1
+
+// MZ clock setting
+#define MZ_CLK_DEBUG		1
+
+// debounce timing adjust
+//#define MZ_DEBOUNCE_ADJUST	1
+
+// SYSTEM MODE
+#define SYSTEM_MODE_DEFAULT	0		// SP-1002 SDパッチ無し, FONT-JP, KEY=MZ-80K
+
+// Z80 CLOCK
+#define Z80_CLOCK_MODE_DEFAULT	Z80_CLOCK_MODE_AUTO
+
+/*===================================================================
+  GPIO仕様
+    GPIO0: カセットのモーター信号入力 (IN: Pull-Up) : ON=L, OFF=H (ダイオードで5Vがかからないようにしているので要Pull-Up)
+    GPIO1: システムクロック切替え信号出力 (Out)     : 2MHz=H, 4MHz=L (オープンコレクタTrで反転させているため)
+
+    GPIO2-5(Out): BIOS ROMの切替え
+      GPIO2: A15: 1=日本語,	0=英語 この信号はCG Selectにも使う
+      GPIO3: A14: 1=MZ-1200,	0=MZ-700
+      GPIO4: A13: 1=オリジナル,	0=MZ-80 SD対応パッチ入り
+      GPIO5: A12: 1=SHARP ROM,	0=MZ-New Monitor
+
+    GPIO6-15(Out): キースイッチマトリクスへ
+      GPIO6:  RESET
+      GPIO7:  DATA
+      GPIO8:  STROBE
+      GPIO9:  AX0
+      GPIO10: AX1
+      GPIO11: AX2
+      GPIO12: AX3
+      GPIO13: AY0
+      GPIO14: AY1
+      GPIO15: AY2
+
+    GPIO16(In-PullUp): キースキャン(DEC0)検出線。0でスキャンを検出 (ダイオードで5Vがかからないようにしているので要Pull-Up)
+
+    GPIO19(Out): 本体リセット用。1でリセットスイッチを押した状態
+
+    GPIO20-22(In/Out): USB HOST制御 (Pico SDK内TinyUSBのデフォルト)
+      GPIO20: D+
+      GPIO21: D-
+      GPIO22: VBUSEN
+
+
+  -------------------------------------------------------------------
+  キー入力仕様
+  ■[ALT] + [CTRL] + テンキー[0]-[7]: システムモードの切り替え
+      ROMを切り替えてリセットスイッチを押す(Cold Reset)
+             A15 A14 A13 A12 ROM                      SD          FONT     KEY
+      ALT+0:   0   0   0   0 MZ-1200, SP-1002         パッチ無し, FONT-JP, KEY=MZ-80K
+      ALT+1:   0   0   0   1 MZ-1200, MZ-New Monitor  パッチ無し, FONT-JP, KEY=MZ-80K
+      ALT+2:   0   0   1   0 MZ-1200, SP-1002         SDパッチ,   FONT-JP, KEY=MZ-80K
+      ALT+3:   0   0   1   1 MZ-1200, MZ-New Monitor  SDパッチ,   FONT-JP, KEY=MZ-80K
+      ALT+4:   0   1   0   0 MZ-700,  1Z-009A         パッチ無し, FONT-JP, KEY=MZ-700J
+      ALT+5:   0   1   0   1 MZ-700,  MZ-New Monitor  パッチ無し, FONT-JP, KEY=MZ-700J
+      ALT+6:   0   1   1   0 MZ-700,  1Z-009A         SDパッチ,   FONT-JP, KEY=MZ-700J
+      ALT+7:   0   1   1   1 MZ-700,  MZ-New Monitor  SDパッチ,   FONT-JP, KEY=MZ-700J
+ CTRL+ALT+0:   1   0   0   0 MZ-1200, SA-1510         パッチ無し, FONT-EN, KEY=MZ-80A
+ CTRL+ALT+1:   1   0   0   1 MZ-1200, SP-1002         パッチ無し, FONT-EN, KEY=MZ-80K
+ CTRL+ALT+2:   1   0   1   0 MZ-1200, SA-1510         SDパッチ,   FONT-EN, KEY=MZ-80A
+ CTRL+ALT+3:   1   0   1   1 MZ-1200, SP-1002         SDパッチ,   FONT-EN, KEY=MZ-80K
+ CTRL+ALT+4:   1   1   0   0 MZ-700,  1Z-013A         パッチ無し, FONT-EN, KEY=MZ-700E
+ CTRL+ALT+5:   1   1   0   1 MZ-700,  MZ-New Monitor7 パッチ無し, FONT-EN, KEY=MZ-700J
+ CTRL+ALT+6:   1   1   1   0 MZ-700,  1Z-013A         SDパッチ,   FONT-EN, KEY=MZ-700E
+ CTRL+ALT+7:   1   1   1   1 MZ-700,  MZ-New Monitor7 SDパッチ,   FONT-EN, KEY=MZ-700J
+
+  ■[ALT] + テンキー[+][-][*]: システムクロック切替え
+      ALT+[+]: 4MHz固定
+      ALT+[-]: 2MHz固定
+      ALT+[*]: Auto (カセットのモーターOn時は2MHz, 他は4MHz)
+
+  ■[ALT] + テンキー[8]: フラッシュへ保存したシステムモード、システムクロック、ファンクションキーを消去
+  ■[ALT] + テンキー[9]: 現在のシステムモード、システムクロック、ファンクションキーをフラッシュへ保存
+  　次回電源投入時は、保存されたモード、システムクロック、ファンクションキー設定になる
+
+  ■[CTRL]+[ALT]+[DEL]: 現在のシステムモードでROMを切り替えずリセットスイッチを押す (Cold Reset)
+  ■[CTRL]+[ALT]+[END]: 現在のシステムモードでROMを切り替えず[CTRL]+リセットスイッチを押す (MZ-700系のWarm Resetのエミュレーション)
+  ■[ALT]+英字キー: MZ-1200モードでグラフィックキャラクタの直接入力 (Pasocom mini MZ-80C互換)
+
+  ■[Fn]キー       n=6-12: ファンクションキー(キーマクロ)の実行 ([F1]-[F5]はMZ700で使われているので[F6]-[F12]とする) (COOKED mode only)
+  ■[ALT]+[Fn]キー n=6-12: ファンクションキー(キーマクロ)の登録/登録終了([F1]-[F5]はMZ700で使われるため[F6]-[F12]とする) (COOKED mode only)
+  　キーマクロは MZ_FKEY_MAXLEN	キーストロークまで。((FLASH_PAGE_SIZE - 8) / 2) = 124 キーまで。
+  　[ALT]+[テンキー9]で不揮発に保存される。
+
+  ■[CAPS]キー: [ALPHA(英数)]キーとして処理される。MZ-1200モードでは[カナ/英数]キーとなる
+  ■[TAB]キー: [HOME/CLR]キーとして処理される。
+  ■[PgUp]キー: [GRPH]キーとして処理される。
+  ■[PgDn]キー,[かな]: [KANA]キーとして処理される。
+
+  ■[ALT]+[CAPS]キー: RAW mode / COOKED mode 切替え。
+  　COOKED mode (Default):
+  　  USBキーに書かれているキー刻印にできるだけ忠実になるように、シフトキーが自動で付加される
+  　RAW mode (aka GAME mode):
+  　  シフトキーも透過的に実機に送られるため、キーの読み替えは最小限となる。
+  　  このモードの時は、カナキー、NUMキー、CAPSキーランプが点滅する。
+  　  また、ゲームのキー反応のリアルタイム性を上げるため、デバウンス関係の待ちは入れない。
+
+  ■[ALT] + [Up]/[Down]/[Left]/[Right]
+    (MZ_DEBOUNCE_ADJUST 定義時)
+  　デバウンス関係のパラメータ調整
+  　[ALT]+[Up]/[Down]    : Press debounce +/-
+  　[ALT]+[Left]/[Right] : Release debounce -/+
+  ■[ALT] + [Left]/[Right]
+  　デバウンス関係のパラメータ調整
+  　[ALT]+[Left]/[Right] : Release debounce H,M,L切替え
+
+  ===================================================================*/
+
+
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "bsp/board.h"
+#include "tusb.h"
+
+// GPIO for MZ ver.
+#include "pico/stdlib.h"
+#include "hardware/gpio.h"
+
+// flash memory access
+#include "hardware/flash.h"
+
+// PIO_USB_VBUSEN_PIN, PIO_USB_VBUSEN_STATE
+#include "../../hw/bsp/rp2040/board.h"
+
+//--------------------------------------------------------------------+
+// MACRO CONSTANT TYPEDEF PROTYPES
+//--------------------------------------------------------------------+
+
+// uncomment if you are using colemak layout
+// #define KEYBOARD_COLEMAK
+
+#ifdef KEYBOARD_COLEMAK
+const uint8_t colemak[128] = {
+  0  ,  0,  0,  0,  0,  0,  0, 22,
+  9  , 23,  7,  0, 24, 17,  8, 12,
+  0  , 14, 28, 51,  0, 19, 21, 10,
+  15 ,  0,  0,  0, 13,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0, 18,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0
+};
+#endif
+
+static uint8_t const keycode2ascii[256][2] =  {
+    {0     , 0      }, /* 0x00 */ \
+    {0     , 0      }, /* 0x01 */ \
+    {0     , 0      }, /* 0x02 */ \
+    {0     , 0      }, /* 0x03 */ \
+    {'a'   , 'A'    }, /* 0x04 */ \
+    {'b'   , 'B'    }, /* 0x05 */ \
+    {'c'   , 'C'    }, /* 0x06 */ \
+    {'d'   , 'D'    }, /* 0x07 */ \
+    {'e'   , 'E'    }, /* 0x08 */ \
+    {'f'   , 'F'    }, /* 0x09 */ \
+    {'g'   , 'G'    }, /* 0x0a */ \
+    {'h'   , 'H'    }, /* 0x0b */ \
+    {'i'   , 'I'    }, /* 0x0c */ \
+    {'j'   , 'J'    }, /* 0x0d */ \
+    {'k'   , 'K'    }, /* 0x0e */ \
+    {'l'   , 'L'    }, /* 0x0f */ \
+    {'m'   , 'M'    }, /* 0x10 */ \
+    {'n'   , 'N'    }, /* 0x11 */ \
+    {'o'   , 'O'    }, /* 0x12 */ \
+    {'p'   , 'P'    }, /* 0x13 */ \
+    {'q'   , 'Q'    }, /* 0x14 */ \
+    {'r'   , 'R'    }, /* 0x15 */ \
+    {'s'   , 'S'    }, /* 0x16 */ \
+    {'t'   , 'T'    }, /* 0x17 */ \
+    {'u'   , 'U'    }, /* 0x18 */ \
+    {'v'   , 'V'    }, /* 0x19 */ \
+    {'w'   , 'W'    }, /* 0x1a */ \
+    {'x'   , 'X'    }, /* 0x1b */ \
+    {'y'   , 'Y'    }, /* 0x1c */ \
+    {'z'   , 'Z'    }, /* 0x1d */ \
+    {'1'   , '!'    }, /* 0x1e */ \
+    {'2'   , '"'    }, /* 0x1f */ \
+    {'3'   , '#'    }, /* 0x20 */ \
+    {'4'   , '$'    }, /* 0x21 */ \
+    {'5'   , '%'    }, /* 0x22 */ \
+    {'6'   , '&'    }, /* 0x23 */ \
+    {'7'   , 0x27   }, /* 0x24 */ \
+    {'8'   , '('    }, /* 0x25 */ \
+    {'9'   , ')'    }, /* 0x26 */ \
+    {'0'   , 0      }, /* 0x27 */ \
+    {'\r'  , '\r'   }, /* 0x28 [CR] */ \
+    {'\x1b', '\x1b' }, /* 0x29 [ESC] = SHIFT+SPACE in Hu-BASIC*/ \
+    {'\x14', '\x14' }, /* 0x2a [BS] = [←] */ \
+    {'\x15', '\x16' }, /* 0x2b TAB = [HOME/CLR] */ \
+    {' '   , ' '    }, /* 0x2c [SPACE] */ \
+    {'-'   , '-'    }, /* 0x2d */ \
+    {'^'   , 0      }, /* 0x2e */ \
+    {'@'   , '`'    }, /* 0x2f */ \
+    {'['   , '{'    }, /* 0x30 */ \
+    {0     , 0      }, /* 0x31 */ \
+    {']'   , '}'    }, /* 0x32 */ \
+    {';'   , '+'    }, /* 0x33 */ \
+    {':'   , '*'    }, /* 0x34 */ \
+    {'\x03', '\x03' }, /* 0x35 ZEN/HAN = [BREAK] key = ^C */ \
+    {','   , '<'    }, /* 0x36 */ \
+    {'.'   , '>'    }, /* 0x37 */ \
+    {'/'   , '?'    }, /* 0x38 */ \
+                                  \
+    {0     , 0      }, /* 0x39: [CAPS] = [カナ/英数] */ \
+    {0     , 0      }, /* 0x3a [F1] */ \
+    {0     , 0      }, /* 0x3b [F2] */ \
+    {0     , 0      }, /* 0x3c [F3] */ \
+    {0     , 0      }, /* 0x3d [F4] */ \
+    {0     , 0      }, /* 0x3e [F5] */ \
+    {0     , 0      }, /* 0x3f [F6] */ \
+    {0     , 0      }, /* 0x40 [F7] */ \
+    {0     , 0      }, /* 0x41 [F8] */ \
+    {0     , 0      }, /* 0x42:[F9]  */ \
+    {0     , 0      }, /* 0x43:[F10] */ \
+    {0     , 0      }, /* 0x44 [F11] */ \
+    {0     , 0      }, /* 0x45:[F12] */ \
+    {0     , 0      }, /* 0x46 */ \
+    {0     , 0      }, /* 0x47 */ \
+    {0     , 0      }, /* 0x48 */ \
+    {0     , 0      }, /* 0x49 Insert */ \
+    {'\x15', 0      }, /* 0x4a Home */ \
+    {0     , 0      }, /* 0x4b PgUp */ \
+    {0     , 0      }, /* 0x4c Delete */ \
+    {0     , 0      }, /* 0x4d Pgdn */ \
+    {0     , 0      }, /* 0x4e */ \
+    {'\x13', 0      }, /* 0x4f right arrow */ \
+    {'\x14', 0      }, /* 0x50 left arrow */ \
+    {'\x11', 0      }, /* 0x51 down arrow */ \
+    {'\x12', 0      }, /* 0x52 up arrow */ \
+    {0     , 0      }, /* 0x53 */ \
+                                  \
+    {'/'   , '/'    }, /* 0x54 */ \
+    {'*'   , '*'    }, /* 0x55 */ \
+    {'-'   , '-'    }, /* 0x56 */ \
+    {'+'   , '+'    }, /* 0x57 */ \
+    {'\r'  , '\r'   }, /* 0x58 */ \
+    {'1'   , 0      }, /* 0x59 */ \
+    {'2'   , 0      }, /* 0x5a */ \
+    {'3'   , 0      }, /* 0x5b */ \
+    {'4'   , 0      }, /* 0x5c */ \
+    {'5'   , 0      }, /* 0x5d */ \
+    {'6'   , 0      }, /* 0x5e */ \
+    {'7'   , 0      }, /* 0x5f */ \
+    {'8'   , 0      }, /* 0x60 */ \
+    {'9'   , 0      }, /* 0x61 */ \
+    {'0'   , 0      }, /* 0x62 */ \
+    {'.'   , 0      }, /* 0x63 */ \
+    {0     , 0      }, /* 0x64 */ \
+    {0     , 0      }, /* 0x65:[Application] */ \
+    {0     , 0      }, /* 0x66 */ \
+    {'='   , '='    }, /* 0x67 */ \
+    				  \
+    {0     , 0      }, /* 0x68 */ \
+    {0     , 0      }, /* 0x69 */ \
+    {0     , 0      }, /* 0x6a */ \
+    {0     , 0      }, /* 0x6b */ \
+    {0     , 0      }, /* 0x6c */ \
+    {0     , 0      }, /* 0x6d */ \
+    {0     , 0      }, /* 0x6e */ \
+    {0     , 0      }, /* 0x6f */ \
+    {0     , 0      }, /* 0x70 */ \
+    {0     , 0      }, /* 0x71 */ \
+    {0     , 0      }, /* 0x72 */ \
+    {0     , 0      }, /* 0x73 */ \
+    {0     , 0      }, /* 0x74 */ \
+    {0     , 0      }, /* 0x75 */ \
+    {0     , 0      }, /* 0x76 */ \
+    {0     , 0      }, /* 0x77 */ \
+    {0     , 0      }, /* 0x78 */ \
+    {0     , 0      }, /* 0x79 */ \
+    {0     , 0      }, /* 0x7a */ \
+    {0     , 0      }, /* 0x7b */ \
+    {0     , 0      }, /* 0x7c */ \
+    {0     , 0      }, /* 0x7d */ \
+    {0     , 0      }, /* 0x7e */ \
+    {0     , 0      }, /* 0x7f */ \
+    {0     , 0      }, /* 0x80 */ \
+    {0     , 0      }, /* 0x81 */ \
+    {0     , 0      }, /* 0x82 */ \
+    {0     , 0      }, /* 0x83 */ \
+    {0     , 0      }, /* 0x84 */ \
+    {0     , 0      }, /* 0x85 */ \
+    {0     , 0      }, /* 0x86 */ \
+    				  \
+    {'\x5c', '_'    }, /* 0x87:[Backslash]/[_] key */ \
+    {0     , 0      }, /* 0x88:[Hiragana/Katakana] */ \
+    {'\x5c', 0      }, /* 0x89:[Yen]/[|] key */ \
+};
+
+
+/* Blink pattern
+ * - 250 ms  : device not mounted
+ * - 1000 ms : device mounted
+ * - 2500 ms : device is suspended
+ */
+enum  {
+  BLINK_NOT_MOUNTED = 250,
+  BLINK_MOUNTED = 1000,
+  BLINK_SUSPENDED = 2500,
+};
+
+static uint32_t blink_interval_ms = BLINK_NOT_MOUNTED;
+
+void led_blinking_task(void);
+
+/*------------- Keyboard LED  -------------*/
+static uint8_t leds = 0;
+static uint8_t prev_leds = 0;
+
+/* NUMLOCK Blink pattern
+ * - 250 ms : RAW mode
+ * - 0 ms   : KANA mode
+ */
+enum  {
+  BLINK_NUMLOCK_LED_NONE = 0,
+  BLINK_NUMLOCK_LED_RAW = 250,
+  BLINK_NUMLOCK_LED_KANA = 0,
+};
+
+static uint32_t blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_NONE;
+
+// Keyboard address and instance (assumes there is only one)
+static uint8_t keybd_dev_addr = 0xFFu;
+static uint8_t keybd_instance;
+
+void keyboard_led_blinking_task(void);
+
+
+
+/*------------- MZ-1200  -------------*/
+
+/*
+#====================================================================
+# Scan Code: MZ-1200
+#  ------+------------------------
+#   row |  7  6  5  4  3  2  1  0
+# +1----+------------------------
+#  1 0 .| ┴ ┘  -  9  7  5  3  1
+#      S| ┬ ┐  +  )  '  %  #  !
+#      K| ャ「  ホ ヨ ヤ エ ア ヌ
+#       |
+#  2 1 .| 月 ├ └  0  8  6  4  2
+#      S| 日 ┤ ┌  π (  &  $  "
+#      K| ￥ ァ ケ ワ ユ オ ウ フ
+#       |
+#  3 2 .| ┘ F4  =  O  U  T  E  Q
+#      S| ┐ C5  *  :  @  ] ←  <
+#      K| ュ 」 ヘ ラ ナ カ イ タ
+#       |
+#  4 3 .| 水 └ E5  P  I  Y  R  W
+#      S| 火 ┌ C3  ^  ? ＼  [  >	^=↑キー
+#      K| ￡ ィ ム セ ニ ン ス テ
+#       | 
+#  5 4 .| D4 E3 ┼  L  J  G  D  A
+#      S| ED E7 DE DC F1 ● ♦ ♠
+#      K| ョ 、 ロ リ マ キ シ チ
+#       |
+#  6 5 .| 金 EE E3  ;  K  H  F  S
+#      s| 木 D7 E4 DF DB 〇 ♣ ♥
+#      K| 時 ゥ ヲ レ ノ ク ハ ト
+#       |
+#  7 6 .| C1 FD kn  .  M  B  C  Z 	kn = [カナ/英数]
+#      S| D4 E7 kn EB FE E8 C0 C6
+#      K| ッ ・ kn ル モ コ ソ ツ	・ = 中黒
+#       |
+#  8 7 .| 生 C2 E6  /  ,  N  V  X
+#      S| 土 D7 E0 F6 EA C8 F4 FC
+#      K| 分 ェ ゜ メ ネ ミ ヒ サ
+#       |
+#  9 8 .| CA C6 rs CR -> -- id ls	ls = Left SHIFT, rs = Right SHIFT
+#      S| D6 F8 rs CR <- -- id ls	-> = CURSOR →
+#      K| ー 。 rs CR <> -- id ls	<- = CURSOR ←
+#       |
+#  a 9 .| 円 CF ゛ -- ^C cd 20 hh	hh = [HOME], 20=[SPACE], cd = [CURSOR↓]
+#      S| 年 D8 ゛ -- ^C cu 20 cc	cc = [CLR], cu = [CURSOR↑]
+#      K| 秒 ォ ゛ -- ^C cd 20 HC	HC = [HOME/CLR], ^C ~ [BREAK]
+#       |
+#  ------+------------------------
+#====================================================================
+*/
+/*------------- MZ-80A  -------------*/
+/*
+#====================================================================
+# Scan Code: MZ-80A
+#  ------+------------------------
+#   row |  7  6  5  4  3  2  1  0
+# +1----+------------------------
+#  1 0 .| ct -- -- -- -- -- gr sh	cr=[CTRL],br=[BREAK],gr=[GRPH],sh=[SHIFT]
+#      S| br
+#      G| 
+#       |
+#  2 1 .|  2  1  W  Q  A dl --  Z	dl=[DEL]
+#      S|  "  !          in --  	in=[INST]
+#      G| 
+#       |
+#  3 2 .|  4  3  R  E  D  S  X  C
+#      S|  $  #
+#      G| 
+#       |
+#  4 3 .|  6  5  Y  T  G  F  V  B
+#      S|  &  %
+#      G| 
+#       | 
+#  5 4 .|  8  7  I  U  J  H  N sp
+#      S|  (  '
+#      G| 
+#       |
+#  6 5 .|  0  9  P  O  L  K  <  M
+#      s|  -  )              ,
+#      G| 
+#       |
+#  7 6 .|  ^  -  [  @  :  ;  /  .
+#      S|  ~  =  {  \  *  + ←  >
+#      G| 
+#       |
+#  8 7 .| hm  \ ri up CR  ] -- ↑
+#      S| cl  | le dn CR  } --  ?
+#      G| 
+#       |
+#  9 8 .|  8  7  5  4  2  1 00  0	10-KEY
+#      S| 
+#      G| 
+#       |
+#  a 9 .|  +  9  -  6 --  3 --  .	10-KEY
+#      S| 
+#      G| 
+#       |
+#  ------+------------------------
+#====================================================================
+*/
+/*------------- MZ700  -------------*/
+
+/*
+#====================================================================
+# Scan Code: MZ-700J
+#  ------+------------------------
+#   row |  7  6  5  4  3  2  1  0
+# +1----+-----------------------
+#  1 0 .| kn gr  = ei --  ;  : CR	 kn=[カナ], gr=[GRPH], ei=[英数], CR=[CR]
+#       |
+#  2 1 .|  Y  Z  @  (  ) -- -- --
+#      S| 
+#      K| 
+#       |
+#  3 2 .|  Q  R  S  T  U  V  W  X
+#      S| 
+#      K| 
+#       |
+#  4 3 .|  I  J  K  L  M  N  O  P
+#      S| 
+#      K| 
+#       | 
+#  5 4 .|  A  B  C  D  E  F  G  H
+#      S| 
+#      K| 
+#       |
+#  6 5 .|  1  2  3  4  5  6  7  8
+#      s| 
+#      K| 
+#       |
+#  7 6 .|  *  +  - sp  0  9  ,  .	sp=[SPACE]
+#      S| 
+#      K| 
+#       |
+#  8 7 .| in de up dn ri le  ?  /	in=[INST], de=[DEL], up,db,ri,le =Cursor up, down, right left
+#      S| 
+#      K| 
+#       |
+#  9 8 .| br ct -- -- -- -- -- sh	cr=[BREAK], ct=[CTRL], sh=[SHIFT]
+#      S| 
+#      K| 
+#       |
+#  a 9 .| F1 F2 F3 F4 F5 -- -- --
+#      S| 
+#      K| 
+#       |
+#  ------+------------------------
+#====================================================================
+# Scan Code: MZ-700EU
+#  ------+------------------------
+#   row |  7  6  5  4  3  2  1  0
+# +1----+-----------------------
+#  1 0 .| -- gr ↓ ei --  ;  : CR	 gr=[GRPH], ei=[英数], CR=[CR]
+#       |
+#  2 1 .|  Y  Z  @  (  ) -- -- --
+#      S| 
+#      K| 
+#       |
+#  3 2 .|  Q  R  S  T  U  V  W  X
+#      S| 
+#      K| 
+#       |
+#  4 3 .|  I  J  K  L  M  N  O  P
+#      S| 
+#      K| 
+#       | 
+#  5 4 .|  A  B  C  D  E  F  G  H
+#      S| 
+#      K| 
+#       |
+#  6 5 .|  1  2  3  4  5  6  7  8
+#      s| 
+#      K| 
+#       |
+#  7 6 .|  \ ↑  - sp  0  9  ,  .	sp=[SPACE]
+#      S| 
+#      K| 
+#       |
+#  8 7 .| in de up dn ri le  ?  /	in=[INST], de=[DEL], up,db,ri,le =Cursor up, down, right left
+#      S| 
+#      K| 
+#       |
+#  9 8 .| br ct -- -- -- -- -- sh	cr=[BREAK], ct=[CTRL], sh=[SHIFT]
+#      S| 
+#      K| 
+#       |
+#  a 9 .| F1 F2 F3 F4 F5 -- -- --
+#      S| 
+#      K| 
+#       |
+#  ------+------------------------
+#====================================================================
+*/
+
+#define DELETE_KEY_CODE		0x4c	// for CTRL-ALT-DEL
+#define END_KEY_CODE		0x4d	// for CTRL-ALT-END
+#define C_KEY_CODE		0x06	// for CTRL-C
+#define UP_KEY_CODE		0x52	// for CTRL-UP/DOWN/LEFT/RIGHT
+#define DOWN_KEY_CODE		0x51	// for CTRL-UP/DOWN/LEFT/RIGHT
+#define LEFT_KEY_CODE		0x50	// for CTRL-UP/DOWN/LEFT/RIGHT
+#define RIGHT_KEY_CODE		0x4f	// for CTRL-UP/DOWN/LEFT/RIGHT
+#define CAPS_KEY_CODE		0x39	// for ALPHA
+#define KANA_KEY_CODE		0x88	// for KANA input mode
+#define KANA_KEY_CODE2		0x4e	// for KANA input mode (=[PgDn] key)
+#define GRPH_KEY_CODE		0x4b	// for GRPH input mode (=[PgUp] key)
+#define F1_KEY_CODE		0x3a	// [F1] - [F12]
+#define F2_KEY_CODE		0x3b	// [F1] - [F12]
+#define F3_KEY_CODE		0x3c	// [F1] - [F12]
+#define F4_KEY_CODE		0x3d	// [F1] - [F12]
+#define F5_KEY_CODE		0x3e	// [F1] - [F12]
+#define F6_KEY_CODE		0x3f	// [F1] - [F12]
+#define F7_KEY_CODE		0x40	// [F1] - [F12]
+#define F8_KEY_CODE		0x41	// [F1] - [F12]
+#define F9_KEY_CODE		0x42	// [F1] - [F12]
+#define F10_KEY_CODE		0x43	// [F1] - [F12]
+#define F11_KEY_CODE		0x44	// [F1] - [F12]
+#define F12_KEY_CODE		0x45	// [F1] - [F12]
+#define TENKEY_1_KEY_CODE	0x59	// Tenkey [1] - [7]
+#define TENKEY_7_KEY_CODE	0x5f	// Tenkey [1] - [7]
+#define TENKEY_8_KEY_CODE	0x60	// Tenkey [8]
+#define TENKEY_9_KEY_CODE	0x61	// Tenkey [9]
+#define TENKEY_0_KEY_CODE	0x62	// Tenkey [0]
+#define TENKEY_PLUS_KEY_CODE	0x57	// Tenkey [+]
+#define TENKEY_MINUS_KEY_CODE	0x56	// Tenkey [-]
+#define TENKEY_ASTERISK_KEY_CODE 0x55	// Tenkey [*]
+
+#define MZ_KEYPRESS		0x100u
+#define MZ_ISKEYPRESS(x)	((x & MZ_KEYPRESS) ? true : false)
+#define MZ_BARE_SYX(x)		((uint16_t)(x & ~MZ_KEYPRESS))
+#define MZ_SHIFT		0x80u
+#define MZ_BARE_YX(x)		((uint16_t)(x & ~MZ_KEYPRESS & ~MZ_SHIFT))
+#define MZ_ISSHIFT(x)		((x & MZ_SHIFT) ? 1 : 0)
+#define MZ_Y(x)			((x >> 4) & 0x07)
+#define MZ_X(x)			((x & 0x0f) - 1)
+
+/*
+  key code to switch matrix X-Y and SHIFT table
+   (bit 8  : 1 = pressed, 0 = released, in queue only)
+    bit 7  : Need SHIFT (1 = Generate with SHIFT key)
+    bit 6-4: Y scanline (0-7)
+    bit 3-0: X scanline + 1 (1-0a), i.e. valid key has non-zero code on this table
+*/
+
+#define MZ1200_KEYCODE_BREAK	0x3a	// MZ1200 [BREAK] key X-Y
+#define MZ1200_KEYCODE_CTRL	0x00	// MZ1200 [CTRL] key X-Y (No key)
+#define MZ1200_KEYCODE_LS	0x09	// MZ1200 [Left SHIFT] key X-Y
+#define MZ1200_KEYCODE_RS	0x59	// MZ1200 [Right SHIFT] key X-Y
+#define MZ1200_KEYCODE_ALPHA	0x57	// MZ1200 [英数] key X-Y
+#define MZ1200_KEYCODE_KANA	0x57	// MZ1200 [カナ] key X-Y
+#define MZ1200_KEYCODE_GRPH	0x00	// MZ1200 [GRPH] key X-Y (No key)
+
+#define MZ700J_KEYCODE_BREAK	0x79	// MZ700J [BREAK] key X-Y
+#define MZ700J_KEYCODE_CTRL	0x69	// MZ700J [CTRL] key X-Y
+#define MZ700J_KEYCODE_LS	0x09	// MZ700J [Left SHIFT] key X-Y
+#define MZ700J_KEYCODE_RS	0x09	// MZ700J [Right SHIFT] key X-Y
+#define MZ700J_KEYCODE_ALPHA	0x41	// MZ700J [英数] key X-Y
+#define MZ700J_KEYCODE_KANA	0x71	// MZ700J [カナ] key X-Y
+#define MZ700J_KEYCODE_GRPH	0x61	// MZ700J [GRPH] key X-Y
+
+#define MZ80A_KEYCODE_BREAK	0xF1	// MZ80A [BREAK] key X-Y (SHIFT+CTRL)
+#define MZ80A_KEYCODE_CTRL	0x71	// MZ80A [CTRL] key X-Y
+#define MZ80A_KEYCODE_LS	0x01	// MZ80A [Left SHIFT] key X-Y
+#define MZ80A_KEYCODE_RS	0x01	// MZ80A [Right SHIFT] key X-Y
+//#define MZ80A_KEYCODE_ALPHA	0x11	// MZ80A [英数] key X-Y
+#define MZ80A_KEYCODE_ALPHA	0x12	// MZ80A [英数] key X-Y : 実機には無いキーを[ALPHA]専用に割り当てる 要パッチSA-1510: 0BF0, 0C38, 0C70: 00->C9
+#define MZ80A_KEYCODE_KANA	0x00	// MZ80A [カナ] key X-Y (No key)
+#define MZ80A_KEYCODE_GRPH	0x11	// MZ80A [GRPH] key X-Y
+
+#define MZ700E_KEYCODE_BREAK	0x79	// MZ700E [BREAK] key X-Y
+#define MZ700E_KEYCODE_CTRL	0x69	// MZ700E [CTRL] key X-Y
+#define MZ700E_KEYCODE_LS	0x09	// MZ700E [Left SHIFT] key X-Y
+#define MZ700E_KEYCODE_RS	0x09	// MZ700E [Right SHIFT] key X-Y
+#define MZ700E_KEYCODE_ALPHA	0x41	// MZ700E [英数] key X-Y
+#define MZ700E_KEYCODE_KANA	0x00	// MZ700E [カナ] key X-Y (No key)
+#define MZ700E_KEYCODE_GRPH	0x61	// MZ700E [GRPH] key X-Y
+
+
+// SYSTEM MODE (for switing ROM/KB MATRIX): 0-15
+uint16_t system_mode = SYSTEM_MODE_DEFAULT;
+
+// MZ KEYCODES FOR SPECIAL KEYS
+const uint8_t mz_keycode_break[16] = {
+  MZ1200_KEYCODE_BREAK,		// 0
+  MZ1200_KEYCODE_BREAK,		// 1
+  MZ1200_KEYCODE_BREAK,		// 2
+  MZ1200_KEYCODE_BREAK,		// 3
+  MZ700J_KEYCODE_BREAK,		// 4
+  MZ700J_KEYCODE_BREAK,		// 5
+  MZ700J_KEYCODE_BREAK,		// 6
+  MZ700J_KEYCODE_BREAK,		// 7
+  MZ80A_KEYCODE_BREAK,		// 8
+  MZ1200_KEYCODE_BREAK,		// 9
+  MZ80A_KEYCODE_BREAK,		// 10
+  MZ1200_KEYCODE_BREAK,		// 11
+  MZ700E_KEYCODE_BREAK,		// 12
+  MZ700J_KEYCODE_BREAK,		// 13
+  MZ700E_KEYCODE_BREAK,		// 14
+  MZ700J_KEYCODE_BREAK,		// 15
+};
+#define MZ_KEYCODE_BREAK	(mz_keycode_break[system_mode])
+const uint8_t mz_keycode_ctrl[16] = {
+  MZ1200_KEYCODE_CTRL,		// 0
+  MZ1200_KEYCODE_CTRL,		// 1
+  MZ1200_KEYCODE_CTRL,		// 2
+  MZ1200_KEYCODE_CTRL,		// 3
+  MZ700J_KEYCODE_CTRL,		// 4
+  MZ700J_KEYCODE_CTRL,		// 5
+  MZ700J_KEYCODE_CTRL,		// 6
+  MZ700J_KEYCODE_CTRL,		// 7
+  MZ80A_KEYCODE_CTRL,		// 8
+  MZ1200_KEYCODE_CTRL,		// 9
+  MZ80A_KEYCODE_CTRL,		// 10
+  MZ1200_KEYCODE_CTRL,		// 11
+  MZ700E_KEYCODE_CTRL,		// 12
+  MZ700J_KEYCODE_CTRL,		// 13
+  MZ700E_KEYCODE_CTRL,		// 14
+  MZ700J_KEYCODE_CTRL,		// 15
+};
+#define MZ_KEYCODE_CTRL	(mz_keycode_ctrl[system_mode])
+const uint8_t mz_keycode_ls[16] = {
+  MZ1200_KEYCODE_LS,		// 0
+  MZ1200_KEYCODE_LS,		// 1
+  MZ1200_KEYCODE_LS,		// 2
+  MZ1200_KEYCODE_LS,		// 3
+  MZ700J_KEYCODE_LS,		// 4
+  MZ700J_KEYCODE_LS,		// 5
+  MZ700J_KEYCODE_LS,		// 6
+  MZ700J_KEYCODE_LS,		// 7
+  MZ80A_KEYCODE_LS,		// 8
+  MZ1200_KEYCODE_LS,		// 9
+  MZ80A_KEYCODE_LS,		// 10
+  MZ1200_KEYCODE_LS,		// 11
+  MZ700E_KEYCODE_LS,		// 12
+  MZ700J_KEYCODE_LS,		// 13
+  MZ700E_KEYCODE_LS,		// 14
+  MZ700J_KEYCODE_LS,		// 15
+};
+#define MZ_KEYCODE_LS	(mz_keycode_ls[system_mode])
+const uint8_t mz_keycode_rs[16] = {
+  MZ1200_KEYCODE_RS,		// 0
+  MZ1200_KEYCODE_RS,		// 1
+  MZ1200_KEYCODE_RS,		// 2
+  MZ1200_KEYCODE_RS,		// 3
+  MZ700J_KEYCODE_RS,		// 4
+  MZ700J_KEYCODE_RS,		// 5
+  MZ700J_KEYCODE_RS,		// 6
+  MZ700J_KEYCODE_RS,		// 7
+  MZ80A_KEYCODE_RS,		// 8
+  MZ1200_KEYCODE_RS,		// 9
+  MZ80A_KEYCODE_RS,		// 10
+  MZ1200_KEYCODE_RS,		// 11
+  MZ700E_KEYCODE_RS,		// 12
+  MZ700J_KEYCODE_RS,		// 13
+  MZ700E_KEYCODE_RS,		// 14
+  MZ700J_KEYCODE_RS,		// 15
+};
+#define MZ_KEYCODE_RS	(mz_keycode_rs[system_mode])
+const uint8_t mz_keycode_alpha[16] = {
+  MZ1200_KEYCODE_ALPHA,		// 0
+  MZ1200_KEYCODE_ALPHA,		// 1
+  MZ1200_KEYCODE_ALPHA,		// 2
+  MZ1200_KEYCODE_ALPHA,		// 3
+  MZ700J_KEYCODE_ALPHA,		// 4
+  MZ700J_KEYCODE_ALPHA,		// 5
+  MZ700J_KEYCODE_ALPHA,		// 6
+  MZ700J_KEYCODE_ALPHA,		// 7
+  MZ80A_KEYCODE_ALPHA,		// 8
+  MZ1200_KEYCODE_ALPHA,		// 9
+  MZ80A_KEYCODE_ALPHA,		// 10
+  MZ1200_KEYCODE_ALPHA,		// 11
+  MZ700E_KEYCODE_ALPHA,		// 12
+  MZ700J_KEYCODE_ALPHA,		// 13
+  MZ700E_KEYCODE_ALPHA,		// 14
+  MZ700J_KEYCODE_ALPHA,		// 15
+};
+#define MZ_KEYCODE_ALPHA	(mz_keycode_alpha[system_mode])
+const uint8_t mz_keycode_kana[16] = {
+  MZ1200_KEYCODE_KANA,		// 0
+  MZ1200_KEYCODE_KANA,		// 1
+  MZ1200_KEYCODE_KANA,		// 2
+  MZ1200_KEYCODE_KANA,		// 3
+  MZ700J_KEYCODE_KANA,		// 4
+  MZ700J_KEYCODE_KANA,		// 5
+  MZ700J_KEYCODE_KANA,		// 6
+  MZ700J_KEYCODE_KANA,		// 7
+  MZ80A_KEYCODE_KANA,		// 8
+  MZ1200_KEYCODE_KANA,		// 9
+  MZ80A_KEYCODE_KANA,		// 10
+  MZ1200_KEYCODE_KANA,		// 11
+  MZ700E_KEYCODE_KANA,		// 12
+  MZ700J_KEYCODE_KANA,		// 13
+  MZ700E_KEYCODE_KANA,		// 14
+  MZ700J_KEYCODE_KANA,		// 15
+};
+#define MZ_KEYCODE_KANA	(mz_keycode_kana[system_mode])
+const uint8_t mz_keycode_grph[16] = {
+  MZ1200_KEYCODE_GRPH,		// 0
+  MZ1200_KEYCODE_GRPH,		// 1
+  MZ1200_KEYCODE_GRPH,		// 2
+  MZ1200_KEYCODE_GRPH,		// 3
+  MZ700J_KEYCODE_GRPH,		// 4
+  MZ700J_KEYCODE_GRPH,		// 5
+  MZ700J_KEYCODE_GRPH,		// 6
+  MZ700J_KEYCODE_GRPH,		// 7
+  MZ80A_KEYCODE_GRPH,		// 8
+  MZ1200_KEYCODE_GRPH,		// 9
+  MZ80A_KEYCODE_GRPH,		// 10
+  MZ1200_KEYCODE_GRPH,		// 11
+  MZ700E_KEYCODE_GRPH,		// 12
+  MZ700J_KEYCODE_GRPH,		// 13
+  MZ700E_KEYCODE_GRPH,		// 14
+  MZ700J_KEYCODE_GRPH,		// 15
+};
+#define MZ_KEYCODE_GRPH	(mz_keycode_grph[system_mode])
+
+
+typedef const uint8_t keycode2SYX_t[256][7];
+/* MZ-1200 USB KB scan code to MZ switch matrix code
+     w/o SHIFT        , w/ SHIFT         , kana             , kana+shift       , ALT (=GRPH)      , GRPH+shift       , RAW */
+static keycode2SYX_t keycode2MZ1200SYX =  {
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x00   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x01   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x02   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x03   */ \
+    {0x05             , 0x05|MZ_SHIFT    , 0x05             , 0x76             , 0x54             , 0x54             , 0x05             }, /* 0x04:a */ \
+    {0x27             , 0x27|MZ_SHIFT    , 0x27             , 0                , 0x76             , 0x76             , 0x27             }, /* 0x05:b */ \
+    {0x17             , 0x17|MZ_SHIFT    , 0x17             , 0                , 0x66             , 0x66             , 0x17             }, /* 0x06:c */ \
+    {0x15             , 0x15|MZ_SHIFT    , 0x15             , 0x7a             , 0x64             , 0x64             , 0x15             }, /* 0x07:d */ \
+    {0x13             , 0x13|MZ_SHIFT    , 0x13             , 0x64             , 0x62             , 0x62             , 0x13             }, /* 0x08:e */ \
+    {0x16             , 0x16|MZ_SHIFT    , 0x16             , 0                , 0x73             , 0x73             , 0x16             }, /* 0x09:f */ \
+    {0x25             , 0x25|MZ_SHIFT    , 0x25             , 0                , 0x74             , 0x74             , 0x25             }, /* 0x0a:g */ \
+    {0x26             , 0x26|MZ_SHIFT    , 0x26             , 0                , 0x5a             , 0x5a             , 0x26             }, /* 0x0b:h */ \
+    {0x34             , 0x38|MZ_SHIFT    , 0x34             , 0                , 0x68             , 0x68             , 0x34             }, /* 0x0c:i */ \
+    {0x35             , 0x35|MZ_SHIFT    , 0x35             , 0                , 0x69             , 0x69             , 0x35             }, /* 0x0d:j */ \
+    {0x36             , 0x36|MZ_SHIFT    , 0x36             , 0                , 0x6a             , 0x6a             , 0x36             }, /* 0x0e:k */ \
+    {0x45             , 0x45|MZ_SHIFT    , 0x45             , 0                , 0x79             , 0x79             , 0x45             }, /* 0x0f:l */ \
+\
+    {0x37             , 0x37|MZ_SHIFT    , 0x37             , 0                , 0                , 0                , 0x37             }, /* 0x10:m */ \
+    {0x28             , 0x28|MZ_SHIFT    , 0x28             , 0                , 0                , 0                , 0x28             }, /* 0x11:n */ \
+    {0x43             , 0x47|MZ_SHIFT    , 0x43             , 0                , 0x77             , 0x77             , 0x43             }, /* 0x12:o */ \
+    {0x44             , 0x44|MZ_SHIFT    , 0x44             , 0                , 0x78             , 0x78             , 0x44             }, /* 0x13:p */ \
+    {0x03             , 0x42|MZ_SHIFT    , 0x03             , 0x72             , 0x52             , 0x52             , 0x03             }, /* 0x14:q/[Pi] */ \
+    {0x14             , 0x46|MZ_SHIFT    , 0x14             , 0                , 0x71             , 0x71             , 0x14             }, /* 0x15:r */ \
+    {0x06             , 0x06|MZ_SHIFT    , 0x06             , 0x78             , 0x63             , 0x63             , 0x06             }, /* 0x16:s */ \
+    {0x23             , 0x55|MZ_SHIFT    , 0x23             , 0                , 0x72             , 0x72             , 0x23             }, /* 0x17:t */ \
+    {0x33             , 0x33|MZ_SHIFT    , 0x33             , 0                , 0x67             , 0x67             , 0x33             }, /* 0x18:u */ \
+    {0x18             , 0x18|MZ_SHIFT    , 0x18             , 0                , 0x75             , 0x75             , 0x18             }, /* 0x19:v */ \
+    {0x04             , 0                , 0x04             , 0x74             , 0x61             , 0x61             , 0x04             }, /* 0x1a:w */ \
+    {0x08             , 0x08|MZ_SHIFT    , 0x08             , 0                , 0x65             , 0x65             , 0x08             }, /* 0x1b:x */ \
+    {0x24             , 0x55             , 0x24             , 0                , 0x58             , 0x58             , 0x24             }, /* 0x1c:y */ \
+    {0x07             , 0x07|MZ_SHIFT    , 0x07             , 0x77             , 0x56             , 0x56             , 0x07             }, /* 0x1d:z */ \
+    {0x01             , 0x01|MZ_SHIFT    , 0x01             , 0                , 0                , 0                , 0x01             }, /* 0x1e:1/! */ \
+    {0x02             , 0x02|MZ_SHIFT    , 0x02             , 0                , 0                , 0                , 0x02             }, /* 0x1f:2/" */ \
+\
+    {0x11             , 0x11|MZ_SHIFT    , 0x11             , 0x62             , 0                , 0                , 0x11             }, /* 0x20:3/# */ \
+    {0x12             , 0x12|MZ_SHIFT    , 0x12             , 0x66             , 0                , 0                , 0x12             }, /* 0x21:4/$ */ \
+    {0x21             , 0x21|MZ_SHIFT    , 0x21             , 0x68             , 0                , 0                , 0x21             }, /* 0x22:5/% */ \
+    {0x22             , 0x22|MZ_SHIFT    , 0x22             , 0x6a             , 0                , 0                , 0x22             }, /* 0x23:6/& */ \
+    {0x31             , 0x31|MZ_SHIFT    , 0x31             , 0x71             , 0                , 0                , 0x31             }, /* 0x24:7/' */ \
+    {0x32             , 0x32|MZ_SHIFT    , 0x32             , 0x73             , 0                , 0                , 0x32             }, /* 0x25:8/( */ \
+    {0x41             , 0x41|MZ_SHIFT    , 0x41             , 0x75             , 0                , 0                , 0x41             }, /* 0x26:9/) */ \
+    {0x42             , 0x42|MZ_SHIFT    , 0x42             , 0x56             , 0                , 0                , 0x42             }, /* 0x27:0 */ \
+    {0x49             , 0x49|MZ_SHIFT    , 0x49             , 0                , 0                , 0                , 0x49             }, /* 0x28:[RETURN] */ \
+    {0x1a|MZ_SHIFT    , 0x1a|MZ_SHIFT    , 0x1a|MZ_SHIFT    , 0                , 0                , 0                , 0                }, /* 0x29:[ESC] = SHIFT+SPACE In Hu-BASIC */ \
+    {0x19             , 0x19|MZ_SHIFT    , 0x19             , 0x19|MZ_SHIFT    , 0                , 0                , 0x19             }, /* 0x2a:[BS] = [INST/DEL] key */ \
+    {0x0a             , 0x0a|MZ_SHIFT    , 0x0a             , 0x0a|MZ_SHIFT    , 0                , 0                , 0x0a             }, /* 0x2b:[TAB] = Assign as [HOME/CLR] */ \
+    {0x1a             , 0x1a|MZ_SHIFT    , 0x1a             , 0x1a|MZ_SHIFT    , 0                , 0                , 0x1a             }, /* 0x2c:[SPACE] */ \
+    {0x51             , 0x53             , 0x51             , 0                , 0                , 0                , 0x51             }, /* 0x2d:-/= : Different key when SHIFT */ \
+    {0x44|MZ_SHIFT    , 0x54|MZ_SHIFT    , 0x53             , 0                , 0                , 0                , 0                }, /* 0x2e:^/~ = [Upper arrow] */ \
+    {0x33|MZ_SHIFT    , 0                , 0x5a             , 0                , 0                , 0                , 0x53             }, /* 0x2f:@/` = @ */ \
+\
+    {0x14|MZ_SHIFT    , 0                , 0x58             , 0x61             , 0                , 0                , 0                }, /* 0x30:[/「 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x31:NA */ \
+    {0x23|MZ_SHIFT    , 0                , 0x54             , 0x63             , 0                , 0                , 0                }, /* 0x32:]/」  */ \
+    {0x46             , 0x51|MZ_SHIFT    , 0x46             , 0                , 0x7a             , 0x7a             , 0x46             }, /* 0x33:;/+ */ \
+    {0x43|MZ_SHIFT    , 0x53|MZ_SHIFT    , 0x52             , 0                , 0                , 0                , 0x55             }, /* 0x34:':'/'*' */ \
+    {0x3a             , 0x3a|MZ_SHIFT    , 0x3a             , 0x3a|MZ_SHIFT    , 0                , 0                , 0x3a             }, /* 0x35 ZEN/HAN = [BREAK] key */ \
+    {0x38             , 0x03|MZ_SHIFT    , 0x38             , 0x65             , 0                , 0                , 0x38             }, /* 0x36:,/< */ \
+    {0x47             , 0x04|MZ_SHIFT    , 0x47             , 0x69             , 0                , 0                , 0x47             }, /* 0x37:./> */ \
+    {0x48             , 0x34|MZ_SHIFT    , 0x48             , 0x67             , 0                , 0                , 0x48             }, /* 0x38:'/'/'?' */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x57             }, /* 0x39: [CAPS] = assaign as [カナ/英数] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3a:[F1] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3b:[F2] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3c:[F3] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3d:[F4] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3e:[F5] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3f:[F6] */ \
+\
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x40:[F7] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x41:[F8] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x42:[F9] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x43:[F10] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x44 [F11] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x45:[F12] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x46 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x47 */ \
+    {0x3a             , 0x3a|MZ_SHIFT    , 0x3a             , 0x3a|MZ_SHIFT    , 0                , 0                , 0x3a             }, /* 0x48 Pause/Break */ \
+    {0x19|MZ_SHIFT    , 0x19             , 0x19|MZ_SHIFT    , 0x19             , 0                , 0                , 0                }, /* 0x49 Insert = SHIFT + [DEL/INST] */ \
+    {0x0a             , 0x0a|MZ_SHIFT    , 0x0a             , 0x0a|MZ_SHIFT    , 0                , 0                , 0x0a             }, /* 0x4a Home = [HOME/CLR] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x4b PgUp = [] */ \
+    {0x19             , 0x19|MZ_SHIFT    , 0x19             , 0x19|MZ_SHIFT    , 0                , 0                , 0x19             }, /* 0x4c Delete = [DEL/INST] key */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x4d End */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x57             }, /* 0x4e:PgDn = [KANA] */ \
+    {0x39             , 0x39|MZ_SHIFT    , 0x39             , 0x39|MZ_SHIFT    , 0                , 0                , 0x39             }, /* 0x4f right arrow */ \
+\
+    {0x39|MZ_SHIFT    , 0x39             , 0x39|MZ_SHIFT    , 0x39             , 0                , 0                , 0                }, /* 0x50 left arrow */ \
+    {0x2a             , 0x2a|MZ_SHIFT    , 0x2a             , 0x2a|MZ_SHIFT    , 0                , 0                , 0x2a             }, /* 0x51 down arrow */ \
+    {0x2a|MZ_SHIFT    , 0x2a             , 0x2a|MZ_SHIFT    , 0x2a             , 0                , 0                , 0                }, /* 0x52 up arrow */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x53 */ \
+    {0x48             , 0x48|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x47             }, /* 0x54:/ */ \
+    {0x53|MZ_SHIFT    , 0x53|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0                }, /* 0x55:* */ \
+    {0x51             , 0x51|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x51             }, /* 0x56:- */ \
+    {0x51|MZ_SHIFT    , 0x51|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0                }, /* 0x57:+ */ \
+    {0x49             , 0x49|MZ_SHIFT    , 0x49             , 0x49|MZ_SHIFT    , 0                , 0                , 0x49             }, /* 0x58:[RETURN] */ \
+    {0x01             , 0x01|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x01             }, /* 0x59:1 */ \
+    {0x02             , 0x02|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x02             }, /* 0x5a:2 */ \
+    {0x11             , 0x11|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x11             }, /* 0x5b:3 */ \
+    {0x12             , 0x12|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x12             }, /* 0x5c:4 */ \
+    {0x21             , 0x21|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x21             }, /* 0x5d:5 */ \
+    {0x22             , 0x22|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x22             }, /* 0x5e:6 */ \
+    {0x31             , 0x31|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x31             }, /* 0x5f:7 */ \
+\
+    {0x32             , 0x32|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x32             }, /* 0x60:8 */ \
+    {0x41             , 0x41|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x41             }, /* 0x61:9 */ \
+    {0x42             , 0x42|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x42             }, /* 0x62:0 */ \
+    {0x47             , 0x47|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x47             }, /* 0x63:. */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x64 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x65:[Application] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x66 */ \
+    {0x53             , 0x53|MZ_SHIFT    , 0                , 0                , 0                , 0                , 0x53             }, /* 0x67:= */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x68 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x69 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x70 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x71 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x72 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x73 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x74 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x75 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x76 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x77 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x78 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x79 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x80 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x81 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x82 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x83 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x84 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x85 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x86 */ \
+    {0x24|MZ_SHIFT    , 0x5a             , 0x55             , 0                , 0                , 0                , 0x48             }, /* 0x87:[Backslash]/_ key, '←' */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x57             }, /* 0x88:[Hiragana/Katakana] = [カナ/英数]=カナ */ \
+    {0x7a             , 0x65             , 0x72             , 0                , 0                , 0                , 0x24             }, /* 0x89:[Yen]/[|] key */ \
+};
+
+/* MZ-700J USB KB scan code to MZ switch matrix code
+     w/o SHIFT        , w/ SHIFT         , kana             , kana+shift       , GRPH             , GRPH+shift       , RAW */
+static keycode2SYX_t keycode2MZ700JSYX =  {
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x00   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x01   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x02   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x03   */ \
+    {0x75             , 0x75|MZ_SHIFT    , 0x03             , 0                , 0x75             , 0x75|MZ_SHIFT    , 0x75             }, /* 0x04:a/ち */ \
+    {0x65             , 0x65|MZ_SHIFT    , 0x43             , 0                , 0x65             , 0x65|MZ_SHIFT    , 0x65             }, /* 0x05:b/こ */ \
+    {0x55             , 0x55|MZ_SHIFT    , 0x15             , 0                , 0x55             , 0x55|MZ_SHIFT    , 0x55             }, /* 0x06:c/そ */ \
+    {0x45             , 0x45|MZ_SHIFT    , 0x53             , 0                , 0x45             , 0x45|MZ_SHIFT    , 0x45             }, /* 0x07:d/し */ \
+    {0x35             , 0x35|MZ_SHIFT    , 0x66             , 0x66|MZ_SHIFT    , 0x35             , 0x35|MZ_SHIFT    , 0x35             }, /* 0x08:e/い */ \
+    {0x25             , 0x25|MZ_SHIFT    , 0x72             , 0                , 0x25             , 0x25|MZ_SHIFT    , 0x25             }, /* 0x09:f/は */ \
+    {0x15             , 0x15|MZ_SHIFT    , 0x13             , 0                , 0x15             , 0x15|MZ_SHIFT    , 0x15             }, /* 0x0a:g/き */ \
+    {0x05             , 0x05|MZ_SHIFT    , 0x35             , 0                , 0x05             , 0x05|MZ_SHIFT    , 0x05             }, /* 0x0b:h/く */ \
+    {0x74             , 0x74|MZ_SHIFT    , 0x16             , 0                , 0x74             , 0x74|MZ_SHIFT    , 0x74             }, /* 0x0c:i/に */ \
+    {0x64             , 0x64|MZ_SHIFT    , 0x05             , 0                , 0x64             , 0x64|MZ_SHIFT    , 0x64             }, /* 0x0d:j/ま */ \
+    {0x54             , 0x54|MZ_SHIFT    , 0x37             , 0                , 0x54             , 0x54|MZ_SHIFT    , 0x54             }, /* 0x0e:k/の */ \
+    {0x44             , 0x44|MZ_SHIFT    , 0x34             , 0                , 0x44             , 0x44|MZ_SHIFT    , 0x44             }, /* 0x0f:l/り */ \
+\
+    {0x34             , 0x34|MZ_SHIFT    , 0x21             , 0                , 0x34             , 0x34|MZ_SHIFT    , 0x34             }, /* 0x10:m/も */ \
+    {0x24             , 0x24|MZ_SHIFT    , 0x64             , 0                , 0x24             , 0x24|MZ_SHIFT    , 0x24             }, /* 0x11:n/み */ \
+    {0x14             , 0x14|MZ_SHIFT    , 0x24             , 0                , 0x14             , 0x14|MZ_SHIFT    , 0x14             }, /* 0x12:o/ら */ \
+    {0x04             , 0x04|MZ_SHIFT    , 0x25             , 0                , 0x04             , 0x04|MZ_SHIFT    , 0x04             }, /* 0x13:p/せ */ \
+    {0x73             , 0x73|MZ_SHIFT    , 0x62             , 0                , 0x73             , 0x73|MZ_SHIFT    , 0x73             }, /* 0x14:q/た */ \
+    {0x63             , 0x63|MZ_SHIFT    , 0x45             , 0                , 0x63             , 0x63|MZ_SHIFT    , 0x63             }, /* 0x15:r/す */ \
+    {0x53             , 0x53|MZ_SHIFT    , 0x65             , 0                , 0x53             , 0x53|MZ_SHIFT    , 0x53             }, /* 0x16:s/と */ \
+    {0x43             , 0x43|MZ_SHIFT    , 0x73             , 0                , 0x43             , 0x43|MZ_SHIFT    , 0x43             }, /* 0x17:t/か */ \
+    {0x33             , 0x33|MZ_SHIFT    , 0x26             , 0                , 0x33             , 0x33|MZ_SHIFT    , 0x33             }, /* 0x18:u/な */ \
+    {0x23             , 0x23|MZ_SHIFT    , 0x33             , 0                , 0x23             , 0x23|MZ_SHIFT    , 0x23             }, /* 0x19:v/ひ */ \
+    {0x13             , 0x13|MZ_SHIFT    , 0x23             , 0                , 0x13             , 0x13|MZ_SHIFT    , 0x13             }, /* 0x1a:w/て */ \
+    {0x03             , 0x03|MZ_SHIFT    , 0x75             , 0                , 0x03             , 0x03|MZ_SHIFT    , 0x03             }, /* 0x1b:x/さ */ \
+    {0x72             , 0x72|MZ_SHIFT    , 0x51             , 0                , 0x72             , 0x72|MZ_SHIFT    , 0x72             }, /* 0x1c:y/ん */ \
+    {0x62             , 0x62|MZ_SHIFT    , 0x55             , 0x55|MZ_SHIFT    , 0x62             , 0x62|MZ_SHIFT    , 0x62             }, /* 0x1d:z/つ */ \
+    {0x76             , 0x76|MZ_SHIFT    , 0x06             , 0                , 0x76             , 0x76|MZ_SHIFT    , 0x76             }, /* 0x1e:1/!/ぬ */ \
+    {0x66             , 0x66|MZ_SHIFT    , 0x74             , 0                , 0x66             , 0x66|MZ_SHIFT    , 0x66             }, /* 0x1f:2/"/ふ */ \
+\
+    {0x56             , 0x56|MZ_SHIFT    , 0x76             , 0x76|MZ_SHIFT    , 0x56             , 0x56|MZ_SHIFT    , 0x56             }, /* 0x20:3/#/あ */ \
+    {0x46             , 0x46|MZ_SHIFT    , 0x56             , 0x56|MZ_SHIFT    , 0x46             , 0x46|MZ_SHIFT    , 0x46             }, /* 0x21:4/$/う */ \
+    {0x36             , 0x36|MZ_SHIFT    , 0x46             , 0x46|MZ_SHIFT    , 0x36             , 0x36|MZ_SHIFT    , 0x36             }, /* 0x22:5/%/え */ \
+    {0x26             , 0x26|MZ_SHIFT    , 0x36             , 0x36|MZ_SHIFT    , 0x26             , 0x26|MZ_SHIFT    , 0x26             }, /* 0x23:6/&/お */ \
+    {0x16             , 0x16|MZ_SHIFT    , 0x57             , 0x57|MZ_SHIFT    , 0x16             , 0x16|MZ_SHIFT    , 0x16             }, /* 0x24:7/'/や */ \
+    {0x06             , 0x42             , 0x67             , 0x67|MZ_SHIFT    , 0x06             , 0x06|MZ_SHIFT    , 0x06             }, /* 0x25:8/[/ゆ */ \
+    {0x27             , 0x32             , 0x77             , 0x77|MZ_SHIFT    , 0x27             , 0x27|MZ_SHIFT    , 0x27             }, /* 0x26:9/]/よ */ \
+    {0x37             , 0x37|MZ_SHIFT    , 0x52             , 0x42             , 0x37             , 0x37|MZ_SHIFT    , 0x37             }, /* 0x27:0/[Pi]/わ/を */ \
+    {0x01             , 0x01|MZ_SHIFT    , 0x01             , 0x01|MZ_SHIFT    , 0x01             , 0x01|MZ_SHIFT    , 0x01             }, /* 0x28:[RETURN] */ \
+    {0x47|MZ_SHIFT    , 0x47|MZ_SHIFT    , 0x47|MZ_SHIFT    , 0x47|MZ_SHIFT    , 0x47|MZ_SHIFT    , 0x47|MZ_SHIFT    , 0                }, /* 0x29:[ESC] = SHIFT+SPACE In Hu-BASIC */ \
+    {0x68             , 0x68             , 0x68             , 0x68             , 0x68             , 0x68             , 0x68             }, /* 0x2a:[BS] = [DEL] key */ \
+    {0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0                }, /* 0x2b:[TAB] = Assign as [HOME]=[SHIFT]+[DEL]/[CLR]=[SHIFT]+[INST] */ \
+    {0x47             , 0x47|MZ_SHIFT    , 0x47             , 0x47|MZ_SHIFT    , 0x47             , 0x47|MZ_SHIFT    , 0x47             }, /* 0x2c:[SPACE] */ \
+    {0x57             , 0x51|MZ_SHIFT    , 0x04             , 0                , 0x57             , 0x57|MZ_SHIFT    , 0x57             }, /* 0x2d:'-'/'='/ほ */ \
+    {0x42|MZ_SHIFT    , 0x67|MZ_SHIFT    , 0x14             , 0                , 0                , 0                , 0x51             }, /* 0x2e:'^'/'~'/へ = [Upper arrow]/￡ */ \
+    {0x52             , 0x52|MZ_SHIFT    , 0x11             , 0                , 0x52             , 0x52|MZ_SHIFT    , 0x52             }, /* 0x2f:'@'/'`'/゛ */ \
+\
+    {0x16|MZ_SHIFT    , 0x42|MZ_SHIFT    , 0x32             , 042|MZ_SHIFT     , 0x42             , 0x42|MZ_SHIFT    , 0x42             }, /* 0x30:'['/'{'/゜/「 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x31: */ \
+    {0x27|MZ_SHIFT    , 0x32|MZ_SHIFT    , 0x54             , 0x32|MZ_SHIFT    , 0x32             , 0x32|MZ_SHIFT    , 0x32             }, /* 0x32:']'/'}'/む/」  */ \
+    {0x21             , 0x67             , 0x07             , 0                , 0x21             , 0x21|MZ_SHIFT    , 0x21             }, /* 0x33:';'/'+'/れ */ \
+    {0x11             , 0x77             , 0x63             , 0                , 0                , 0                , 0x11             }, /* 0x34:':'/'*'/け */ \
+    {0x79             , 0x79|MZ_SHIFT    , 0x79             , 0x79|MZ_SHIFT    , 0x79             , 0x79|MZ_SHIFT    , 0x79             }, /* 0x35 ZEN/HAN = [BREAK] key */ \
+    {0x17             , 0x17|MZ_SHIFT    , 0x37             , 0x17|MZ_SHIFT    , 0x17             , 0x17|MZ_SHIFT    , 0x17             }, /* 0x36:','/'<'/ね/、 */ \
+    {0x07             , 0x07|MZ_SHIFT    , 0x17             , 0x07|MZ_SHIFT    , 0x07             , 0x07|MZ_SHIFT    , 0x07             }, /* 0x37:'.'/'>'/る/。 */ \
+    {0x08             , 0x18             , 0x44             , 0                , 0x08             , 0x08|MZ_SHIFT    , 0x08             }, /* 0x38:'/'/'?'/め/・ */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x41             }, /* 0x39: [CAPS] = assaign as [英数] */ \
+    {0x7a             , 0x7a|MZ_SHIFT    , 0x7a             , 0x7a|MZ_SHIFT    , 0x7a             , 0x7a|MZ_SHIFT    , 0x7a             }, /* 0x3a:[F1] */ \
+    {0x6a             , 0x6a|MZ_SHIFT    , 0x6a             , 0x6a|MZ_SHIFT    , 0x6a             , 0x6a|MZ_SHIFT    , 0x6a             }, /* 0x3b:[F2] */ \
+    {0x5a             , 0x5a|MZ_SHIFT    , 0x5a             , 0x5a|MZ_SHIFT    , 0x5a             , 0x5a|MZ_SHIFT    , 0x5a             }, /* 0x3c:[F3] */ \
+    {0x4a             , 0x4a|MZ_SHIFT    , 0x4a             , 0x4a|MZ_SHIFT    , 0x4a             , 0x4a|MZ_SHIFT    , 0x4a             }, /* 0x3d:[F4] */ \
+    {0x3a             , 0x3a|MZ_SHIFT    , 0x3a             , 0x3a|MZ_SHIFT    , 0x3a             , 0x3a|MZ_SHIFT    , 0x3a             }, /* 0x3e:[F5] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3f:[F6] */ \
+\
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x40:[F7] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x41:[F8] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x42:[F9] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x43:[F10] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x44 [F11] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x45:[F12] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x46 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x47 */ \
+    {0x79             , 0x79|MZ_SHIFT    , 0x79             , 0x79|MZ_SHIFT    , 0x79             , 0x79|MZ_SHIFT    , 0x79             }, /* 0x48 Pause/Break = [BREAK] */ \
+    {0x78             , 0x78             , 0x78             , 0x78             , 0x78             , 0x78             , 0x78             }, /* 0x49 Insert = [INST] */ \
+    {0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0x68             , 0x78             , 0                }, /* 0x4a Home = [SHIFT]+[DEL] / [SHIFT]+[INST] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x61             }, /* 0x4b PgUp = [GRPH] */ \
+    {0x68             , 0x68             , 0x68             , 0x68             , 0x68             , 0x68             , 0x68             }, /* 0x4c Delete = [DEL] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x4d End */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x71             }, /* 0x4e PgDn = [KANA] */ \
+    {0x38             , 0x38|MZ_SHIFT    , 0x38             , 0x38|MZ_SHIFT    , 0x38             , 0x38|MZ_SHIFT    , 0x38             }, /* 0x4f right arrow */ \
+\
+    {0x28             , 0x28|MZ_SHIFT    , 0x28             , 0x28|MZ_SHIFT    , 0x28             , 0x28|MZ_SHIFT    , 0x28             }, /* 0x50 left arrow */ \
+    {0x48             , 0x48|MZ_SHIFT    , 0x48             , 0x48|MZ_SHIFT    , 0x48             , 0x48|MZ_SHIFT    , 0x48             }, /* 0x51 down arrow */ \
+    {0x58             , 0x58|MZ_SHIFT    , 0x58             , 0x58|MZ_SHIFT    , 0x58             , 0x58|MZ_SHIFT    , 0x58             }, /* 0x52 up arrow */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x53 NumLock */ \
+    {0x08             , 0x08|MZ_SHIFT    , 0x08             , 0x08|MZ_SHIFT    , 0x08             , 0x08|MZ_SHIFT    , 0x08             }, /* 0x54:/ */ \
+    {0x77             , 0x77|MZ_SHIFT    , 0x77             , 0x77|MZ_SHIFT    , 0x77             , 0x77|MZ_SHIFT    , 0x77             }, /* 0x55:* */ \
+    {0x57             , 0x57|MZ_SHIFT    , 0x57             , 0x57|MZ_SHIFT    , 0x57             , 0x57|MZ_SHIFT    , 0x57             }, /* 0x56:- */ \
+    {0x67             , 0x67|MZ_SHIFT    , 0x67             , 0x67|MZ_SHIFT    , 0x67             , 0x67|MZ_SHIFT    , 0x67             }, /* 0x57:+ */ \
+    {0x01             , 0x01|MZ_SHIFT    , 0x01             , 0x01|MZ_SHIFT    , 0x01             , 0x01|MZ_SHIFT    , 0x01             }, /* 0x58:[RETURN] */ \
+    {0x76             , 0x76|MZ_SHIFT    , 0x76             , 0x76|MZ_SHIFT    , 0x76             , 0x76|MZ_SHIFT    , 0x76             }, /* 0x59:1 */ \
+    {0x66             , 0x66|MZ_SHIFT    , 0x66             , 0x66|MZ_SHIFT    , 0x66             , 0x66|MZ_SHIFT    , 0x66             }, /* 0x5a:2 */ \
+    {0x56             , 0x56|MZ_SHIFT    , 0x56             , 0x56|MZ_SHIFT    , 0x56             , 0x56|MZ_SHIFT    , 0x56             }, /* 0x5b:3 */ \
+    {0x46             , 0x46|MZ_SHIFT    , 0x46             , 0x46|MZ_SHIFT    , 0x46             , 0x46|MZ_SHIFT    , 0x46             }, /* 0x5c:4 */ \
+    {0x36             , 0x36|MZ_SHIFT    , 0x36             , 0x36|MZ_SHIFT    , 0x36             , 0x36|MZ_SHIFT    , 0x36             }, /* 0x5d:5 */ \
+    {0x26             , 0x26|MZ_SHIFT    , 0x26             , 0x26|MZ_SHIFT    , 0x26             , 0x26|MZ_SHIFT    , 0x26             }, /* 0x5e:6 */ \
+    {0x16             , 0x16|MZ_SHIFT    , 0x16             , 0x16|MZ_SHIFT    , 0x16             , 0x16|MZ_SHIFT    , 0x16             }, /* 0x5f:7 */ \
+\
+    {0x06             , 0x06|MZ_SHIFT    , 0x06             , 0x06|MZ_SHIFT    , 0x06             , 0x06|MZ_SHIFT    , 0x06             }, /* 0x60:8 */ \
+    {0x27             , 0x27|MZ_SHIFT    , 0x27             , 0x27|MZ_SHIFT    , 0x27             , 0x27|MZ_SHIFT    , 0x27             }, /* 0x61:9 */ \
+    {0x37             , 0x37|MZ_SHIFT    , 0x37             , 0x37|MZ_SHIFT    , 0x37             , 0x37|MZ_SHIFT    , 0x37             }, /* 0x62:0 */ \
+    {0x07             , 0x07|MZ_SHIFT    , 0x07             , 0x07|MZ_SHIFT    , 0x07             , 0x07|MZ_SHIFT    , 0x01             }, /* 0x63:. */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x64 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x65:[Application] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x66 */ \
+    {0x51             , 0x51|MZ_SHIFT    , 0x51             , 0x51|MZ_SHIFT    , 0x51             , 0x51|MZ_SHIFT    , 0x51             }, /* 0x67:= */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x68 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x69 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x70 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x71 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x72 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x73 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x74 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x75 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x76 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x77 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x78 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x79 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x80 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x81 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x82 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x83 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x84 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x85 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x86 */ \
+    {0x57|MZ_SHIFT    , 0x08|MZ_SHIFT    , 0x08             , 0                , 0                , 0                , 0x18             }, /* 0x87:[Backslash]/_/ろ key = [￥][←][/] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x71             }, /* 0x88:[Hiragana/Katakana] = [カナ] */ \
+    {0x57|MZ_SHIFT    , 0x18|MZ_SHIFT    , 0x18             , 0                , 0                , 0                , 0x24             }, /* 0x89:[Yen]/[|]/ー key = [￥][→] */ \
+};
+
+/* MZ-80A USB KB scan code to MZ switch matrix code
+     w/o SHIFT        , w/ SHIFT         , kana             , kana+shift       , GRPH             , GRPH+shift       , RAW */
+static keycode2SYX_t keycode2MZ80ASYX =  {
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x00   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x01   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x02   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x03   */ \
+    {0x32             , 0x32|MZ_SHIFT    , 0                , 0                , 0x32             , 0x32|MZ_SHIFT    , 0x32             }, /* 0x04:a */ \
+    {0x04             , 0x04|MZ_SHIFT    , 0                , 0                , 0x04             , 0x04|MZ_SHIFT    , 0x04             }, /* 0x05:b */ \
+    {0x03             , 0x03|MZ_SHIFT    , 0                , 0                , 0x03             , 0x03|MZ_SHIFT    , 0x03             }, /* 0x06:c */ \
+    {0x33             , 0x33|MZ_SHIFT    , 0                , 0                , 0x33             , 0x33|MZ_SHIFT    , 0x33             }, /* 0x07:d */ \
+    {0x43             , 0x43|MZ_SHIFT    , 0                , 0                , 0x43             , 0x43|MZ_SHIFT    , 0x43             }, /* 0x08:e */ \
+    {0x24             , 0x24|MZ_SHIFT    , 0                , 0                , 0x24             , 0x24|MZ_SHIFT    , 0x24             }, /* 0x09:f */ \
+    {0x34             , 0x34|MZ_SHIFT    , 0                , 0                , 0x34             , 0x34|MZ_SHIFT    , 0x34             }, /* 0x0a:g */ \
+    {0x25             , 0x25|MZ_SHIFT    , 0                , 0                , 0x25             , 0x25|MZ_SHIFT    , 0x25             }, /* 0x0b:h */ \
+    {0x55             , 0x55|MZ_SHIFT    , 0                , 0                , 0x55             , 0x55|MZ_SHIFT    , 0x55             }, /* 0x0c:i */ \
+    {0x35             , 0x35|MZ_SHIFT    , 0                , 0                , 0x35             , 0x35|MZ_SHIFT    , 0x35             }, /* 0x0d:j */ \
+    {0x26             , 0x26|MZ_SHIFT    , 0                , 0                , 0x26             , 0x26|MZ_SHIFT    , 0x26             }, /* 0x0e:k */ \
+    {0x36             , 0x36|MZ_SHIFT    , 0                , 0                , 0x36             , 0x36|MZ_SHIFT    , 0x36             }, /* 0x0f:l */ \
+\
+    {0x06             , 0x06|MZ_SHIFT    , 0                , 0                , 0x06             , 0x06|MZ_SHIFT    , 0x06             }, /* 0x10:m */ \
+    {0x15             , 0x15|MZ_SHIFT    , 0                , 0                , 0x15             , 0x15|MZ_SHIFT    , 0x15             }, /* 0x11:n */ \
+    {0x46             , 0x46|MZ_SHIFT    , 0                , 0                , 0x46             , 0x46|MZ_SHIFT    , 0x46             }, /* 0x12:o */ \
+    {0x56             , 0x56|MZ_SHIFT    , 0                , 0                , 0x56             , 0x56|MZ_SHIFT    , 0x56             }, /* 0x13:p */ \
+    {0x42             , 0x42|MZ_SHIFT    , 0                , 0                , 0x42             , 0x42|MZ_SHIFT    , 0x42             }, /* 0x14:q */ \
+    {0x53             , 0x53|MZ_SHIFT    , 0                , 0                , 0x53             , 0x53|MZ_SHIFT    , 0x53             }, /* 0x15:r */ \
+    {0x23             , 0x23|MZ_SHIFT    , 0                , 0                , 0x23             , 0x23|MZ_SHIFT    , 0x23             }, /* 0x16:s */ \
+    {0x44             , 0x44|MZ_SHIFT    , 0                , 0                , 0x44             , 0x44|MZ_SHIFT    , 0x44             }, /* 0x17:t */ \
+    {0x45             , 0x45|MZ_SHIFT    , 0                , 0                , 0x45             , 0x45|MZ_SHIFT    , 0x45             }, /* 0x18:u */ \
+    {0x14             , 0x14|MZ_SHIFT    , 0                , 0                , 0x14             , 0x14|MZ_SHIFT    , 0x14             }, /* 0x19:v */ \
+    {0x52             , 0x52|MZ_SHIFT    , 0                , 0                , 0x52             , 0x52|MZ_SHIFT    , 0x52             }, /* 0x1a:w */ \
+    {0x13             , 0x13|MZ_SHIFT    , 0                , 0                , 0x13             , 0x13|MZ_SHIFT    , 0x13             }, /* 0x1b:x */ \
+    {0x54             , 0x54|MZ_SHIFT    , 0                , 0                , 0x54             , 0x54|MZ_SHIFT    , 0x54             }, /* 0x1c:y */ \
+    {0x02             , 0x02|MZ_SHIFT    , 0                , 0                , 0x02             , 0x02|MZ_SHIFT    , 0x02             }, /* 0x1d:z */ \
+    {0x62             , 0x62|MZ_SHIFT    , 0                , 0                , 0x62             , 0x62|MZ_SHIFT    , 0x62             }, /* 0x1e:1/! */ \
+    {0x72             , 0x72|MZ_SHIFT    , 0                , 0                , 0x72             , 0x72|MZ_SHIFT    , 0x72             }, /* 0x1f:2/" */ \
+\
+    {0x63             , 0x63|MZ_SHIFT    , 0                , 0                , 0x63             , 0x63|MZ_SHIFT    , 0x63             }, /* 0x20:3/# */ \
+    {0x73             , 0x73|MZ_SHIFT    , 0                , 0                , 0x73             , 0x73|MZ_SHIFT    , 0x73             }, /* 0x21:4/$ */ \
+    {0x64             , 0x64|MZ_SHIFT    , 0                , 0                , 0x64             , 0x64|MZ_SHIFT    , 0x64             }, /* 0x22:5/% */ \
+    {0x74             , 0x74|MZ_SHIFT    , 0                , 0                , 0x74             , 0x74|MZ_SHIFT    , 0x74             }, /* 0x23:6/& */ \
+    {0x65             , 0x65|MZ_SHIFT    , 0                , 0                , 0x65             , 0x65|MZ_SHIFT    , 0x65             }, /* 0x24:7/' */ \
+    {0x75             , 0x75|MZ_SHIFT    , 0                , 0                , 0x75             , 0x75|MZ_SHIFT    , 0x75             }, /* 0x25:8/( */ \
+    {0x66             , 0x66|MZ_SHIFT    , 0                , 0                , 0x66             , 0x66|MZ_SHIFT    , 0x66             }, /* 0x26:9/) */ \
+    {0x76             , 0x76|MZ_SHIFT    , 0                , 0                , 0x76             , 0x76|MZ_SHIFT    , 0x76             }, /* 0x27:0 */ \
+    {0x38             , 0x38|MZ_SHIFT    , 0                , 0                , 0x38             , 0x38|MZ_SHIFT    , 0x38             }, /* 0x28:[RETURN] */ \
+    {0x05|MZ_SHIFT    , 0x05|MZ_SHIFT    , 0                , 0                , 0x05|MZ_SHIFT    , 0x05|MZ_SHIFT    , 0                }, /* 0x29:[ESC] = SHIFT+SPACE In Hu-BASIC */ \
+    {0x22             , 0x22|MZ_SHIFT    , 0                , 0                , 0x22             , 0x22|MZ_SHIFT    , 0x22             }, /* 0x2a:[BS] = [INST/DEL] key */ \
+    {0x78             , 0x78|MZ_SHIFT    , 0                , 0                , 0x78             , 0x78|MZ_SHIFT    , 0x78             }, /* 0x2b:[TAB] = Assign as [HOME/CLR] */ \
+    {0x05             , 0x05|MZ_SHIFT    , 0                , 0                , 0x05             , 0x05|MZ_SHIFT    , 0x05             }, /* 0x2c:[SPACE] */ \
+    {0x67             , 0x67|MZ_SHIFT    , 0                , 0                , 0x67             , 0x67|MZ_SHIFT    , 0x67             }, /* 0x2d:-/= */ \
+    {0x77             , 0x77|MZ_SHIFT    , 0                , 0                , 0x77             , 0x77|MZ_SHIFT    , 0x77             }, /* 0x2e:^/~ */ \
+    {0x47             , 0x47|MZ_SHIFT    , 0                , 0                , 0x47             , 0x47|MZ_SHIFT    , 0x47             }, /* 0x2f:@/` = @ */ \
+\
+    {0x57             , 0x57|MZ_SHIFT    , 0                , 0                , 0x57             , 0x57|MZ_SHIFT    , 0x57             }, /* 0x30:[/{ */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x31:NA */ \
+    {0x28             , 0x28|MZ_SHIFT    , 0                , 0                , 0x28             , 0x28|MZ_SHIFT    , 0x28             }, /* 0x32:]/}  */ \
+    {0x27             , 0x27|MZ_SHIFT    , 0                , 0                , 0x27             , 0x27|MZ_SHIFT    , 0x27             }, /* 0x33:;/+ */ \
+    {0x37             , 0x37|MZ_SHIFT    , 0                , 0                , 0x37             , 0x37|MZ_SHIFT    , 0x37             }, /* 0x34:':'/'*' */ \
+    {0x71             , 0x71|MZ_SHIFT    , 0                , 0                , 0x71             , 0x71|MZ_SHIFT    , 0x71             }, /* 0x35 ZEN/HAN = [BREAK] key */ \
+    {0x16             , 0x16|MZ_SHIFT    , 0                , 0                , 0x16             , 0x16|MZ_SHIFT    , 0x16             }, /* 0x36:,/< */ \
+    {0x07             , 0x07|MZ_SHIFT    , 0                , 0                , 0x07             , 0x07|MZ_SHIFT    , 0x07             }, /* 0x37:./> */ \
+    {0x17             , 0x08             , 0                , 0                , 0x17             , 0x08             , 0x17             }, /* 0x38:'/'/'?' */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x12             }, /* 0x39: [CAPS] = assaign as [ALPHA] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3a:[F1] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3b:[F2] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3c:[F3] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3d:[F4] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3e:[F5] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3f:[F6] */ \
+\
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x40:[F7] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x41:[F8] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x42:[F9] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x43:[F10] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x44 [F11] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x45:[F12] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x46 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x47 */ \
+    {0x71             , 0x71|MZ_SHIFT    , 0                , 0                , 0x71             , 0x71|MZ_SHIFT    , 0x71             }, /* 0x48 Pause/Break */ \
+    {0x22|MZ_SHIFT    , 0x22             , 0                , 0                , 0x22|MZ_SHIFT    , 0x22             , 0                }, /* 0x49 Insert = SHIFT + [DEL/INST] */ \
+    {0x78             , 0x78|MZ_SHIFT    , 0                , 0                , 0x78             , 0x78|MZ_SHIFT    , 0x78             }, /* 0x4a Home = [HOME/CLR] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x11             }, /* 0x4b PgUp = [GRPH] */ \
+    {0x22             , 0x19|MZ_SHIFT    , 0                , 0                , 0x22             , 0x19|MZ_SHIFT    , 0x22             }, /* 0x4c Delete = [DEL/INST] key */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x4d End */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x4e PgDn = [] */ \
+    {0x58             , 0x58|MZ_SHIFT    , 0                , 0                , 0x58             , 0x58|MZ_SHIFT    , 0x58             }, /* 0x4f right arrow */ \
+\
+    {0x58|MZ_SHIFT    , 0x58             , 0                , 0                , 0x58|MZ_SHIFT    , 0x58             , 0                }, /* 0x50 left arrow */ \
+    {0x48|MZ_SHIFT    , 0x48             , 0                , 0                , 0x48|MZ_SHIFT    , 0x48             , 0                }, /* 0x51 down arrow */ \
+    {0x48             , 0x48|MZ_SHIFT    , 0                , 0                , 0x48             , 0x48|MZ_SHIFT    , 0x48             }, /* 0x52 up arrow */ \
+    {0x19             , 0x19|MZ_SHIFT    , 0                , 0                , 0x19             , 0x19|MZ_SHIFT    , 0x19             }, /* 0x53 NumLock = [00] key */ \
+    {0x17             , 0x17|MZ_SHIFT    , 0x17             , 0x17|MZ_SHIFT    , 0x17             , 0x17|MZ_SHIFT    , 0x17             }, /* 0x54:/ */ \
+    {0x37|MZ_SHIFT    , 0x37|MZ_SHIFT    , 0                , 0                , 0x37|MZ_SHIFT    , 0x37|MZ_SHIFT    , 0                }, /* 0x55:* */ \
+    {0x5a             , 0x5a|MZ_SHIFT    , 0                , 0                , 0x5a             , 0x5a|MZ_SHIFT    , 0x5a             }, /* 0x56:- */ \
+    {0x7a             , 0x7a|MZ_SHIFT    , 0                , 0                , 0x7a             , 0x7a|MZ_SHIFT    , 0x7a             }, /* 0x57:+ */ \
+    {0x38             , 0x38|MZ_SHIFT    , 0                , 0                , 0x38             , 0x38|MZ_SHIFT    , 0x38             }, /* 0x58:[RETURN] */ \
+    {0x29             , 0x29|MZ_SHIFT    , 0                , 0                , 0x29             , 0x29|MZ_SHIFT    , 0x29             }, /* 0x59:1 */ \
+    {0x39             , 0x39|MZ_SHIFT    , 0                , 0                , 0x39             , 0x39|MZ_SHIFT    , 0x39             }, /* 0x5a:2 */ \
+    {0x2a             , 0x2a|MZ_SHIFT    , 0                , 0                , 0x2a             , 0x2a|MZ_SHIFT    , 0x2a             }, /* 0x5b:3 */ \
+    {0x49             , 0x49|MZ_SHIFT    , 0                , 0                , 0x49             , 0x49|MZ_SHIFT    , 0x49             }, /* 0x5c:4 */ \
+    {0x59             , 0x59|MZ_SHIFT    , 0                , 0                , 0x59             , 0x59|MZ_SHIFT    , 0x59             }, /* 0x5d:5 */ \
+    {0x4a             , 0x4a|MZ_SHIFT    , 0                , 0                , 0x4a             , 0x4a|MZ_SHIFT    , 0x4a             }, /* 0x5e:6 */ \
+    {0x69             , 0x69|MZ_SHIFT    , 0                , 0                , 0x69             , 0x69|MZ_SHIFT    , 0x69             }, /* 0x5f:7 */ \
+\
+    {0x79             , 0x79|MZ_SHIFT    , 0                , 0                , 0x79             , 0x79|MZ_SHIFT    , 0x79             }, /* 0x60:8 */ \
+    {0x6a             , 0x6a|MZ_SHIFT    , 0                , 0                , 0x6a             , 0x6a|MZ_SHIFT    , 0x6a             }, /* 0x61:9 */ \
+    {0x09             , 0x09|MZ_SHIFT    , 0                , 0                , 0x09             , 0x09|MZ_SHIFT    , 0x09             }, /* 0x62:0 */ \
+    {0x0a             , 0x0a|MZ_SHIFT    , 0                , 0                , 0x0a             , 0x0a|MZ_SHIFT    , 0x0a             }, /* 0x63:. */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x64 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x65:[Application] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x66 */ \
+    {0x67|MZ_SHIFT    , 0x53|MZ_SHIFT    , 0                , 0                , 0x67|MZ_SHIFT    , 0x53|MZ_SHIFT    , 0                }, /* 0x67:= */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x68 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x69 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x70 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x71 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x72 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x73 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x74 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x75 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x76 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x77 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x78 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x79 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x80 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x81 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x82 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x83 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x84 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x85 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x86 */ \
+    {0x08             , 0x08|MZ_SHIFT    , 0                , 0                , 0x08             , 0x08|MZ_SHIFT    , 0x08             }, /* 0x87:[Backslash]/_ key, ?↑ */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x88:[Hiragana/Katakana] = [カナ/英数]=カナ */ \
+    {0x68             , 0x68|MZ_SHIFT    , 0                , 0                , 0x68             , 0x68|MZ_SHIFT    , 0x68             }, /* 0x89:[Yen]/[|] key */ \
+};
+
+/* MZ-700E USB KB scan code to MZ switch matrix code
+     w/o SHIFT        , w/ SHIFT         , kana             , kana+shift       , GRPH             , GRPH+shift       , RAW */
+static keycode2SYX_t keycode2MZ700ESYX =  {
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x00   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x01   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x02   */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x03   */ \
+    {0x75             , 0x75|MZ_SHIFT    , 0                , 0                , 0x75             , 0x75|MZ_SHIFT    , 0x75             }, /* 0x04:a */ \
+    {0x65             , 0x65|MZ_SHIFT    , 0                , 0                , 0x65             , 0x65|MZ_SHIFT    , 0x65             }, /* 0x05:b */ \
+    {0x55             , 0x55|MZ_SHIFT    , 0                , 0                , 0x55             , 0x55|MZ_SHIFT    , 0x55             }, /* 0x06:c */ \
+    {0x45             , 0x45|MZ_SHIFT    , 0                , 0                , 0x45             , 0x45|MZ_SHIFT    , 0x45             }, /* 0x07:d */ \
+    {0x35             , 0x35|MZ_SHIFT    , 0                , 0                , 0x35             , 0x35|MZ_SHIFT    , 0x35             }, /* 0x08:e */ \
+    {0x25             , 0x25|MZ_SHIFT    , 0                , 0                , 0x25             , 0x25|MZ_SHIFT    , 0x25             }, /* 0x09:f */ \
+    {0x15             , 0x15|MZ_SHIFT    , 0                , 0                , 0x15             , 0x15|MZ_SHIFT    , 0x15             }, /* 0x0a:g */ \
+    {0x05             , 0x05|MZ_SHIFT    , 0                , 0                , 0x05             , 0x05|MZ_SHIFT    , 0x05             }, /* 0x0b:h */ \
+    {0x74             , 0x74|MZ_SHIFT    , 0                , 0                , 0x74             , 0x74|MZ_SHIFT    , 0x74             }, /* 0x0c:i */ \
+    {0x64             , 0x64|MZ_SHIFT    , 0                , 0                , 0x64             , 0x64|MZ_SHIFT    , 0x64             }, /* 0x0d:j */ \
+    {0x54             , 0x54|MZ_SHIFT    , 0                , 0                , 0x54             , 0x54|MZ_SHIFT    , 0x54             }, /* 0x0e:k */ \
+    {0x44             , 0x44|MZ_SHIFT    , 0                , 0                , 0x44             , 0x44|MZ_SHIFT    , 0x44             }, /* 0x0f:l */ \
+\
+    {0x34             , 0x34|MZ_SHIFT    , 0                , 0                , 0x34             , 0x34|MZ_SHIFT    , 0x34             }, /* 0x10:m */ \
+    {0x24             , 0x24|MZ_SHIFT    , 0                , 0                , 0x24             , 0x24|MZ_SHIFT    , 0x24             }, /* 0x11:n */ \
+    {0x14             , 0x14|MZ_SHIFT    , 0                , 0                , 0x14             , 0x14|MZ_SHIFT    , 0x14             }, /* 0x12:o */ \
+    {0x04             , 0x04|MZ_SHIFT    , 0                , 0                , 0x04             , 0x04|MZ_SHIFT    , 0x04             }, /* 0x13:p */ \
+    {0x73             , 0x73|MZ_SHIFT    , 0                , 0                , 0x73             , 0x73|MZ_SHIFT    , 0x73             }, /* 0x14:q */ \
+    {0x63             , 0x63|MZ_SHIFT    , 0                , 0                , 0x63             , 0x63|MZ_SHIFT    , 0x63             }, /* 0x15:r */ \
+    {0x53             , 0x53|MZ_SHIFT    , 0                , 0                , 0x53             , 0x53|MZ_SHIFT    , 0x53             }, /* 0x16:s */ \
+    {0x43             , 0x43|MZ_SHIFT    , 0                , 0                , 0x43             , 0x43|MZ_SHIFT    , 0x43             }, /* 0x17:t */ \
+    {0x33             , 0x33|MZ_SHIFT    , 0                , 0                , 0x33             , 0x33|MZ_SHIFT    , 0x33             }, /* 0x18:u */ \
+    {0x23             , 0x23|MZ_SHIFT    , 0                , 0                , 0x23             , 0x23|MZ_SHIFT    , 0x23             }, /* 0x19:v */ \
+    {0x13             , 0x13|MZ_SHIFT    , 0                , 0                , 0x13             , 0x13|MZ_SHIFT    , 0x13             }, /* 0x1a:w */ \
+    {0x03             , 0x03|MZ_SHIFT    , 0                , 0                , 0x03             , 0x03|MZ_SHIFT    , 0x03             }, /* 0x1b:x */ \
+    {0x72             , 0x72|MZ_SHIFT    , 0                , 0                , 0x72             , 0x72|MZ_SHIFT    , 0x72             }, /* 0x1c:y */ \
+    {0x62             , 0x62|MZ_SHIFT    , 0                , 0                , 0x62             , 0x62|MZ_SHIFT    , 0x62             }, /* 0x1d:z */ \
+    {0x76             , 0x76|MZ_SHIFT    , 0                , 0                , 0x76             , 0x76|MZ_SHIFT    , 0x76             }, /* 0x1e:1/! */ \
+    {0x66             , 0x66|MZ_SHIFT    , 0                , 0                , 0x66             , 0x66|MZ_SHIFT    , 0x66             }, /* 0x1f:2/" */ \
+\
+    {0x56             , 0x56|MZ_SHIFT    , 0                , 0                , 0x56             , 0x56|MZ_SHIFT    , 0x56             }, /* 0x20:3/# */ \
+    {0x46             , 0x46|MZ_SHIFT    , 0                , 0                , 0x46             , 0x46|MZ_SHIFT    , 0x46             }, /* 0x21:4/$ */ \
+    {0x36             , 0x36|MZ_SHIFT    , 0                , 0                , 0x36             , 0x36|MZ_SHIFT    , 0x36             }, /* 0x22:5/% */ \
+    {0x26             , 0x26|MZ_SHIFT    , 0                , 0                , 0x26             , 0x26|MZ_SHIFT    , 0x26             }, /* 0x23:6/& */ \
+    {0x16             , 0x16|MZ_SHIFT    , 0                , 0                , 0x16             , 0x16|MZ_SHIFT    , 0x16             }, /* 0x24:7/' */ \
+    {0x06             , 0x06|MZ_SHIFT    , 0                , 0                , 0x06             , 0x06|MZ_SHIFT    , 0x06             }, /* 0x25:8/( */ \
+    {0x27             , 0x27|MZ_SHIFT    , 0                , 0                , 0x27             , 0x27|MZ_SHIFT    , 0x27             }, /* 0x26:9/) */ \
+    {0x37             , 0x37|MZ_SHIFT    , 0                , 0                , 0x37             , 0x37|MZ_SHIFT    , 0x37             }, /* 0x27:0/[Paragraph]/わ */ \
+    {0x01             , 0x01|MZ_SHIFT    , 0                , 0                , 0x01             , 0x01|MZ_SHIFT    , 0x01             }, /* 0x28:[RETURN] */ \
+    {0x47|MZ_SHIFT    , 0x47|MZ_SHIFT    , 0                , 0                , 0x47|MZ_SHIFT    , 0x47|MZ_SHIFT    , 0                }, /* 0x29:[ESC] = SHIFT+SPACE In Hu-BASIC */ \
+    {0x68             , 0x68             , 0                , 0                , 0x68             , 0x68             , 0x68             }, /* 0x2a:[BS] = [DEL] key */ \
+    {0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0                , 0                , 0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0                }, /* 0x2b:Home = [SHIFT]+[DEL] / [SHIFT]+[INST] */ \
+    {0x47             , 0x47|MZ_SHIFT    , 0                , 0                , 0x47             , 0x47|MZ_SHIFT    , 0x47             }, /* 0x2c:[SPACE] */ \
+    {0x57             , 0x57|MZ_SHIFT    , 0                , 0                , 0x57             , 0x57|MZ_SHIFT    , 0x57             }, /* 0x2d:'-'/'=' */ \
+    {0x67             , 0x67|MZ_SHIFT    , 0                , 0                , 0x67             , 0x67|MZ_SHIFT    , 0x67             }, /* 0x2e:'^'/'~' */ \
+    {0x52             , 0x52|MZ_SHIFT    , 0                , 0                , 0x52             , 0x52|MZ_SHIFT    , 0x52             }, /* 0x2f:'@'/'`'/゛ */ \
+\
+    {0x42             , 0x42|MZ_SHIFT    , 0                , 0                , 0x42             , 0x42|MZ_SHIFT    , 0x42             }, /* 0x30:'['/'{' */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x31: */ \
+    {0x32             , 0x32|MZ_SHIFT    , 0                , 0                , 0x32             , 0x32|MZ_SHIFT    , 0x32             }, /* 0x32:']'/'}'  */ \
+    {0x21             , 0x21|MZ_SHIFT    , 0                , 0                , 0x21             , 0x21|MZ_SHIFT    , 0x21             }, /* 0x33:';'/'+' */ \
+    {0x11             , 0x11|MZ_SHIFT    , 0                , 0                , 0x11             , 0x11|MZ_SHIFT    , 0x11             }, /* 0x34:':'/'*' */ \
+    {0x79             , 0x79|MZ_SHIFT    , 0                , 0                , 0x79             , 0x79|MZ_SHIFT    , 0x79             }, /* 0x35 ZEN/HAN = [BREAK] key */ \
+    {0x17             , 0x17|MZ_SHIFT    , 0                , 0                , 0x17             , 0x17|MZ_SHIFT    , 0x17             }, /* 0x36:','/'<' */ \
+    {0x07             , 0x07|MZ_SHIFT    , 0                , 0                , 0x07             , 0x07|MZ_SHIFT    , 0x07             }, /* 0x37:'.'/'>' */ \
+    {0x08             , 0x18             , 0                , 0                , 0x08             , 0x08|MZ_SHIFT    , 0x08             }, /* 0x38:'/'/'?' */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x41             }, /* 0x39: [CAPS] = assaign as [ALPHA] */ \
+    {0x7a             , 0x7a|MZ_SHIFT    , 0                , 0                , 0x7a             , 0x7a|MZ_SHIFT    , 0x7a             }, /* 0x3a:[F1] */ \
+    {0x6a             , 0x6a|MZ_SHIFT    , 0                , 0                , 0x6a             , 0x6a|MZ_SHIFT    , 0x6a             }, /* 0x3b:[F2] */ \
+    {0x5a             , 0x5a|MZ_SHIFT    , 0                , 0                , 0x5a             , 0x5a|MZ_SHIFT    , 0x5a             }, /* 0x3c:[F3] */ \
+    {0x4a             , 0x4a|MZ_SHIFT    , 0                , 0                , 0x4a             , 0x4a|MZ_SHIFT    , 0x4a             }, /* 0x3d:[F4] */ \
+    {0x3a             , 0x3a|MZ_SHIFT    , 0                , 0                , 0x3a             , 0x3a|MZ_SHIFT    , 0x3a             }, /* 0x3e:[F5] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x3f:[F6] */ \
+\
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x40:[F7] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x41:[F8] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x42:[F9] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x43:[F10] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x44 [F11] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x45:[F12] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x46 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x47 */ \
+    {0x79             , 0x79|MZ_SHIFT    , 0                , 0                , 0x79             , 0x79|MZ_SHIFT    , 0x79             }, /* 0x48 Pause/Break = [BREAK] */ \
+    {0x78             , 0x78             , 0                , 0                , 0x78             , 0x78             , 0x78             }, /* 0x49 Insert = [INST] */ \
+    {0x68|MZ_SHIFT    , 0x78|MZ_SHIFT    , 0                , 0                , 0x68             , 0x78             , 0                }, /* 0x4a Home = [SHIFT]+[DEL] / [SHIFT]+[INST] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0x61             }, /* 0x4b PgUp = [GRPH] */ \
+    {0x68             , 0x68             , 0                , 0                , 0x68             , 0x68             , 0x68             }, /* 0x4c Delete = [DEL] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x4d End */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x4e PgDn = [] */ \
+    {0x38             , 0x38|MZ_SHIFT    , 0                , 0                , 0x38             , 0x38|MZ_SHIFT    , 0x38             }, /* 0x4f right arrow */ \
+\
+    {0x28             , 0x28|MZ_SHIFT    , 0                , 0                , 0x28             , 0x28|MZ_SHIFT    , 0x28             }, /* 0x50 left arrow */ \
+    {0x48             , 0x48|MZ_SHIFT    , 0                , 0                , 0x48             , 0x48|MZ_SHIFT    , 0x48             }, /* 0x51 down arrow */ \
+    {0x58             , 0x58|MZ_SHIFT    , 0                , 0                , 0x58             , 0x58|MZ_SHIFT    , 0x58             }, /* 0x52 up arrow */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x53 NumLock */ \
+    {0x08             , 0x08|MZ_SHIFT    , 0                , 0                , 0x08             , 0x08|MZ_SHIFT    , 0x08             }, /* 0x54:/ */ \
+    {0x11|MZ_SHIFT    , 0x11             , 0                , 0                , 0x11|MZ_SHIFT    , 0x11             , 0x11             }, /* 0x55:* */ \
+    {0x57             , 0x57|MZ_SHIFT    , 0                , 0                , 0x57             , 0x57|MZ_SHIFT    , 0x57             }, /* 0x56:- */ \
+    {0x21|MZ_SHIFT    , 0x21             , 0                , 0                , 0x21|MZ_SHIFT    , 0x21             , 0x21             }, /* 0x57:+ */ \
+    {0x01             , 0x01|MZ_SHIFT    , 0                , 0                , 0x01             , 0x01|MZ_SHIFT    , 0x01             }, /* 0x58:[RETURN] */ \
+    {0x76             , 0x76|MZ_SHIFT    , 0                , 0                , 0x76             , 0x76|MZ_SHIFT    , 0x76             }, /* 0x59:1 */ \
+    {0x66             , 0x66|MZ_SHIFT    , 0                , 0                , 0x66             , 0x66|MZ_SHIFT    , 0x66             }, /* 0x5a:2 */ \
+    {0x56             , 0x56|MZ_SHIFT    , 0                , 0                , 0x56             , 0x56|MZ_SHIFT    , 0x56             }, /* 0x5b:3 */ \
+    {0x46             , 0x46|MZ_SHIFT    , 0                , 0                , 0x46             , 0x46|MZ_SHIFT    , 0x46             }, /* 0x5c:4 */ \
+    {0x36             , 0x36|MZ_SHIFT    , 0                , 0                , 0x36             , 0x36|MZ_SHIFT    , 0x36             }, /* 0x5d:5 */ \
+    {0x26             , 0x26|MZ_SHIFT    , 0                , 0                , 0x26             , 0x26|MZ_SHIFT    , 0x26             }, /* 0x5e:6 */ \
+    {0x16             , 0x16|MZ_SHIFT    , 0                , 0                , 0x16             , 0x16|MZ_SHIFT    , 0x16             }, /* 0x5f:7 */ \
+\
+    {0x06             , 0x06|MZ_SHIFT    , 0                , 0                , 0x06             , 0x06|MZ_SHIFT    , 0x06             }, /* 0x60:8 */ \
+    {0x27             , 0x27|MZ_SHIFT    , 0                , 0                , 0x27             , 0x27|MZ_SHIFT    , 0x27             }, /* 0x61:9 */ \
+    {0x37             , 0x37|MZ_SHIFT    , 0                , 0                , 0x37             , 0x37|MZ_SHIFT    , 0x37             }, /* 0x62:0 */ \
+    {0x07             , 0x07|MZ_SHIFT    , 0                , 0                , 0x07             , 0x07|MZ_SHIFT    , 0x07             }, /* 0x63:. */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x64 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x65:[Application] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x66 */ \
+    {0x51             , 0x51|MZ_SHIFT    , 0                , 0                , 0x51             , 0x51|MZ_SHIFT    , 0x51             }, /* 0x67:= */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x68 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x69 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x6f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x70 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x71 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x72 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x73 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x74 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x75 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x76 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x77 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x78 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x79 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7a */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7b */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7c */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7d */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7e */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x7f */ \
+ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x80 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x81 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x82 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x83 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x84 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x85 */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x86 */ \
+    {0x18             , 0x18|MZ_SHIFT    , 0                , 0                , 0x18             , 0x18|MZ_SHIFT    , 0x18             }, /* 0x87:[Backslash]/_ key = [?][→] */ \
+    {0                , 0                , 0                , 0                , 0                , 0                , 0                }, /* 0x88:[Hiragana/Katakana] = [カナ] */ \
+    {0x77             , 0x77|MZ_SHIFT    , 0                , 0                , 0x77             , 0x77|MZ_SHIFT    , 0x77             }, /* 0x89:[Yen]/[|] */ \
+};
+
+// SYSTEM MODE vs. KB MATRIX table
+static keycode2SYX_t *keycode2SYX[16]  = {
+  &keycode2MZ1200SYX,	// 0
+  &keycode2MZ1200SYX,	// 1
+  &keycode2MZ1200SYX,	// 2
+  &keycode2MZ1200SYX,	// 3
+  &keycode2MZ700JSYX,	// 4
+  &keycode2MZ700JSYX,	// 5
+  &keycode2MZ700JSYX,	// 6
+  &keycode2MZ700JSYX,	// 7
+  &keycode2MZ80ASYX,	// 8
+  &keycode2MZ1200SYX,	// 9
+  &keycode2MZ80ASYX,	// 10
+  &keycode2MZ1200SYX,	// 11
+  &keycode2MZ700ESYX,	// 12
+  &keycode2MZ700JSYX,	// 13
+  &keycode2MZ700ESYX,	// 14
+  &keycode2MZ700JSYX,	// 15
+};
+#define KEYCODE2SYX	(*keycode2SYX[system_mode])
+
+// MZ-80A で [GRPH] モードとするのに [ALPHA]+[GRPH] が必要かどうか
+static bool need_alpha_grph[16]  = {
+  false,	// 0: MZ1200
+  false,	// 1: MZ1200
+  false,	// 2: MZ1200
+  false,	// 3: MZ1200
+  false,	// 4: MZ700J
+  false,	// 5: MZ700J
+  false,	// 6: MZ700J
+  false,	// 7: MZ700J
+  true,		// 8: MZ80A : 要
+  false,	// 9: MZ1200
+  true,		// 10: MZ80A : 要
+  false,	// 11: MZ1200
+  false,	// 12: MZ700E
+  false,	// 13: MZ700J
+  false,	// 14: MZ700E
+  false,	// 15: MZ700J
+};
+#define NEED_ALPHA_GRPH	(need_alpha_grph[system_mode])
+
+
+
+// [Fn] default string
+#define MZ_START_FKEY	F6_KEY_CODE
+#define MZ_END_FKEY	F12_KEY_CODE
+#define MZ_NUM_FKEYS	(MZ_END_FKEY - MZ_START_FKEY + 1)
+#define MZ_FKEY_MAXLEN	((FLASH_PAGE_SIZE - 8) / 2)
+
+// ASCII to HID keycode + modifier code table (fill later)
+static uint8_t ascii2keycode[256]= {0};
+static uint8_t ascii2modifier[256]= {0};
+
+// alpha, kana,grph,raw mode
+typedef enum {
+  MZ_KBMODE_ALPHA = 0,
+  MZ_KBMODE_KANA = 2,
+  MZ_KBMODE_GRPH = 4,
+  MZ_KBMODE_RAW  = 6,
+} mz_kb_mode_t;
+static mz_kb_mode_t	mz_kb_mode = MZ_KBMODE_ALPHA;
+
+// モード文字列を返す
+static const char *mz_input_modestring(mz_kb_mode_t mode)
+{
+  if (mode == MZ_KBMODE_ALPHA) return "ALPHA";
+  if (mode == MZ_KBMODE_KANA) return "KANA";
+  if (mode == MZ_KBMODE_GRPH) return "GRPH";
+  if (mode == MZ_KBMODE_RAW) return "RAW";
+  return "UNKNOWN";
+}
+
+
+// MZ's last SHIFT Key state
+static bool mz_last_shift_state = false;
+static bool mz_last_lshift_state = false;
+static bool mz_last_rshift_state = false;
+static bool mz_last_ctrl_state = false;
+
+// Function key definition mode
+static bool    fkey_def_mode = false;
+static uint16_t fkey_def_keynum  = 0;
+
+// Function key buffer
+typedef struct {
+  size_t 	length;			// 4: Number of keycodes in this entry
+  mz_kb_mode_t	initial_mz_kb_mode;	// 4: initial mz_kb_mode value of the fkey assume
+  uint8_t modifier[MZ_FKEY_MAXLEN];	//  : HID modifier
+  uint8_t keycode[MZ_FKEY_MAXLEN];	//  : HID keycode
+} mz_func_key_store_t;			// フラッシュに保存するので256バイトに収まるように
+static mz_func_key_store_t mz_func_key_store[MZ_NUM_FKEYS] = {0};
+// ↑のサイズチェック↓。サイズがページサイズになっていないと配列のサイズがマイナスになってコンパイルエラーになる
+typedef char compile_time_assert[(sizeof(mz_func_key_store_t) == FLASH_PAGE_SIZE) ? 1 : -1] __attribute__((unused));
+
+// the string length must be less than MZ_FKEY_MAXLEN
+static char const *mz_func_key_string_default[MZ_NUM_FKEYS] = {
+  "fdl ",							// 6: 
+  "*fdl ",							// 7: in DOS FILE: prompt
+  "load\"*l",							// 8: in BASIC
+  "",								// 9: 
+  "poke $3d25,1\r",						// 10: SP-5030 auto repeat OFF
+  "poke $3d25,0\r",						// 11: SP-5030 auto repeat ON
+  "test:hhahhbhhchhdhhehhfhhghhhhhihhj\r",			// 12: 
+};
+
+
+
+
+// Wait time for debounce
+#define MZ_KBIF_POWERON_WAIT_MS			500		// 
+#define MZ_KBIF_RESET_MS			500
+#define MZ_KBIF_STROBE_MS			1
+#define MZ_KBIF_DEBOUNCE_MS			60		// MZ-1200 : 40mS ?
+#define MZ_KBIF_RELEASE_DEBOUNCE_MS		150		// MZ-1200 : 130mS ?
+#define MZ_KBIF_WAIT_BETWEEN_THE_SAME_KEY_MS	5
+#define MZ_KBIF_CTRL_ALT_DEL_MS			500		// Duration from press MZ RESET SW to release the SW
+#define MZ_KBIF_CTRL_ALT_END_MS			100		// Duration from release ALL keys to press CTRL
+#define MZ_KBIF_CTRL_ALT_END_MS2		100		// Duration from press MZ RESET SW to release RESET
+#define MZ_KBIF_CTRL_ALT_END_MS3		500		// Duration from release MZ RESET SW to release CTRL
+#define MZ_KBIF_VBUS_CYCLE_MS			1000		// Duration of VBUS CYCLE
+
+// Pin assignments
+#define MZ_PIO_MOTOR_PIN			0
+#define MZ_PIO_Z80_CLOCK_SW			1
+#define MZ_PIO_ROM_A15_PIN			2
+#define MZ_PIO_ROM_A14_PIN			3
+#define MZ_PIO_ROM_A13_PIN			4
+#define MZ_PIO_ROM_A12_PIN			5
+#define MZ_PIO_ARRAY_RESET_PIN			6
+#define MZ_PIO_ARRAY_DATA_PIN			7
+#define MZ_PIO_ARRAY_STROBE_PIN			8
+#define MZ_PIO_AX0_PIN				9
+#define MZ_PIO_AX1_PIN				10
+#define MZ_PIO_AX2_PIN				11
+#define MZ_PIO_AX3_PIN				12
+#define MZ_PIO_AY0_PIN				13
+#define MZ_PIO_AY1_PIN				14
+#define MZ_PIO_AY2_PIN				15
+#define MZ_KEYSCAN_DETECTION_PIN		16		// key-scan detection with IRQ
+#define MZ_PIO_MZ_RESET_PIN			19
+
+// Key scan detection
+#define L_KEYSCANS_RELEASE_DEBOUNCE_DEF			2		// Smallest stable value @ SP-1002 2MHz
+#define M_KEYSCANS_RELEASE_DEBOUNCE_DEF			34		// Smallest stable value @ SP-1002 2MHz
+#define	H_KEYSCANS_RELEASE_DEBOUNCE_DEF			76		// Smallest stable value @ SP-5030 Auto repeat
+#define N_KEYSCANS_PRESS_DEBOUNCE_DEF			2		// Smallest stable value @ MZ-700
+#define MZ700E_N_KEYSCANS_RELEASE_DEBOUNCE_DEF		2		// Smallest stable value @ MZ-700
+
+const uint32_t n_keyscans_release_debounce_default[16] = {
+  H_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 0  MZ1200 SP-1002
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 1  MZ1200
+  H_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 2  MZ1200 SP-1002
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 3  MZ1200
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 4  MZ700J
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 5  MZ700J
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 6  MZ700J
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 7  MZ700J
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 8  MZ80A
+  H_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 9  MZ1200 SP-1002
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 10 MZ80A
+  H_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 11 MZ1200 SP-1002
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 12 MZ700E
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 13 MZ700J
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 14 MZ700E
+  M_KEYSCANS_RELEASE_DEBOUNCE_DEF,	// 15 MZ700J
+};
+
+static uint32_t n_keyscans_press_debounce   = N_KEYSCANS_PRESS_DEBOUNCE_DEF;
+static uint32_t n_keyscans_release_debounce = H_KEYSCANS_RELEASE_DEBOUNCE_DEF;
+
+// init debounce count
+void init_debounce_count(void)
+{
+  n_keyscans_press_debounce = N_KEYSCANS_PRESS_DEBOUNCE_DEF;
+  n_keyscans_release_debounce = n_keyscans_release_debounce_default[system_mode];
+}
+
+
+// keyscan detection callback
+uint32_t num_keyscan_called = 0;
+
+void keyscan_detection_callback(uint gpio, uint32_t event_mask)
+{
+  if (gpio == MZ_KEYSCAN_DETECTION_PIN && event_mask == GPIO_IRQ_EDGE_FALL) {
+    num_keyscan_called++;
+  }
+}
+
+// fill ascii2*[] table
+static void mz_fill_ascii2hid(void)
+{
+  for (uint16_t c = 1; c < 256; c++)
+  {
+    for (uint16_t k = 4; k < 256; k++)
+    {
+      for (uint16_t s = 0; s < 2; s++)
+      {
+        if (keycode2ascii[k][s] == (uint8_t)c)
+        {
+          ascii2keycode[c]  = (uint8_t)k;
+          ascii2modifier[c] = s ? KEYBOARD_MODIFIER_LEFTSHIFT : 0;
+          k = 256;	// found
+          break;
+        }
+      }
+    }
+  }
+  // CTRL
+  for (uint16_t c = 1; c < 32; c++)
+  {
+    for (uint16_t k = 4; k < 256; k++)
+    {
+      uint8_t cc = (uint8_t)(c + 0x40u);
+      if (cc >= 0x41 && cc <= 0x5a) cc += 0x20u;
+      if (keycode2ascii[k][0] == cc)
+      {
+        if (ascii2keycode[c] == 0)
+        {
+          ascii2keycode[c]  = (uint8_t)k;
+          ascii2modifier[c] = KEYBOARD_MODIFIER_LEFTCTRL;
+        }
+        k = 256;	// found
+        break;
+      }
+    }
+  }
+  // CTRL-C
+  ascii2keycode[3]  = C_KEY_CODE;
+  ascii2modifier[3] = KEYBOARD_MODIFIER_LEFTCTRL;
+}
+
+// Store function key buffer default
+// must be after mz_fill_ascii2hid()
+static void mz_func_key_init(void)
+{
+  for (int i = 0; i < MZ_NUM_FKEYS; i++)
+  {
+    const char *s = mz_func_key_string_default[i];
+    size_t l = strlen(s);
+    mz_func_key_store[i].length = l;
+    mz_func_key_store[i].initial_mz_kb_mode  = MZ_KBMODE_ALPHA;
+
+    for (size_t n = 0; n < l; n++)
+    {
+      mz_func_key_store[i].keycode[n]  = ascii2keycode[(uint8_t)s[n]];
+      mz_func_key_store[i].modifier[n] = ascii2modifier[(uint8_t)s[n]];
+    }
+  }
+
+  fkey_def_mode = false;
+}
+
+
+// MZ key sending task
+static enum  {
+  MZ_TASK_STATE_POWERON = 0,
+  MZ_TASK_STATE_POWERON_WAIT,
+  MZ_TASK_STATE_RESET,
+  MZ_TASK_STATE_RESET_ASSERTED,
+  MZ_TASK_STATE_ARRAY_RESET_ASSERTED,
+  MZ_TASK_STATE_GETKEY,
+  MZ_TASK_STATE_KEY_STROBE_ASSERTED,
+  MZ_TASK_STATE_KEY_STROBE_DEASSERTED,
+  MZ_TASK_STATE_KEY_WAIT_DEBOUNCE,
+  MZ_TASK_STATE_KEY_WAIT_RELEASE_DEBOUNCE,
+  MZ_TASK_STATE_CTRL_ALT_DEL,
+  MZ_TASK_STATE_CTRL_ALT_DEL_ASSERTED,
+  MZ_TASK_STATE_CTRL_ALT_END,
+  MZ_TASK_STATE_CTRL_ALT_END_ASSERTED,
+  MZ_TASK_STATE_CTRL_ALT_END_ASSERTED2,
+  MZ_TASK_STATE_CTRL_ALT_END_ASSERTED3,
+  MZ_TASK_STATE_CTRL_ALT_END_ASSERTED4,
+  MZ_TASK_STATE_WAITING_BETWEEN_THE_SAME_KEY,
+  MZ_TASK_STATE_CYCLE_VBUS,
+  MZ_TASK_STATE_CYCLE_VBUS_WAITING,
+} mz_key_sending_task_state = MZ_TASK_STATE_POWERON;
+static uint32_t mz_task_start_ms = 0;
+void mz_sendkey_task(void);
+
+// Key queue for MZ
+#define MZ_KEY_QUEUE_LEN	((uint16_t)256)
+static uint16_t mz_key_queue[MZ_KEY_QUEUE_LEN] =  { 0 };
+static uint16_t mz_key_queue_read = 0;
+static uint16_t mz_key_queue_write = 0;
+
+// return number of data in queue
+uint16_t mz_key_queue_num_data(void)
+{
+  return (uint16_t)((mz_key_queue_write + MZ_KEY_QUEUE_LEN - mz_key_queue_read) % MZ_KEY_QUEUE_LEN);
+}
+
+// put key into queue
+void mz_key_queue_put(uint16_t syx)
+{
+  if ((uint16_t)((mz_key_queue_write + 1) % MZ_KEY_QUEUE_LEN) != mz_key_queue_write)
+  {
+    mz_key_queue[mz_key_queue_write] = syx;
+    mz_key_queue_write = (uint16_t)((mz_key_queue_write + 1) % MZ_KEY_QUEUE_LEN);
+  }
+  else
+  {
+    // TODO when queue is full
+    mz_key_sending_task_state = MZ_TASK_STATE_RESET;
+  }
+}
+
+// peek queue
+uint16_t mz_key_queue_peek(void)
+{
+  if (mz_key_queue_read == mz_key_queue_write) return 0;	// No key in queue
+  return mz_key_queue[mz_key_queue_read];			// Peek queue
+}
+
+// drop queue
+void mz_key_queue_drop(void)
+{
+  if (mz_key_queue_read == mz_key_queue_write) return;	// No key in queue
+  // advance queue read pointer
+  mz_key_queue_read = (uint16_t)((mz_key_queue_read + 1) % MZ_KEY_QUEUE_LEN);
+}
+
+// Host PC to MZ
+// Key queue for host
+#define MZ_HOST_QUEUE_LEN	((uint16_t)128)
+static char     mz_host_queue[MZ_HOST_QUEUE_LEN] =  { 0 };
+static uint16_t mz_host_queue_read = 0;
+static uint16_t mz_host_queue_write = 0;
+
+void mz_host2mz_task(void);
+
+// return number of data in queue
+uint16_t mz_host_queue_num_data(void)
+{
+  return (uint16_t)((mz_host_queue_write + MZ_HOST_QUEUE_LEN - mz_host_queue_read) % MZ_HOST_QUEUE_LEN);
+}
+
+// put key into queue
+void mz_host_queue_put(char c)
+{
+  if ((uint16_t)((mz_host_queue_write + 1) % MZ_HOST_QUEUE_LEN) != mz_host_queue_write)
+  {
+    mz_host_queue[mz_host_queue_write] = c;
+    mz_host_queue_write = (uint16_t)((mz_host_queue_write + 1) % MZ_HOST_QUEUE_LEN);
+  }
+  else
+  {
+    // TODO when queue is full
+    mz_key_sending_task_state = MZ_TASK_STATE_RESET;
+  }
+}
+
+// peek queue
+char mz_host_queue_peek(void)
+{
+  if (mz_host_queue_read == mz_host_queue_write) return 0;	// No key in queue
+  return mz_host_queue[mz_host_queue_read];			// Peek queue
+}
+
+// drop queue
+void mz_host_queue_drop(void)
+{
+  if (mz_host_queue_read == mz_host_queue_write) return;	// No key in queue
+  // advance queue read pointer
+  mz_host_queue_read = (uint16_t)((mz_host_queue_read + 1) % MZ_HOST_QUEUE_LEN);
+}
+
+// init queue
+void mz_host_queue_init(void)
+{
+  mz_key_queue_read = 0;
+  mz_key_queue_write = 0;
+  mz_host_queue_read = 0;
+  mz_host_queue_write = 0;
+}
+
+// init mode
+void mz_mode_init(void)
+{
+  mz_kb_mode = MZ_KBMODE_ALPHA;
+  mz_last_shift_state = false;
+  mz_last_lshift_state = false;
+  mz_last_rshift_state = false;
+  mz_last_ctrl_state = false;
+}
+
+
+// init LED
+void kb_led_init(void)
+{
+  leds = 0;
+  prev_leds = 0;
+  blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_NONE;
+  if (keybd_dev_addr != 0xFFu)
+  {
+    tuh_hid_set_report(keybd_dev_addr, keybd_instance, 0, HID_REPORT_TYPE_OUTPUT, &leds, sizeof(leds));
+  }
+}
+
+// set ROM A15-A12
+void mz_set_ROM_addr(void)
+{
+  gpio_put(MZ_PIO_ROM_A15_PIN, (system_mode & 0x8) ? 1 : 0);
+  gpio_put(MZ_PIO_ROM_A14_PIN, (system_mode & 0x4) ? 1 : 0);
+  gpio_put(MZ_PIO_ROM_A13_PIN, (system_mode & 0x2) ? 1 : 0);
+  gpio_put(MZ_PIO_ROM_A12_PIN, (system_mode & 0x1) ? 1 : 0);
+}
+
+// システムクロック切り替え
+// -------------------------------------------------------------------
+typedef enum {
+  Z80_CLOCK_MODE_AUTO = 0,
+  Z80_CLOCK_MODE_2MHZ,
+  Z80_CLOCK_MODE_4MHZ,
+} z80_clock_mode_t;
+static z80_clock_mode_t z80_clock_mode = Z80_CLOCK_MODE_DEFAULT;
+
+typedef enum {
+  Z80_CLOCK_2MHZ = 1,
+  Z80_CLOCK_4MHZ = 0,
+  Z80_CLOCK_UNKNOWN = 2,
+} z80_clock_t;
+
+static volatile z80_clock_t z80_clock = Z80_CLOCK_UNKNOWN;
+
+void set_z80_system_clock(z80_clock_t clk)
+{
+   if (z80_clock != clk)
+   {
+     z80_clock = clk;
+     gpio_put(MZ_PIO_Z80_CLOCK_SW, clk);
+#ifdef MZ_CLK_DEBUG
+     char tempbuf[256];
+     int count = sprintf(tempbuf, "MZ: Z80 CLOCK set to %s\r\n", (clk == Z80_CLOCK_2MHZ) ? "2MHz" : "4MHz");
+     tud_cdc_write(tempbuf, (uint32_t) count);
+     tud_cdc_write_flush();
+#endif
+   }
+}
+
+void z80_system_clock_task(void)
+{
+  z80_clock_t	clk;
+
+  switch(z80_clock_mode)
+  {
+    case Z80_CLOCK_MODE_2MHZ:
+      clk = Z80_CLOCK_2MHZ;
+      break;
+
+    case Z80_CLOCK_MODE_4MHZ:
+      clk = Z80_CLOCK_4MHZ;
+      break;
+
+    case Z80_CLOCK_MODE_AUTO:
+    default:
+      clk = (gpio_get(MZ_PIO_MOTOR_PIN) ? Z80_CLOCK_4MHZ : Z80_CLOCK_2MHZ);
+      break;
+  }
+  set_z80_system_clock(clk);
+}
+
+
+// GPIO Initialize
+// -------------------------------------------------------------------
+static void mz_switch_init(void)
+{
+  gpio_init(MZ_PIO_MOTOR_PIN);
+  gpio_init(MZ_PIO_Z80_CLOCK_SW);
+  gpio_init(MZ_PIO_ROM_A15_PIN);
+  gpio_init(MZ_PIO_ROM_A14_PIN);
+  gpio_init(MZ_PIO_ROM_A13_PIN);
+  gpio_init(MZ_PIO_ROM_A12_PIN);
+  gpio_init(MZ_PIO_ARRAY_RESET_PIN);
+  gpio_init(MZ_PIO_ARRAY_DATA_PIN);
+  gpio_init(MZ_PIO_ARRAY_STROBE_PIN);
+  gpio_init(MZ_PIO_AX0_PIN);
+  gpio_init(MZ_PIO_AX1_PIN);
+  gpio_init(MZ_PIO_AX2_PIN);
+  gpio_init(MZ_PIO_AX3_PIN);
+  gpio_init(MZ_PIO_AY0_PIN);
+  gpio_init(MZ_PIO_AY1_PIN);
+  gpio_init(MZ_PIO_AY2_PIN);
+  gpio_init(MZ_PIO_MZ_RESET_PIN);
+  gpio_init(MZ_KEYSCAN_DETECTION_PIN);
+
+  gpio_set_dir(MZ_PIO_MOTOR_PIN, GPIO_IN);
+  gpio_pull_up(MZ_PIO_MOTOR_PIN);
+  gpio_set_dir(MZ_PIO_Z80_CLOCK_SW, GPIO_OUT);
+
+  gpio_set_dir(MZ_PIO_ROM_A15_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_ROM_A14_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_ROM_A13_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_ROM_A12_PIN, GPIO_OUT);
+
+  gpio_set_dir(MZ_PIO_ARRAY_RESET_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_ARRAY_DATA_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_ARRAY_STROBE_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_AX0_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_AX1_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_AX2_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_AX3_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_AY0_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_AY1_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_AY2_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_PIO_MZ_RESET_PIN, GPIO_OUT);
+  gpio_set_dir(MZ_KEYSCAN_DETECTION_PIN, GPIO_IN);
+  gpio_pull_up(MZ_KEYSCAN_DETECTION_PIN);
+
+  gpio_put(MZ_PIO_ROM_A15_PIN, 0);
+  gpio_put(MZ_PIO_ROM_A14_PIN, 0);
+  gpio_put(MZ_PIO_ROM_A13_PIN, 0);
+  gpio_put(MZ_PIO_ROM_A12_PIN, 0);
+  gpio_put(MZ_PIO_ARRAY_RESET_PIN, 0);
+  gpio_put(MZ_PIO_ARRAY_DATA_PIN, 0);
+  gpio_put(MZ_PIO_ARRAY_STROBE_PIN, 0);
+  gpio_put(MZ_PIO_AX0_PIN, 0);
+  gpio_put(MZ_PIO_AX1_PIN, 0);
+  gpio_put(MZ_PIO_AX2_PIN, 0);
+  gpio_put(MZ_PIO_AX3_PIN, 0);
+  gpio_put(MZ_PIO_AY0_PIN, 0);
+  gpio_put(MZ_PIO_AY1_PIN, 0);
+  gpio_put(MZ_PIO_AY2_PIN, 0);
+  gpio_put(MZ_PIO_MZ_RESET_PIN, 0);
+
+  // init queue
+  mz_host_queue_init();
+  
+  // init mode
+  mz_mode_init();
+
+  // set clock to safer value
+  set_z80_system_clock(Z80_CLOCK_2MHZ);
+
+  // set ROM A15-A12
+  system_mode = 0; // always SP-1002 while power-on init
+  mz_set_ROM_addr();
+
+  // init LED
+  kb_led_init();
+}
+
+
+// last pressed key
+static uint16_t last_on_syx = 0;
+
+void mz_switch_all_relase(void)
+{
+  // Release all keys
+  // Assert Reset of switch array IC
+  gpio_put(MZ_PIO_ARRAY_RESET_PIN, 1);
+
+  // init queue
+  mz_host_queue_init();
+
+  // init mode
+  mz_last_shift_state = false;
+  mz_last_lshift_state = false;
+  mz_last_rshift_state = false;
+  mz_last_ctrl_state = false;
+  fkey_def_mode = false;
+
+  // clear last pressed key
+  last_on_syx = 0;
+}
+
+// Switch ON/OFF
+void mz_switch_set(uint8_t x, uint8_t y, bool onoff)
+{
+  if (x > 5) x += 2;	// No switch on X=6 and X=7
+
+  gpio_put(MZ_PIO_AX0_PIN, x & 1);
+  gpio_put(MZ_PIO_AX1_PIN, (x & 2) ? 1 : 0);
+  gpio_put(MZ_PIO_AX2_PIN, (x & 4) ? 1 : 0);
+  gpio_put(MZ_PIO_AX3_PIN, (x & 8) ? 1 : 0);
+  gpio_put(MZ_PIO_AY0_PIN, y & 1);
+  gpio_put(MZ_PIO_AY1_PIN, (y & 2) ? 1 : 0);
+  gpio_put(MZ_PIO_AY2_PIN, (y & 4) ? 1 : 0);
+  gpio_put(MZ_PIO_ARRAY_DATA_PIN, (onoff) ? 1 : 0);
+  gpio_put(MZ_PIO_ARRAY_STROBE_PIN, 1);
+}
+
+void mz_switch_deassert_strobe(void)
+{
+  gpio_put(MZ_PIO_ARRAY_STROBE_PIN, 0);
+}
+
+// debounce
+void mz_switch_start_waiting_debounce(void)
+{
+  // Change task state
+  mz_key_sending_task_state =  gpio_get(MZ_PIO_ARRAY_DATA_PIN) ? MZ_TASK_STATE_KEY_WAIT_DEBOUNCE : MZ_TASK_STATE_KEY_WAIT_RELEASE_DEBOUNCE;
+  mz_task_start_ms = board_millis();
+  num_keyscan_called = 0;
+}
+
+// get next key
+void mz_switch_get_next_key(void)
+{
+  // Change task state
+  mz_key_sending_task_state = MZ_TASK_STATE_GETKEY;
+  mz_task_start_ms = board_millis();
+}
+
+// wait between the same key pressed again
+void mz_switch_start_waiting_between_the_same_key(void)
+{
+  // Change task state
+  mz_key_sending_task_state =  MZ_TASK_STATE_WAITING_BETWEEN_THE_SAME_KEY;
+  mz_task_start_ms = board_millis();
+}
+
+static void mz_switch_ctrl_alt_del(void)
+{
+  // set ROM A15-A12
+  mz_set_ROM_addr();
+
+  // Assert RESET on MZ
+  gpio_put(MZ_PIO_MZ_RESET_PIN, 1);
+}
+
+static void mz_switch_ctrl_alt_end(void)
+{
+  // Assert RESET on switch array IC
+  gpio_put(MZ_PIO_ARRAY_RESET_PIN, 1);
+
+  // init queue
+  mz_host_queue_init();
+
+  // init mode
+  mz_mode_init();
+
+  // init LED
+  kb_led_init();
+
+  // Change task state
+  mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_END_ASSERTED;
+  mz_task_start_ms = board_millis();
+}
+
+// Deassert RESET on SW array
+static void mz_switch_deassert_array_reset(void)
+{
+  // Dessert RESET on switch array IC
+  gpio_put(MZ_PIO_ARRAY_RESET_PIN, 0);
+}
+
+// Deassert RESET on MZ
+static void mz_switch_deassert_ctrl_alt_del(void)
+{
+  // Dessert RESET on MZ
+  gpio_put(MZ_PIO_MZ_RESET_PIN, 0);
+}
+
+// Send ASCII string as key strokes
+// must be after mz_fill_ascii2hid()
+static void mz_queue_string_as_key(const char *s)
+{
+  size_t l = strlen(s);
+
+  // RAWモードの時はやらない
+  if (mz_kb_mode == MZ_KBMODE_RAW) return;
+
+  // ALPHAモード以外(KANA,GRPH)ならALPHAモードにする
+  if (mz_kb_mode != MZ_KBMODE_ALPHA)
+  {
+    // [英数] キーをキュー
+    mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+    mz_key_queue_put(MZ_KEYCODE_ALPHA);
+  }
+  mz_kb_mode = MZ_KBMODE_ALPHA;
+
+  // Emulate key press
+  for (size_t n = 0; n < l; n++)
+  {
+    uint8_t fkeycode  = ascii2keycode[(uint8_t)s[n]];
+    uint8_t fmodifier = ascii2modifier[(uint8_t)s[n]];
+    bool       fis_shift = fmodifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT);
+    bool       fis_ctrl  = fmodifier & (KEYBOARD_MODIFIER_LEFTCTRL | KEYBOARD_MODIFIER_RIGHTCTRL);
+    bool const fis_alt   = fmodifier & (KEYBOARD_MODIFIER_LEFTALT  | KEYBOARD_MODIFIER_RIGHTALT);
+    // bool const fis_del   = (fkeycode == DELETE_KEY_CODE);
+    // bool const fis_end   = (fkeycode == END_KEY_CODE);
+    bool const fis_c     = (fkeycode == C_KEY_CODE);
+    bool const fis_caps  = (fkeycode == CAPS_KEY_CODE);
+    bool const fis_kana  = (fkeycode == KANA_KEY_CODE) || (fkeycode == KANA_KEY_CODE2);
+    bool const fis_grph  = (fkeycode == GRPH_KEY_CODE);
+    uint16_t syx;
+
+// モードシフト処理: KANA, GRPH, ALPHA (RAW以外)
+// -------------------------------------------------------------------
+    // KANA mode on
+    if ((MZ_KEYCODE_KANA != 0) && (fis_kana || (fis_caps && fis_shift && !fis_alt)))
+    {
+      mz_kb_mode = MZ_KBMODE_KANA;
+
+      if (MZ_KEYCODE_KANA == MZ_KEYCODE_ALPHA)
+      {
+        // [英数/カナ] キーの場合、シフト+英数キーをキュー
+        mz_key_queue_put(MZ_KEYCODE_LS | MZ_KEYPRESS);
+        mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+        mz_key_queue_put(MZ_KEYCODE_KANA);
+        mz_key_queue_put(MZ_KEYCODE_LS);
+      }
+      else
+      {
+        // [英数]/[カナ] 独立の場合、カナキーをキュー
+        mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+        mz_key_queue_put(MZ_KEYCODE_KANA);
+      }
+      // go to next key
+      continue;
+    }
+    // GRPH  mode on
+    else if ((MZ_KEYCODE_GRPH != 0) && fis_grph)
+    {
+      mz_kb_mode = MZ_KBMODE_GRPH;
+
+      if (NEED_ALPHA_GRPH)
+      {
+        // SA-1510(パッチ済み)の場合、[ALPHA][GRPH]の2キーを押す
+        mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+        mz_key_queue_put(MZ_KEYCODE_ALPHA);
+        mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+        mz_key_queue_put(MZ_KEYCODE_GRPH);
+      }
+      else
+      {
+        // [GRPH]キーをキュー
+        mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+        mz_key_queue_put(MZ_KEYCODE_GRPH);
+      }
+      // go to next key
+      continue;
+    }
+    // ALPHA mode on
+    else if (fis_caps && !fis_shift && !fis_alt)
+    {
+      mz_kb_mode = MZ_KBMODE_ALPHA;
+
+      // [英数] キーをキュー
+      mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+      mz_key_queue_put(MZ_KEYCODE_ALPHA);
+      // go to next key
+      continue;
+    }
+// -------------------------------------------------------------------
+
+// キーエンコード:
+// -------------------------------------------------------------------
+    // GRPH が無い場合、ALTでGRPH代わりとする
+    if (MZ_KEYCODE_GRPH == 0)
+    {
+      if (fis_alt)
+      {
+        syx = (uint16_t)KEYCODE2SYX[fkeycode][MZ_KBMODE_GRPH];
+      }
+      else
+      {
+        syx = (uint16_t)KEYCODE2SYX[fkeycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && fis_shift) ? 1 : 0)];
+      }
+    }
+    else
+    {
+      syx = (uint16_t)KEYCODE2SYX[fkeycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && fis_shift) ? 1 : 0)];
+    }
+
+    // Check CTRL-C / SHIFT-CTRL-C
+    // MZ-700J など、S-BASIC で CTRL-C (=ひらがな入力) など意味を持っている可能性があるため、CTRLキーを持つ機種でのこの処理は止める
+    if (MZ_KEYCODE_CTRL == 0 && fis_ctrl && fis_c)
+    {
+      // Queue [SHIFT] + [BREAK] key pressed
+      syx = MZ_KEYCODE_BREAK | MZ_SHIFT;
+      fis_ctrl = 0;
+    }
+// -------------------------------------------------------------------
+
+// キー押しエミュレーション (syx != 0)
+// -------------------------------------------------------------------
+    if (syx)
+    {
+      // コントロールキー
+      if (MZ_KEYCODE_CTRL != 0 && (fis_ctrl != mz_last_ctrl_state))
+      {
+        mz_last_ctrl_state = fis_ctrl;
+        mz_key_queue_put(MZ_KEYCODE_CTRL | (fis_ctrl ? MZ_KEYPRESS : 0));
+      }
+      bool sft = (syx & MZ_SHIFT);
+      syx = MZ_BARE_YX(syx);			// bare code
+      mz_last_shift_state = sft;
+      mz_last_lshift_state = false;
+      mz_last_rshift_state = false;
+      // press-release emulation
+      if (sft) mz_key_queue_put(MZ_KEYCODE_LS | MZ_KEYPRESS);	// SHIFT
+      mz_key_queue_put(syx | MZ_KEYPRESS);			// press
+      mz_key_queue_put(syx);					// release
+      if (sft) mz_key_queue_put(MZ_KEYCODE_LS);			// SHIFT
+    }
+// -------------------------------------------------------------------
+  }	// go to next key
+  // 最後にコントロールキーの辻褄を合わせる
+  if (MZ_KEYCODE_CTRL != 0 && mz_last_ctrl_state)
+  {
+    mz_last_ctrl_state = 0;
+    mz_key_queue_put(MZ_KEYCODE_CTRL);
+  }
+}
+
+// =======================================================================
+// flash access:
+
+const uint32_t			FLASH_TARGET_OFFSET = 0x1f0000u;	// 256MBのflashの最後のブロックのオフセット(64KB)
+static uint8_t			flash_data[FLASH_PAGE_SIZE];		// 256バイト
+static const uint8_t		FLASH_SIGNATURE[] = "kaokun";
+#define DATA_START_IN_PAGE	8					// シグネチャの後
+#define DATA_ERASED_FLAG	(FLASH_PAGE_SIZE - 1)			// 消去済フラグのページ内オフセット。0x00 erased
+#define DATA_PAGES		(FLASH_BLOCK_SIZE / FLASH_PAGE_SIZE)	// wear levellingのため: 64KB/256 = 256 pages
+#define FLASH_MEM_PTR(p)	((void *)(XIP_BASE + FLASH_TARGET_OFFSET + ((p) * FLASH_PAGE_SIZE)))
+
+#define SETTINGS_PAGES		(MZ_NUM_FKEYS + 1)			// 8
+#define LAST_PAGE		(DATA_PAGES - SETTINGS_PAGES)		// 256-8 = 248 : このページまでは書ける。計32個のデータをラウンドロビンで使う事でウェアレベリングとする。
+
+// 指定の頁にシグネチャがあるかチェック
+static bool flash_check_signature(uint32_t page)
+{
+  // check signature
+  return (memcmp(FLASH_MEM_PTR(page), FLASH_SIGNATURE, sizeof(FLASH_SIGNATURE)) == 0);
+}
+
+// 設定消去 (フラッシュのerase)
+static void erase_settings(void)
+{
+  // get latest settings
+  bool found = false;
+  uint32_t page;
+  for (page = 0; page <= LAST_PAGE; page += SETTINGS_PAGES)
+  {
+    if (flash_check_signature(page))
+    {
+      found = true;
+      // read data
+      // 設定
+      memcpy(flash_data, (const uint8_t *)(XIP_BASE + FLASH_TARGET_OFFSET + FLASH_PAGE_SIZE * page), FLASH_PAGE_SIZE);
+    };
+  }
+  if (found && page >= LAST_PAGE)	// 見つけたのが最後のページだった場合は全消去
+  {
+    // disable interrupt
+    uint32_t ints = save_and_disable_interrupts();
+    // erase
+    flash_range_erase(FLASH_TARGET_OFFSET, FLASH_BLOCK_SIZE);	// ブロック64KB全部消す (本当はセクタ4096byteの倍数で消せるが)
+    // restore interrupt
+    restore_interrupts(ints);
+  }
+  else if (found && flash_data[DATA_ERASED_FLAG] == 0xffu)
+  {
+    // シグネチャ有効かつ未消去ページが見つかった場合
+    // このセクタの消去済フラグに0x00を書き込む
+    flash_data[DATA_ERASED_FLAG] = 0;
+    // disable interrupt
+    uint32_t ints = save_and_disable_interrupts();
+    // write
+    flash_range_program(FLASH_TARGET_OFFSET + FLASH_PAGE_SIZE * page, flash_data, FLASH_PAGE_SIZE);
+    // restore interrupt
+    restore_interrupts(ints);
+  }
+}
+
+// 設定保存
+static void save_settings(void)
+{
+  // fill with FF
+  for (unsigned int i = 0; i < FLASH_PAGE_SIZE; i++) flash_data[i] = (uint8_t)0xffu;
+
+  // set signature
+  memcpy(flash_data, FLASH_SIGNATURE, sizeof(FLASH_SIGNATURE));
+
+  // set sysmode
+  *((uint16_t *)        (void *)&(flash_data[DATA_START_IN_PAGE])) = system_mode;
+  //set clock mode
+  *((z80_clock_mode_t *)(void *)&(flash_data[DATA_START_IN_PAGE + sizeof(uint16_t)])) = z80_clock_mode;
+  // debounce counters
+  *((uint32_t *)        (void *)&(flash_data[DATA_START_IN_PAGE + sizeof(uint16_t) + sizeof(uint16_t)])) = n_keyscans_press_debounce;
+  *((uint32_t *)        (void *)&(flash_data[DATA_START_IN_PAGE + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t)])) = n_keyscans_release_debounce;
+
+  // get free page
+  bool erase = false;
+  uint32_t page;
+  for (page = 0; page <= LAST_PAGE; page += SETTINGS_PAGES)
+  {
+    if (!flash_check_signature(page))	break;
+  }
+  if (page > LAST_PAGE)
+  {
+    page = 0;
+    erase = true;
+  }
+
+  // disable interrupt
+  uint32_t ints = save_and_disable_interrupts();
+  // erase
+  if (erase) flash_range_erase(FLASH_TARGET_OFFSET, FLASH_BLOCK_SIZE);	// ブロック64KB全部消す (本当はセクタ4096byteの倍数で消せるが)
+
+  // write
+  // 設定
+  flash_range_program(FLASH_TARGET_OFFSET + FLASH_PAGE_SIZE * page++, flash_data, FLASH_PAGE_SIZE);
+  // ファンクションキー
+  for (uint32_t fn = 0; fn < MZ_NUM_FKEYS; fn++)
+  {
+    flash_range_program(FLASH_TARGET_OFFSET + FLASH_PAGE_SIZE * page++, (uint8_t *)&(mz_func_key_store[fn]), FLASH_PAGE_SIZE);
+  }
+
+  // restore interrupt
+  restore_interrupts(ints);
+}
+
+// 設定の読み出し、またはデフォルトのセット
+//   system_mode, z80_clock_mode, debounce_count，ファンクションキーマクロ
+static void load_settings(void)
+{
+  // 設定が無かったときのためにまずデフォルト値をセットしておく
+  system_mode = SYSTEM_MODE_DEFAULT;
+  z80_clock_mode = Z80_CLOCK_MODE_AUTO;
+  init_debounce_count();
+  mz_func_key_init();
+
+
+  // get latest settings
+  bool found = false;
+  uint32_t page, found_page;
+  for (page = 0; page <= (DATA_PAGES - SETTINGS_PAGES); page += SETTINGS_PAGES)
+  {
+    if (flash_check_signature(page))
+    {
+      found = true;
+      found_page = page;
+    };
+  }
+
+  if (found)
+  {
+    page = found_page;
+    // 設定部分をとりあえずリードしておく
+    memcpy(flash_data, (const uint8_t *)(XIP_BASE + FLASH_TARGET_OFFSET + FLASH_PAGE_SIZE * page++), FLASH_PAGE_SIZE);
+
+    // 有効なデータか？
+    if (flash_data[DATA_ERASED_FLAG] == 0xffu)
+    {
+      // signature check OK, return the data
+      // sysmode
+      system_mode =                 *((uint16_t *)(void *)&(flash_data[DATA_START_IN_PAGE]));								// offset 8
+      // clock mode
+      z80_clock_mode =      *((z80_clock_mode_t *)(void *)&(flash_data[DATA_START_IN_PAGE + sizeof(uint16_t)]));					// offset 10
+      // debounce counters
+      n_keyscans_press_debounce   = *((uint32_t *)(void *)&(flash_data[DATA_START_IN_PAGE + sizeof(uint16_t) + sizeof(uint16_t)]));			// offset 12
+      n_keyscans_release_debounce = *((uint32_t *)(void *)&(flash_data[DATA_START_IN_PAGE + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t)]));	// offset 16
+
+      // ファンクションキーのリード
+      for (uint32_t fn = 0; fn < MZ_NUM_FKEYS; fn++)
+      {
+        memcpy((uint8_t *)&(mz_func_key_store[fn]), (const uint8_t *)(XIP_BASE + FLASH_TARGET_OFFSET + FLASH_PAGE_SIZE * page++), FLASH_PAGE_SIZE);
+      }
+    }
+  }
+}
+
+// =======================================================================
+
+/*------------- MAIN -------------*/
+int main(void)
+{
+  board_init();
+
+  // init GPIO and switches
+  mz_switch_init();
+
+  // fill ascii2hid table
+  mz_fill_ascii2hid();
+
+  // printf("MZKB + TinyUSB Host HID <-> Device CDC Example\r\n");
+
+  // init device and host stack on configured roothub port
+  tud_init(BOARD_TUD_RHPORT);
+  tuh_init(BOARD_TUH_RHPORT);
+
+  // enable keyscan detection
+  gpio_set_irq_enabled_with_callback(MZ_KEYSCAN_DETECTION_PIN, GPIO_IRQ_EDGE_FALL, true, &keyscan_detection_callback);
+  num_keyscan_called = 0;
+
+  // 設定の読み出し、またはデフォルトのセット
+  //   system_mode, z80_clock_mode, debounce_count，ファンクションキーマクロ
+  load_settings();
+
+  // initial task state
+  mz_key_sending_task_state = MZ_TASK_STATE_POWERON;
+
+  while (1)
+  {
+    tud_task(); // tinyusb device task
+    tuh_task(); // tinyusb host task
+    led_blinking_task();
+    mz_host2mz_task();
+    mz_sendkey_task();
+    keyboard_led_blinking_task();
+    z80_system_clock_task();
+  }
+
+  return 0;
+}
+
+//--------------------------------------------------------------------+
+// Device CDC
+//--------------------------------------------------------------------+
+
+// Invoked when device is mounted
+void tud_mount_cb(void)
+{
+  blink_interval_ms = BLINK_MOUNTED;
+}
+
+// Invoked when device is unmounted
+void tud_umount_cb(void)
+{
+  blink_interval_ms = BLINK_NOT_MOUNTED;
+}
+
+// Invoked when usb bus is suspended
+// remote_wakeup_en : if host allow us  to perform remote wakeup
+// Within 7ms, device must draw an average of current less than 2.5 mA from bus
+void tud_suspend_cb(bool remote_wakeup_en)
+{
+  (void) remote_wakeup_en;
+  blink_interval_ms = BLINK_SUSPENDED;
+}
+
+// Invoked when usb bus is resumed
+void tud_resume_cb(void)
+{
+  blink_interval_ms = BLINK_MOUNTED;
+}
+
+// Invoked when CDC interface received data from host
+void tud_cdc_rx_cb(uint8_t itf)
+{
+  (void) itf;
+
+  char buf[64];
+  uint32_t count = tud_cdc_read(buf, sizeof(buf));
+
+  for (uint32_t i = 0; i < count; i++)
+  {
+    mz_host_queue_put(buf[i]);
+  }
+}
+
+//--------------------------------------------------------------------+
+// Host HID
+//--------------------------------------------------------------------+
+
+// Invoked when device with hid interface is mounted
+// Report descriptor is also available for use. tuh_hid_parse_report_descriptor()
+// can be used to parse common/simple enough descriptor.
+// Note: if report descriptor length > CFG_TUH_ENUMERATION_BUFSIZE, it will be skipped
+// therefore report_desc = NULL, desc_len = 0
+void tuh_hid_mount_cb(uint8_t dev_addr, uint8_t instance, uint8_t const* desc_report, uint16_t desc_len)
+{
+  (void)desc_report;
+  (void)desc_len;
+
+  // Interface protocol (hid_interface_protocol_enum_t)
+  const char* protocol_str[] = { "None", "Keyboard", "Mouse" };
+  uint8_t const itf_protocol = tuh_hid_interface_protocol(dev_addr, instance);
+
+  uint16_t vid, pid;
+  tuh_vid_pid_get(dev_addr, &vid, &pid);
+
+  char tempbuf[256];
+  int count = sprintf(tempbuf, "[%04x:%04x][%u] HID Interface%u, Protocol = %s\r\n", vid, pid, dev_addr, instance, protocol_str[itf_protocol]);
+  tud_cdc_write(tempbuf, (uint32_t) count);
+  tud_cdc_write_flush();
+
+  // Receive report from boot keyboard & mouse only
+  // tuh_hid_report_received_cb() will be invoked when report is available
+  if (itf_protocol == HID_ITF_PROTOCOL_KEYBOARD || itf_protocol == HID_ITF_PROTOCOL_MOUSE)
+  {
+    if ( !tuh_hid_receive_report(dev_addr, instance) )
+    {
+      tud_cdc_write_str("Error: cannot request report\r\n");
+    }
+  }
+
+  // When HID Keyboard attached
+  if (itf_protocol == HID_ITF_PROTOCOL_KEYBOARD)
+  {
+    // Init LED
+    leds = 0;
+    prev_leds = 0;
+    keybd_dev_addr = dev_addr;
+    keybd_instance = instance;
+    tuh_hid_set_report(keybd_dev_addr, keybd_instance, 0, HID_REPORT_TYPE_OUTPUT, &leds, sizeof(leds));
+
+    // Reset SW Array & key state
+    mz_switch_all_relase();
+    // VBUS電源入れ直し中は状態変化させないが、他は初期状態へ
+    if (mz_key_sending_task_state != MZ_TASK_STATE_CYCLE_VBUS_WAITING)
+    {
+      mz_key_sending_task_state = MZ_TASK_STATE_RESET_ASSERTED;
+    }
+    mz_task_start_ms = board_millis();
+  }
+}
+
+// Invoked when device with hid interface is un-mounted
+void tuh_hid_umount_cb(uint8_t dev_addr, uint8_t instance)
+{
+  char tempbuf[256];
+  int count = sprintf(tempbuf, "[%u] HID Interface%u is unmounted\r\n", dev_addr, instance);
+  tud_cdc_write(tempbuf, (uint32_t) count);
+  tud_cdc_write_flush();
+
+  // Reset SW Array & key state
+  mz_switch_all_relase();
+  // VBUS電源入れ直し中は状態変化させないが、他は初期状態へ
+  if (mz_key_sending_task_state != MZ_TASK_STATE_CYCLE_VBUS_WAITING)
+  {
+    mz_key_sending_task_state = MZ_TASK_STATE_RESET_ASSERTED;
+  }
+  mz_task_start_ms = board_millis();
+
+  keybd_dev_addr = 0xFFu;
+
+  // Init KB LED
+  leds = 0;
+  prev_leds = 0;
+  blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_NONE;
+
+  // init mode
+  mz_mode_init();
+}
+
+// look up new key in previous keys
+static inline bool find_key_in_report(hid_keyboard_report_t const *report, uint8_t keycode)
+{
+  for(uint8_t i=0; i<6; i++)
+  {
+    if (report->keycode[i] == keycode)  return true;
+  }
+
+  return false;
+}
+
+
+// convert hid keycode to ascii and print via usb device CDC (ignore non-printable)
+static void process_kbd_report(uint8_t dev_addr, hid_keyboard_report_t const *report)
+{
+  (void) dev_addr;
+  static hid_keyboard_report_t prev_report = { 0, 0, {0} }; // previous report to check key released
+  bool flush = false;
+  static uint8_t last_modifier = 0;
+
+  bool       is_shift  = report->modifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT);
+  bool const is_lshift = report->modifier & KEYBOARD_MODIFIER_LEFTSHIFT;
+  bool const is_rshift = report->modifier & KEYBOARD_MODIFIER_RIGHTSHIFT;
+  bool const is_ctrl   = report->modifier & (KEYBOARD_MODIFIER_LEFTCTRL | KEYBOARD_MODIFIER_RIGHTCTRL);
+  bool const is_alt    = report->modifier & (KEYBOARD_MODIFIER_LEFTALT  | KEYBOARD_MODIFIER_RIGHTALT);
+
+  char tempbuf[256];
+  int count;
+
+  // Check modifier change
+  // シフトキー、コントロールを処理する
+  if (last_modifier != report->modifier)
+  {
+    count = sprintf(tempbuf, "Modifier: %02x -> %02x\r\n", last_modifier, report->modifier);
+    tud_cdc_write(tempbuf, (uint32_t) count);
+    flush = true;
+
+    // シフトキーは RAW モード時のみ処理する
+    // (Cooked modeではシフトキーはキー変換に応じて処理されるので、ここではやらない)
+    // -->Report the changed modifier
+    if (mz_kb_mode == MZ_KBMODE_RAW)
+    {
+      if (MZ_KEYCODE_LS != MZ_KEYCODE_RS) {
+        // LS and RS are different keys on the matrix
+        if ((last_modifier ^ report->modifier) & KEYBOARD_MODIFIER_LEFTSHIFT)
+        {
+          // LS changed
+          mz_key_queue_put(MZ_KEYCODE_LS | (is_lshift ? MZ_KEYPRESS : 0));
+        }
+        if ((last_modifier ^ report->modifier) & KEYBOARD_MODIFIER_RIGHTSHIFT)
+        {
+          // RS changed
+          mz_key_queue_put(MZ_KEYCODE_RS | (is_rshift ? MZ_KEYPRESS : 0));
+        }
+      }
+      else {
+        // LS and RS are the same key on the matrix
+        if ((last_modifier ^ report->modifier) & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT))
+        {
+          // LS or RSchanged
+          mz_key_queue_put(MZ_KEYCODE_LS | (is_shift ? MZ_KEYPRESS : 0));
+        }
+      }
+    }
+
+    // コントロールキーはRAWモードかどうかかかわらずやる
+    if (MZ_KEYCODE_CTRL != 0 && (is_ctrl != mz_last_ctrl_state))
+    {
+      mz_last_ctrl_state = is_ctrl;
+      mz_key_queue_put(MZ_KEYCODE_CTRL | (is_ctrl ? MZ_KEYPRESS : 0));
+    }
+  }
+  last_modifier = report->modifier;
+
+  for(uint8_t i=0; i<6; i++)
+  {
+    uint8_t keycode = report->keycode[i];
+    bool const is_del   = (keycode == DELETE_KEY_CODE);
+    bool const is_end   = (keycode == END_KEY_CODE);
+    bool const is_c     = (keycode == C_KEY_CODE);
+    bool const is_caps  = (keycode == CAPS_KEY_CODE);
+    bool const is_kana  = (keycode == KANA_KEY_CODE) || (keycode == KANA_KEY_CODE2);
+    bool const is_grph  = (keycode == GRPH_KEY_CODE);
+#ifdef MZ_DEBOUNCE_ADJUST
+    bool const is_up    = (keycode == UP_KEY_CODE);
+    bool const is_down  = (keycode == DOWN_KEY_CODE);
+#endif
+    bool const is_left  = (keycode == LEFT_KEY_CODE);
+    bool const is_right = (keycode == RIGHT_KEY_CODE);
+
+    if ( keycode )
+    {
+      if ( keycode && find_key_in_report(&prev_report, keycode) )
+      {
+        // exists in previous report means the current key is still holding
+      }
+      else
+      {
+        // not exist in previous report means the current key is newly pressed
+
+        // remap the key code for Colemak layout
+        #ifdef KEYBOARD_COLEMAK
+        uint8_t colemak_key_code = colemak[keycode];
+        if (colemak_key_code != 0) keycode = colemak_key_code;
+        #endif
+
+// モードシフト処理: RAW, KANA, GRPH, ALPHA
+// -------------------------------------------------------------------
+        // [ALT]+[CAPS]: RAW mode / COOKED mode 切替え
+        if (is_caps && is_alt)
+        {
+          // RAWならALPHAへ、そうで無ければRAWへ
+          mz_kb_mode = (mz_kb_mode == MZ_KBMODE_RAW) ? MZ_KBMODE_ALPHA : MZ_KBMODE_RAW;
+
+          // All key relase when entering/leaving RAW mode
+          mz_switch_all_relase();
+
+          // Change task state
+          mz_key_sending_task_state = MZ_TASK_STATE_ARRAY_RESET_ASSERTED;
+          mz_task_start_ms = board_millis();
+
+          // ALPHA とするため [英数] キーをキュー (★MZ New Monitorはカナモードのトグルで同期が取れなくなるためパッチ必要)
+          mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+          mz_key_queue_put(MZ_KEYCODE_ALPHA);
+
+          count = sprintf(tempbuf, "MZ: KB MODE = %s\r\n", mz_input_modestring(mz_kb_mode));
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+          // go to next key
+          continue;
+        }
+
+        // KANA mode on
+        else if ((mz_kb_mode != MZ_KBMODE_RAW) && (MZ_KEYCODE_KANA != 0) && (is_kana || (is_caps && is_shift && !is_alt)))
+        {
+          mz_kb_mode = MZ_KBMODE_KANA;
+
+          if (MZ_KEYCODE_KANA == MZ_KEYCODE_ALPHA)
+          {
+            // [英数/カナ] キーの場合、シフト+英数キーをキュー
+            mz_key_queue_put(MZ_KEYCODE_LS | MZ_KEYPRESS);
+            mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+            mz_key_queue_put(MZ_KEYCODE_KANA);
+            mz_key_queue_put(MZ_KEYCODE_LS);
+          }
+          else
+          {
+            // [英数]/[カナ] 独立の場合、カナキーをキュー
+            mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+            mz_key_queue_put(MZ_KEYCODE_KANA);
+          }
+
+          count = sprintf(tempbuf, "[KANA ON]\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+
+          // go to next key
+          continue;
+        }
+
+        // GRPH  mode on
+        else if ((mz_kb_mode != MZ_KBMODE_RAW) && (MZ_KEYCODE_GRPH != 0) && is_grph)
+        {
+          mz_kb_mode = MZ_KBMODE_GRPH;
+
+          if (NEED_ALPHA_GRPH)
+          {
+            // SA-1510(パッチ済み)の場合、[ALPHA][GRPH]の2キーを押す
+            mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+            mz_key_queue_put(MZ_KEYCODE_ALPHA);
+            mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+            mz_key_queue_put(MZ_KEYCODE_GRPH);
+          }
+          else
+          {
+            // [GRPH]キーをキュー
+            mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+            mz_key_queue_put(MZ_KEYCODE_GRPH);
+          }
+
+          count = sprintf(tempbuf, "[GRPH ON]\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+
+          // go to next key
+          continue;
+        }
+
+        // ALPHA mode on
+        else if ((mz_kb_mode != MZ_KBMODE_RAW) && is_caps && !is_shift && !is_alt)
+        {
+          mz_kb_mode = MZ_KBMODE_ALPHA;
+
+          // [英数] キーをキュー
+          mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+          mz_key_queue_put(MZ_KEYCODE_ALPHA);
+
+          count = sprintf(tempbuf, "[ALPHA ON]\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+
+          // go to next key
+          continue;
+        }
+// -------------------------------------------------------------------
+
+// ファンクションキー(キーマクロ)定義モードの検出とキーの記録:
+// -------------------------------------------------------------------
+        // キーマクロ定義モードの検出と遷移: [ALT]+[Fn]
+        // disabled in RAW mode
+        //------------------------------------------------------------
+        if (mz_kb_mode != MZ_KBMODE_RAW && is_alt && (keycode >= MZ_START_FKEY) && (keycode <= MZ_END_FKEY))
+        {
+          uint16_t keynum = keycode - MZ_START_FKEY;
+
+          if (!fkey_def_mode)
+          {
+            // enter fkey definition mode
+            count = sprintf(tempbuf, "Enter [F%d] definition mode\r\n", keynum + (MZ_START_FKEY - F1_KEY_CODE) + 1);
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+
+            fkey_def_mode = true;
+            fkey_def_keynum  = keynum;
+            mz_func_key_store[fkey_def_keynum].length = 0;
+            mz_func_key_store[fkey_def_keynum].initial_mz_kb_mode  = mz_kb_mode;
+          }
+          else
+          {
+            // exit from fkey definition mode
+            count = sprintf(tempbuf, "Exit [F%d] definition mode\r\n", fkey_def_keynum + 1);
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+
+            fkey_def_mode = false;
+          }
+          // once enter / exit the mode, this key is done and wait for the next key
+          continue;
+        }
+        //------------------------------------------------------------
+
+        // キーマクロ定義モードならキーとmodifierの記録
+        // if fkey_def_mode, record the keycode and modifier
+        //------------------------------------------------------------
+        if (fkey_def_mode)
+        {
+            if (mz_func_key_store[fkey_def_keynum].length < MZ_FKEY_MAXLEN)
+            {
+              mz_func_key_store[fkey_def_keynum].keycode[mz_func_key_store[fkey_def_keynum].length]  = keycode;
+              mz_func_key_store[fkey_def_keynum].modifier[mz_func_key_store[fkey_def_keynum].length] = report->modifier;
+              mz_func_key_store[fkey_def_keynum].length++;
+            }
+            if (mz_func_key_store[fkey_def_keynum].length >= MZ_FKEY_MAXLEN)
+            {
+              // exit from fkey definition mode
+              count = sprintf(tempbuf, "Exit [F%d] definition mode due to buffer full\r\n", fkey_def_keynum + 1);
+              tud_cdc_write(tempbuf, (uint32_t) count);
+              flush = true;
+
+              fkey_def_mode = false;
+            }
+        }
+        //------------------------------------------------------------
+// -------------------------------------------------------------------
+
+// 入力したキーの表示(デバッグ用)
+// -------------------------------------------------------------------
+        uint8_t ch = keycode2ascii[keycode][is_shift ? 1 : 0];
+        if (ch && !(ch & 0x80))
+        {
+          tud_cdc_write("C:", 2);
+          if (ch == '\r') tud_cdc_write("[CR]", 4);
+          else if (ch == '\t') tud_cdc_write("[TAB]", 5);
+          else if (ch == '\b') tud_cdc_write("[BS]", 4);
+          else if (ch == ' ') tud_cdc_write("[SP]", 4);
+          else if (ch < 0x20u || ch >= 0x80u)
+          {
+            count = sprintf(tempbuf, "[%02x]", ch);
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+          }
+          else tud_cdc_write(&ch, 1);
+          tud_cdc_write("\r\n", 2);
+          flush = true;
+        }
+        else
+        {
+          count = sprintf(tempbuf, "H:%02x/%02x\r\n", keycode, report->modifier);
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+        }
+// -------------------------------------------------------------------
+
+
+// 特殊キー操作
+/*
+  ■[CTRL]+[ALT]+[DEL]: 現在のシステムモードでROMを切り替えずリセットスイッチを押す (Cold Reset)
+  ■[CTRL]+[ALT]+[END]: 現在のシステムモードでROMを切り替えず[CTRL]+リセットスイッチを押す (MZ-700系のWarm Resetのエミュレーション)
+  ■[ALT] (+ [CTRL]) + テンキー[0]-[7]: システムモードの切り替え
+  　ROMを切り替えてリセットスイッチを押す(Cold Reset)
+*/
+// -------------------------------------------------------------------
+        // Check CTRL-ALT-DEL
+        if (is_ctrl && is_alt && is_del)
+        {
+          mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_DEL;
+          // no need to continue. just return.
+          return;
+        }
+
+        // Check CTRL-ALT-END
+        if (is_ctrl && is_alt && is_end)
+        {
+          if (MZ_KEYCODE_CTRL)
+          {
+            // コントロールキーがあるシステムのみ
+            mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_END;
+          }
+          else
+          {
+            // コントロールキーが無いシステムではCTRL-ALT-DELと同じ
+            mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_DEL;
+          }
+          // no need to continue. just return.
+          return;
+        }
+
+        // Check ALT + ten key [0]-[7] (+ CTRL)
+        if (is_alt && ((keycode >= TENKEY_1_KEY_CODE && keycode <= TENKEY_7_KEY_CODE) || (keycode == TENKEY_0_KEY_CODE)))
+        {
+          uint16_t keynum = keycode - TENKEY_1_KEY_CODE + 1;	// 1-7
+          if (keynum > 7) keynum = 0;				// 0-7
+	  if (is_ctrl) keynum += 8;				// 8-15
+
+          count = sprintf(tempbuf, "MZ: system_mode = %d\r\n", keynum);
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+
+          system_mode = keynum;
+
+          // init debounce count according to system mode
+          init_debounce_count();
+
+          mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_DEL;
+          // no need to continue. just return.
+          return;
+        }
+
+        // Check ALT + ten key [+][-][*]
+        if (is_alt && (keycode == TENKEY_PLUS_KEY_CODE))
+        {
+          count = sprintf(tempbuf, "MZ: CLK 4MHz\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+          z80_clock_mode = Z80_CLOCK_MODE_4MHZ;
+          continue;
+        }
+        if (is_alt && (keycode == TENKEY_MINUS_KEY_CODE))
+        {
+          count = sprintf(tempbuf, "MZ: CLK 2MHz\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+          z80_clock_mode = Z80_CLOCK_MODE_2MHZ;
+          continue;
+        }
+        if (is_alt && (keycode == TENKEY_ASTERISK_KEY_CODE))
+        {
+          count = sprintf(tempbuf, "MZ: CLK AUTO\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+          z80_clock_mode = Z80_CLOCK_MODE_AUTO;
+          continue;
+        }
+
+	// [ALT] + ten key [8]: erase settings
+        if (is_alt && !is_shift && !is_ctrl && keycode == TENKEY_8_KEY_CODE)
+	{
+          count = sprintf(tempbuf, "MZ: erase settings\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+	  flush = true;
+	  erase_settings();
+          // この後、タイミングによってはUSBからの割り込みが来なくなるのでいったんVBUSを落とす
+          mz_key_sending_task_state = MZ_TASK_STATE_CYCLE_VBUS;
+          mz_task_start_ms = board_millis();
+          continue;
+	}
+
+	// [ALT] + ten key [9]: save settings
+        if (is_alt && !is_shift && !is_ctrl && keycode == TENKEY_9_KEY_CODE)
+	{
+          count = sprintf(tempbuf, "MZ: save settings\r\n");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+	  flush = true;
+	  save_settings();
+          // この後、タイミングによってはUSBからの割り込みが来なくなるのでいったんVBUSを落とす
+          mz_key_sending_task_state = MZ_TASK_STATE_CYCLE_VBUS;
+          continue;
+	}
+
+// -------------------------------------------------------------------
+
+// キータイミングのデバッグ用:
+// -------------------------------------------------------------------
+#ifdef MZ_DEBOUNCE_ADJUST
+        // ALT-UP/DOWN/LEFT/RIGHT
+        // adjust debounce timing
+        if (is_alt & is_down) {
+          if (n_keyscans_press_debounce > 1) n_keyscans_press_debounce--;
+          sprintf(tempbuf, "press debounce = %u\r", n_keyscans_press_debounce);
+          mz_queue_string_as_key(tempbuf);
+          continue;
+        }
+        else if (is_alt & is_up) {
+          if (n_keyscans_press_debounce < 1000) n_keyscans_press_debounce++;
+          sprintf(tempbuf, "press debounce = %u\r", n_keyscans_press_debounce);
+          mz_queue_string_as_key(tempbuf);
+          continue;
+        }
+        else if (is_alt & is_left) {
+          if (n_keyscans_release_debounce > 1) n_keyscans_release_debounce--;
+          sprintf(tempbuf, "release debounce = %u\r", n_keyscans_release_debounce);
+          mz_queue_string_as_key(tempbuf);
+          continue;
+        }
+        else if (is_alt & is_right) {
+          if (n_keyscans_release_debounce < 1000) n_keyscans_release_debounce++;
+          sprintf(tempbuf, "release debounce = %u\r", n_keyscans_release_debounce);
+          mz_queue_string_as_key(tempbuf);
+          continue;
+        }
+#else
+        if (is_alt & is_left) {
+          if (n_keyscans_release_debounce > M_KEYSCANS_RELEASE_DEBOUNCE_DEF)		n_keyscans_release_debounce = M_KEYSCANS_RELEASE_DEBOUNCE_DEF;
+          else if (n_keyscans_release_debounce > L_KEYSCANS_RELEASE_DEBOUNCE_DEF)	n_keyscans_release_debounce = L_KEYSCANS_RELEASE_DEBOUNCE_DEF;
+          sprintf(tempbuf, "release debounce = %u\r", n_keyscans_release_debounce);
+          mz_queue_string_as_key(tempbuf);
+          continue;
+        }
+        else if (is_alt & is_right) {
+          if (n_keyscans_release_debounce < M_KEYSCANS_RELEASE_DEBOUNCE_DEF)		n_keyscans_release_debounce = M_KEYSCANS_RELEASE_DEBOUNCE_DEF;
+          else if (n_keyscans_release_debounce < H_KEYSCANS_RELEASE_DEBOUNCE_DEF)	n_keyscans_release_debounce = H_KEYSCANS_RELEASE_DEBOUNCE_DEF;
+          sprintf(tempbuf, "release debounce = %u\r", n_keyscans_release_debounce);
+          mz_queue_string_as_key(tempbuf);
+          continue;
+        }
+#endif
+// -------------------------------------------------------------------
+
+
+// ファンクションキー(キーマクロ)の検出とマクロの処理:
+// -------------------------------------------------------------------
+        // [F1] - [F12]
+        // function key
+        // [ =============================================================
+        if (mz_kb_mode != MZ_KBMODE_RAW && (keycode >= MZ_START_FKEY) && (keycode <= MZ_END_FKEY))
+        {
+          // Function keys are disabled in RAW mode
+          uint16_t keynum = keycode - MZ_START_FKEY;
+          size_t l = mz_func_key_store[keynum].length;
+
+          mz_kb_mode  =  mz_func_key_store[keynum].initial_mz_kb_mode;
+
+          count = sprintf(tempbuf, "[F%d],kb:%s\r\n", keynum + (MZ_START_FKEY - F1_KEY_CODE) + 1, mz_input_modestring(mz_kb_mode));
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+
+        // ファンクションキーマクロ用の初期モードシフト処理: KANA, GRPH, ALPHA (RAWはやらない)
+        // -------------------------------------------------------------------
+          // KANA mode on
+          if ((MZ_KEYCODE_KANA != 0) && (mz_kb_mode == MZ_KBMODE_KANA))
+          {
+            if (MZ_KEYCODE_KANA == MZ_KEYCODE_ALPHA)
+            {
+              // [英数/カナ] キーの場合、シフト+英数キーをキュー
+              mz_key_queue_put(MZ_KEYCODE_LS | MZ_KEYPRESS);
+              mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+              mz_key_queue_put(MZ_KEYCODE_KANA);
+              mz_key_queue_put(MZ_KEYCODE_LS);
+            }
+            else
+            {
+              // [英数]/[カナ] 独立の場合、カナキーをキュー
+              mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+              mz_key_queue_put(MZ_KEYCODE_KANA);
+            }
+
+            count = sprintf(tempbuf, "[KANA mode ON]\r\n");
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+          }
+          // GRPH  mode on
+          else if ((MZ_KEYCODE_GRPH != 0) && (mz_kb_mode == MZ_KBMODE_GRPH))
+          {
+            if (NEED_ALPHA_GRPH)
+            {
+              // SA-1510(パッチ済み)の場合、[ALPHA][GRPH]の2キーを押す
+              mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+              mz_key_queue_put(MZ_KEYCODE_ALPHA);
+              mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+              mz_key_queue_put(MZ_KEYCODE_GRPH);
+            }
+            else
+            {
+              // [GRPH]キーをキュー
+              mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+              mz_key_queue_put(MZ_KEYCODE_GRPH);
+            }
+
+            count = sprintf(tempbuf, "[GRPH mode ON]\r\n");
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+          }
+          // ALPHA mode on
+          else
+          {
+            mz_kb_mode = MZ_KBMODE_ALPHA;
+
+            // [英数] キーをキュー
+            mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+            mz_key_queue_put(MZ_KEYCODE_ALPHA);
+
+            count = sprintf(tempbuf, "[ALPHA mode ON]\r\n");
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+          }
+        // -------------------------------------------------------------------
+
+        // ファンクションキーマクロの実行
+        // -------------------------------------------------------------------
+          for (size_t n = 0; n < l; n++)
+          {
+            uint8_t fkeycode     = mz_func_key_store[keynum].keycode[n];
+            uint8_t fmodifier    = mz_func_key_store[keynum].modifier[n];
+            bool       fis_shift = fmodifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT);
+            bool       fis_ctrl  = fmodifier & (KEYBOARD_MODIFIER_LEFTCTRL | KEYBOARD_MODIFIER_RIGHTCTRL);
+            bool const fis_alt   = fmodifier & (KEYBOARD_MODIFIER_LEFTALT  | KEYBOARD_MODIFIER_RIGHTALT);
+            // bool const fis_del   = (fkeycode == DELETE_KEY_CODE);
+            // bool const fis_end   = (fkeycode == END_KEY_CODE);
+            bool const fis_c     = (fkeycode == C_KEY_CODE);
+            bool const fis_caps  = (fkeycode == CAPS_KEY_CODE);
+            bool const fis_kana  = (fkeycode == KANA_KEY_CODE) || (fkeycode == KANA_KEY_CODE2);
+            bool const fis_grph  = (fkeycode == GRPH_KEY_CODE);
+            uint16_t syx;
+
+
+          // キーマクロ実行内モードシフト処理: KANA, GRPH, ALPHA (RAW以外)
+          // -------------------------------------------------------------------
+            // KANA mode on
+            if ((MZ_KEYCODE_KANA != 0) && (fis_kana || (fis_caps && fis_shift && !fis_alt)))
+            {
+              mz_kb_mode = MZ_KBMODE_KANA;
+
+              if (MZ_KEYCODE_KANA == MZ_KEYCODE_ALPHA)
+              {
+                // [英数/カナ] キーの場合、シフト+英数キーをキュー
+                mz_key_queue_put(MZ_KEYCODE_LS | MZ_KEYPRESS);
+                mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+                mz_key_queue_put(MZ_KEYCODE_KANA);
+                mz_key_queue_put(MZ_KEYCODE_LS);
+              }
+              else
+              {
+                // [英数]/[カナ] 独立の場合、カナキーをキュー
+                mz_key_queue_put(MZ_KEYCODE_KANA | MZ_KEYPRESS);
+                mz_key_queue_put(MZ_KEYCODE_KANA);
+              }
+              // go to next key
+              continue;
+            }
+            // GRPH  mode on
+            else if ((MZ_KEYCODE_GRPH != 0) && fis_grph)
+            {
+              mz_kb_mode = MZ_KBMODE_GRPH;
+
+              if (NEED_ALPHA_GRPH)
+              {
+                // SA-1510(パッチ済み)の場合、[ALPHA][GRPH]の2キーを押す
+                mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+                mz_key_queue_put(MZ_KEYCODE_ALPHA);
+                mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+                mz_key_queue_put(MZ_KEYCODE_GRPH);
+              }
+              else
+              {
+                // [GRPH]キーをキュー
+                mz_key_queue_put(MZ_KEYCODE_GRPH | MZ_KEYPRESS);
+                mz_key_queue_put(MZ_KEYCODE_GRPH);
+              }
+
+              // go to next key
+              continue;
+            }
+            // ALPHA mode on
+            else if (fis_caps && !fis_shift && !fis_alt)
+            {
+              mz_kb_mode = MZ_KBMODE_ALPHA;
+
+              // [英数] キーをキュー
+              mz_key_queue_put(MZ_KEYCODE_ALPHA | MZ_KEYPRESS);
+              mz_key_queue_put(MZ_KEYCODE_ALPHA);
+              // go to next key
+              continue;
+            }
+          // -------------------------------------------------------------------
+
+          // キーエンコード:
+          // -------------------------------------------------------------------
+            // GRPH が無い場合、ALTでGRPH代わりとする
+            if (MZ_KEYCODE_GRPH == 0)
+            {
+              if (fis_alt)
+              {
+                syx = KEYCODE2SYX[fkeycode][MZ_KBMODE_GRPH];
+              }
+              else
+              {
+                syx = KEYCODE2SYX[fkeycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && fis_shift) ? 1 : 0)];
+              }
+            }
+            else
+            {
+              syx = KEYCODE2SYX[fkeycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && fis_shift) ? 1 : 0)];
+            }
+
+            // Check CTRL-C / SHIFT-CTRL-C
+            // MZ-700J など、S-BASIC で CTRL-C (=ひらがな入力) など意味を持っている可能性があるため、CTRLキーを持つ機種でのこの処理は止める
+            if (MZ_KEYCODE_CTRL == 0 && fis_ctrl && fis_c)
+            {
+              // Queue [SHIFT] + [BREAK] key pressed
+              syx = MZ_KEYCODE_BREAK | MZ_SHIFT;
+              fis_ctrl = 0;
+            }
+          // -------------------------------------------------------------------
+          
+          // キー押しエミュレーション (syx != 0)
+          // -------------------------------------------------------------------
+            if (syx)
+            {
+              // コントロールキー
+              if (MZ_KEYCODE_CTRL != 0 && (fis_ctrl != mz_last_ctrl_state))
+              {
+                mz_last_ctrl_state = fis_ctrl;
+                mz_key_queue_put(MZ_KEYCODE_CTRL | (fis_ctrl ? MZ_KEYPRESS : 0));
+              }
+              bool sft = (syx & MZ_SHIFT);
+              syx = MZ_BARE_YX(syx);			// bare code
+              mz_last_shift_state = sft;
+              mz_last_lshift_state = false;
+              mz_last_rshift_state = false;
+              // press-release emulation
+              if (sft) mz_key_queue_put(MZ_KEYCODE_LS | MZ_KEYPRESS);	// SHIFT
+              mz_key_queue_put(syx | MZ_KEYPRESS);			// press
+              mz_key_queue_put(syx);					// release
+              if (sft) mz_key_queue_put(MZ_KEYCODE_LS);			// SHIFT
+            }
+          // -------------------------------------------------------------------
+          }	// go to next key
+          // 最後にコントロールキーの辻褄を合わせる
+          if (MZ_KEYCODE_CTRL != 0 && mz_last_ctrl_state)
+          {
+            mz_last_ctrl_state = 0;
+            mz_key_queue_put(MZ_KEYCODE_CTRL);
+          }
+          continue;
+        }
+        // ] =============================================================
+        else
+        {
+// 押されたキーをエンコード:
+// -------------------------------------------------------------------
+          uint16_t syx;
+          // GRPH が無い場合、ALTでGRPH代わりとする
+          if (MZ_KEYCODE_GRPH == 0)
+          {
+            if (is_alt)
+            {
+              syx = KEYCODE2SYX[keycode][MZ_KBMODE_GRPH];
+            }
+            else
+            {
+              syx = KEYCODE2SYX[keycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && is_shift) ? 1 : 0)];
+            }
+          }
+          else
+          {
+            syx = KEYCODE2SYX[keycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && is_shift) ? 1 : 0)];
+          }
+
+          // Check CTRL-C / SHIFT-CTRL-C
+          // MZ-700J など、S-BASIC で CTRL-C (=ひらがな入力) など意味を持っている可能性があるため、CTRLキーを持つ機種でのこの処理は止める
+          if (mz_kb_mode != MZ_KBMODE_RAW && MZ_KEYCODE_CTRL == 0 && is_ctrl && is_c)
+          {
+            // Queue [SHIFT] + [BREAK] key pressed
+            syx = MZ_KEYCODE_BREAK | MZ_SHIFT;
+          }
+// -------------------------------------------------------------------
+        // キー押しエミュレーション (syx != 0)
+        // -------------------------------------------------------------------
+          if (syx)
+          {
+            if (mz_kb_mode == MZ_KBMODE_RAW)
+            {
+              // simply queue bare key press
+              syx = MZ_BARE_YX(syx);		// bare code
+              if (syx) mz_key_queue_put(syx | MZ_KEYPRESS);
+            }
+            else
+            {
+              if (syx & MZ_SHIFT)
+              {
+                mz_last_shift_state = true;
+                // First, queue only SHIFT
+                mz_key_queue_put(MZ_KEYCODE_LS | MZ_KEYPRESS);
+                // Clear SHIFT bit and queue the bare key press
+                syx = MZ_BARE_YX(syx);
+              }
+              else
+              {
+                mz_last_shift_state = false;
+              }
+              // queue bare key press
+              mz_key_queue_put(syx | MZ_KEYPRESS);
+            }
+          }
+        // -------------------------------------------------------------------
+        }
+      }
+    }
+  }
+
+// キーリリース処理:
+// -------------------------------------------------------------------
+  // Handle released key
+  bool       pis_shift  = prev_report.modifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT);
+  bool const pis_ctrl   = prev_report.modifier & (KEYBOARD_MODIFIER_LEFTCTRL | KEYBOARD_MODIFIER_RIGHTCTRL);
+  bool const pis_alt    = prev_report.modifier & (KEYBOARD_MODIFIER_LEFTALT  | KEYBOARD_MODIFIER_RIGHTALT);
+
+  for(uint8_t i=0; i<6; i++)
+  {
+    uint8_t keycode = prev_report.keycode[i];
+    bool const pis_c = (keycode == C_KEY_CODE);
+
+    if ( keycode )
+    {
+      if (find_key_in_report(report, keycode) && (mz_kb_mode == MZ_KBMODE_RAW || prev_report.modifier == report->modifier))
+      {
+        // exist in current report means the previous key is still holding
+        // kaokun: however, modifier may be changed, e.g. the following sequence:
+        // [Press Shift] - [Press a] - [Release Shift] - [release a]
+        // we have to release the modifier-changed key other than in RAW mode.
+      }
+      else
+      {
+        // not existed in current report means the previous key is released, or the modifier changed
+
+        // remap the key code for Colemak layout
+        #ifdef KEYBOARD_COLEMAK
+        uint8_t colemak_key_code = colemak[keycode];
+        if (colemak_key_code != 0) keycode = colemak_key_code;
+        #endif
+
+// キーエンコード:
+// -------------------------------------------------------------------
+        uint16_t syx;
+        // GRPH が無い場合、ALTでGRPH代わりとする
+        if (MZ_KEYCODE_GRPH == 0)
+        {
+          if (pis_alt)
+          {
+            syx = KEYCODE2SYX[keycode][MZ_KBMODE_GRPH];
+          }
+          else
+          {
+            syx = KEYCODE2SYX[keycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && pis_shift) ? 1 : 0)];
+          }
+        }
+        else
+        {
+          syx = KEYCODE2SYX[keycode][mz_kb_mode + ((mz_kb_mode != MZ_KBMODE_RAW && pis_shift) ? 1 : 0)];
+        }
+
+        // Check CTRL-C / SHIFT-CTRL-C
+        // MZ-700J など、S-BASIC で CTRL-C (=ひらがな入力) など意味を持っている可能性があるため、CTRLキーを持つ機種でのこの処理は止める
+        if (mz_kb_mode != MZ_KBMODE_RAW && MZ_KEYCODE_CTRL == 0 && pis_ctrl && pis_c)
+        {
+          // Queue [SHIFT] + [BREAK] key released
+          syx = MZ_KEYCODE_BREAK | MZ_SHIFT;
+        }
+// -------------------------------------------------------------------
+      // キー離しエミュレーション (syx != 0)
+      // -------------------------------------------------------------------
+        if (syx)
+        {
+          if (mz_kb_mode == MZ_KBMODE_RAW)
+          {
+            // simply queue bare key release
+            syx = MZ_BARE_YX(syx);	// bare code
+            if (syx) mz_key_queue_put(syx);
+          }
+          else
+          {
+            // First, queue only bare code
+            mz_key_queue_put(syx & (uint16_t)~MZ_SHIFT);
+            if (syx & MZ_SHIFT)
+            {
+              // Then release SHIFT
+              mz_key_queue_put(MZ_KEYCODE_LS);
+              mz_last_shift_state = false;
+            }
+          }
+        }
+      // -------------------------------------------------------------------
+      }
+    }
+  }
+
+  // Change LED
+  leds = 0;
+  if (mz_kb_mode == MZ_KBMODE_KANA)
+  {
+    leds = leds | KEYBOARD_LED_KANA | KEYBOARD_LED_NUMLOCK;
+    blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_KANA;
+  }
+  if (mz_kb_mode == MZ_KBMODE_RAW)
+  {
+    leds = leds | KEYBOARD_LED_SCROLLLOCK | KEYBOARD_LED_NUMLOCK;
+    blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_RAW;
+  }
+
+  if (flush) tud_cdc_write_flush();
+  prev_report = *report;
+}
+
+// send mouse report to usb device CDC
+static void process_mouse_report(uint8_t dev_addr, hid_mouse_report_t const * report)
+{
+  //------------- button state  -------------//
+  //uint8_t button_changed_mask = report->buttons ^ prev_report.buttons;
+  char l = report->buttons & MOUSE_BUTTON_LEFT   ? 'L' : '-';
+  char m = report->buttons & MOUSE_BUTTON_MIDDLE ? 'M' : '-';
+  char r = report->buttons & MOUSE_BUTTON_RIGHT  ? 'R' : '-';
+
+  char tempbuf[32];
+  int count = sprintf(tempbuf, "[%u] %c%c%c %d %d %d\r\n", dev_addr, l, m, r, report->x, report->y, report->wheel);
+
+  tud_cdc_write(tempbuf, (uint32_t) count);
+  tud_cdc_write_flush();
+}
+
+// Invoked when received report from device via interrupt endpoint
+void tuh_hid_report_received_cb(uint8_t dev_addr, uint8_t instance, uint8_t const* report, uint16_t len)
+{
+  (void) len;
+  uint8_t const itf_protocol = tuh_hid_interface_protocol(dev_addr, instance);
+
+  switch(itf_protocol)
+  {
+    case HID_ITF_PROTOCOL_KEYBOARD:
+      process_kbd_report(dev_addr, (hid_keyboard_report_t const*) report );
+      keybd_dev_addr = dev_addr;
+      keybd_instance = instance;
+    break;
+
+    case HID_ITF_PROTOCOL_MOUSE:
+      process_mouse_report(dev_addr, (hid_mouse_report_t const*) report );
+    break;
+
+    default: break;
+  }
+
+  // continue to request to receive report
+  if ( !tuh_hid_receive_report(dev_addr, instance) )
+  {
+    tud_cdc_write_str("Error: cannot request report\r\n");
+  }
+}
+
+//--------------------------------------------------------------------+
+// Blinking Task
+//--------------------------------------------------------------------+
+void led_blinking_task(void)
+{
+  static uint32_t start_ms = 0;
+  static bool led_state = false;
+
+  // Blink every interval ms
+  if ( board_millis() - start_ms < blink_interval_ms) return; // not enough time
+  start_ms += blink_interval_ms;
+
+  board_led_write(led_state);
+  led_state = 1 - led_state; // toggle
+}
+
+// HID Keyboard LED
+void keyboard_led_blinking_task(void)
+{
+  static uint32_t start_ms = 0;
+  const bool is_numlock = leds & KEYBOARD_LED_NUMLOCK;
+  static bool led_state = false;
+  static uint8_t my_leds;
+#ifdef HID_LED_DEBUG
+  char tempbuf[256];
+  int count;
+#endif
+
+  if (keybd_dev_addr == 0xFFu) return;
+
+  my_leds = leds;
+  if (is_numlock && (blink_numlock_led_interval_ms != BLINK_NUMLOCK_LED_NONE))
+  {
+    if (board_millis() - start_ms >= blink_numlock_led_interval_ms)
+    {
+      // Blink every interval ms
+      start_ms = board_millis();
+      led_state = 1 - led_state; // toggle
+    }
+    if (led_state)
+    {
+      my_leds = (uint8_t)(my_leds | KEYBOARD_LED_NUMLOCK);
+    }
+    else
+    {
+      my_leds = (uint8_t)(my_leds & ~KEYBOARD_LED_NUMLOCK);
+    }
+  }
+  if (prev_leds != my_leds)
+  {
+    if (!tuh_hid_set_report(keybd_dev_addr, keybd_instance, 0, HID_REPORT_TYPE_OUTPUT, &my_leds, sizeof(my_leds)))
+    {
+#ifdef HID_LED_DEBUG
+      count = sprintf(tempbuf, "HID KB LED %02x fail\r\n", my_leds);
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+#endif
+      prev_leds = 0xFFu;	// for retry
+    }
+    else
+    {
+#ifdef HID_LED_DEBUG
+      count = sprintf(tempbuf, "HID KB LED %02x Success\r\n", my_leds);
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+#endif
+      prev_leds = my_leds;
+    }
+  }
+}
+
+//--------------------------------------------------------------------+
+// MZ key sending task
+//--------------------------------------------------------------------+
+void mz_sendkey_task(void)
+{
+  switch(mz_key_sending_task_state)
+  {
+    char tempbuf[256];
+    int count;
+
+    case MZ_TASK_STATE_POWERON:
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_POWERON_WAIT;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_POWERON_WAIT:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_POWERON_WAIT_MS) break;
+      count = sprintf(tempbuf, "MZ: asserting SYSTEM RESET \r\n");
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_RESET;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_RESET:
+      // release keys and queue clear
+      mz_switch_all_relase();
+      // Assert RESET on MZ
+      mz_switch_ctrl_alt_del();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_RESET_ASSERTED;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_RESET_ASSERTED:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_RESET_MS) break;
+      // Deassert RESET on MZ and SW array
+      mz_switch_deassert_array_reset();
+      mz_switch_deassert_ctrl_alt_del();
+      // init queue
+      mz_host_queue_init();
+      // init mode
+      mz_mode_init();
+      // init LED
+      kb_led_init();
+      // init fkey def mode
+      fkey_def_mode = false;
+      count = sprintf(tempbuf, "MZ: Switch array ready\r\nsystem mode=%0d\r\n", system_mode);
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_GETKEY;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_ARRAY_RESET_ASSERTED:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_RESET_MS) break;
+      // Deassert RESET on SW array
+      mz_switch_deassert_array_reset();
+      // init queue
+      mz_host_queue_init();
+      // init fkey def mode
+      fkey_def_mode = false;
+      count = sprintf(tempbuf, "MZ: Switch array ready\r\nsystem mode=%0d\r\n", system_mode);
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_GETKEY;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_GETKEY:
+      if (!mz_key_queue_num_data()) break;			// queue empty
+  
+      uint16_t syx  = mz_key_queue_peek();			// Peek queue
+      uint16_t bare_yx = MZ_BARE_YX(syx);
+      bool onoff    = MZ_ISKEYPRESS(syx);
+      uint8_t x     = MZ_X(syx);
+      uint8_t y     = MZ_Y(syx);
+
+      if (!syx) {
+        // current syx is processed
+        mz_key_queue_drop();
+        break;
+      }
+
+      if (onoff && syx == last_on_syx)
+      {
+        // the same key is pressed. need extra delay
+        mz_switch_start_waiting_between_the_same_key();
+        break;
+      }
+
+      // current syx is being processed
+      mz_key_queue_drop();
+
+      // avoid SHIFT bounce, ON->OFF->ON
+      if ((!onoff) && (bare_yx == MZ_KEYCODE_LS || bare_yx == MZ_KEYCODE_RS) && mz_key_queue_num_data())
+      {
+        // Current: Key off, the key is SHIFT and there is next data
+        uint16_t next_syx = mz_key_queue_peek();	// Peek next data
+        uint16_t next_bare_yx  = MZ_BARE_YX(next_syx);
+        bool next_onoff = MZ_ISKEYPRESS(next_syx);
+        if (next_onoff && (next_bare_yx == MZ_KEYCODE_LS || next_bare_yx == MZ_KEYCODE_RS))
+        {
+          // Next key: key on, the key is SHIFT
+          mz_key_queue_drop();	// drop the next key
+          // and no process for current SHIFT OFF
+          break;
+        }
+      }
+#ifdef MZ_KEYCODE_DEBUG
+      count = sprintf(tempbuf, "MZ: Array (%d, %d) = %s\r\n", x, y, (onoff) ? "ON" : "OFF");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+#endif
+      // Switch array control
+      mz_switch_set(x, y, onoff);
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_KEY_STROBE_ASSERTED;
+      mz_task_start_ms = board_millis();
+      if (onoff && !(bare_yx == MZ_KEYCODE_LS || bare_yx == MZ_KEYCODE_RS))
+      {
+        // save the last pressed key other than [SHIFT]
+        last_on_syx = syx;
+      }
+
+      // OFF->OFF->OFF->... does not need debounce time
+      while ((!onoff) && mz_key_queue_num_data())
+      {
+        // Current: Key off and there is next data
+        uint16_t next_syx = mz_key_queue_peek();	// Peek next data
+        onoff = MZ_ISKEYPRESS(next_syx);
+        if (!onoff)
+        {
+          x = MZ_X(next_syx);
+          y = MZ_Y(next_syx);
+#ifdef MZ_KEYCODE_DEBUG
+          count = sprintf(tempbuf, "MZ: Array (%d, %d) = %s\r\n", x, y, (onoff) ? "ON" : "OFF");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          tud_cdc_write_flush();
+#endif
+          // Release the next key also
+          mz_switch_set(x, y, onoff);
+          // Change task state
+          mz_key_sending_task_state = MZ_TASK_STATE_KEY_STROBE_ASSERTED;
+          mz_task_start_ms = board_millis();
+          // current syx is being processed
+          mz_key_queue_drop();
+        }
+      }
+      break;
+
+    case MZ_TASK_STATE_KEY_STROBE_ASSERTED:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_STROBE_MS) break;
+      mz_switch_deassert_strobe();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_KEY_STROBE_DEASSERTED;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_KEY_STROBE_DEASSERTED:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_STROBE_MS) break;
+      mz_switch_start_waiting_debounce();
+      break;
+
+    case MZ_TASK_STATE_KEY_WAIT_DEBOUNCE:
+      // RAWモードの時はdebounceなし (ゲームの応答性確保のため)
+      if (mz_kb_mode != MZ_KBMODE_RAW && num_keyscan_called < n_keyscans_press_debounce)
+      {
+        if (board_millis() - mz_task_start_ms < MZ_KBIF_DEBOUNCE_MS) break;
+      }
+      mz_switch_get_next_key();
+      break;
+
+    case MZ_TASK_STATE_KEY_WAIT_RELEASE_DEBOUNCE:
+      // RAWモードの時はdebounceなし (ゲームの応答性確保のため)
+      if (mz_kb_mode != MZ_KBMODE_RAW && num_keyscan_called < n_keyscans_release_debounce)
+      {
+        if (board_millis() - mz_task_start_ms < MZ_KBIF_RELEASE_DEBOUNCE_MS) break;
+      }
+      mz_switch_get_next_key();
+      break;
+
+    case MZ_TASK_STATE_CTRL_ALT_DEL:
+      count = sprintf(tempbuf, "MZ: Asserting RESET on MZ\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // release keys and queue clear
+      mz_switch_all_relase();
+      // Assert RESET on MZ
+      mz_switch_ctrl_alt_del();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_DEL_ASSERTED;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_CTRL_ALT_DEL_ASSERTED:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_CTRL_ALT_DEL_MS) break;
+      // Deassert RESET on MZ and SW array
+      mz_switch_deassert_array_reset();
+      mz_switch_deassert_ctrl_alt_del();
+      // init queue
+      mz_host_queue_init();
+      // init mode
+      mz_mode_init();
+      // init LED
+      kb_led_init();
+      // init fkey def mode
+      fkey_def_mode = false;
+      count = sprintf(tempbuf, "MZ: Deassert RESET on MZ\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_GETKEY;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_CTRL_ALT_END:
+      count = sprintf(tempbuf, "MZ: Asserting RESET on array\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      mz_switch_ctrl_alt_end();
+      last_on_syx = 0;
+      break;
+
+    case MZ_TASK_STATE_CTRL_ALT_END_ASSERTED:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_CTRL_ALT_END_MS) break;
+      // Dessert Reset of switch array IC
+      mz_switch_deassert_array_reset();
+      count = sprintf(tempbuf, "MZ: Deassert RESET on array IC\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Assert CTRL on MZ keyboard
+      syx = MZ_KEYCODE_CTRL;
+      mz_switch_set(MZ_X(syx), MZ_Y(syx), true);
+      count = sprintf(tempbuf, "MZ: Assert CTRL on MZ\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_END_ASSERTED2;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_CTRL_ALT_END_ASSERTED2:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_STROBE_MS) break;
+      mz_switch_deassert_strobe();
+      // set ROM A15-A12
+      mz_set_ROM_addr();
+      // Assert RESET on MZ
+      gpio_put(MZ_PIO_MZ_RESET_PIN, 1);
+      count = sprintf(tempbuf, "MZ: Assert RESET on MZ\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_END_ASSERTED3;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_CTRL_ALT_END_ASSERTED3:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_CTRL_ALT_END_MS2) break;
+      // Deassert RESET on MZ, still asserting CTRL
+      gpio_put(MZ_PIO_MZ_RESET_PIN, 0);
+      count = sprintf(tempbuf, "MZ: Deassert RESET on MZ\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_CTRL_ALT_END_ASSERTED4;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_CTRL_ALT_END_ASSERTED4:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_CTRL_ALT_END_MS3) break;
+      // Deassert CTRL on MZ keyboard
+      syx = MZ_KEYCODE_CTRL;
+      mz_switch_set(MZ_X(syx), MZ_Y(syx), false);
+      count = sprintf(tempbuf, "MZ: Deassert CTRL on MZ\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_GETKEY;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_WAITING_BETWEEN_THE_SAME_KEY:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_WAIT_BETWEEN_THE_SAME_KEY_MS) break;
+      mz_switch_get_next_key();
+      last_on_syx = 0;
+      break;
+
+    case MZ_TASK_STATE_CYCLE_VBUS:
+      // DROP VBUSEN
+      gpio_put(PIO_USB_VBUSEN_PIN, (1 - PIO_USB_VBUSEN_STATE));
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_CYCLE_VBUS_WAITING;
+      mz_task_start_ms = board_millis();
+      break;
+
+    case MZ_TASK_STATE_CYCLE_VBUS_WAITING:
+      if (board_millis() - mz_task_start_ms < MZ_KBIF_VBUS_CYCLE_MS)	break;
+      // Enable VBUSEN
+      gpio_put(PIO_USB_VBUSEN_PIN, PIO_USB_VBUSEN_STATE);
+      // Change task state
+      mz_key_sending_task_state = MZ_TASK_STATE_RESET;
+      break;
+
+    default:
+      mz_key_sending_task_state = MZ_TASK_STATE_RESET;
+      break;
+  }
+}
+
+//
+// host to MZ
+//
+void mz_host2mz_task(void)
+{
+  char buf[2];
+  buf[1] = 0;
+  char tempbuf[256];
+  int count;
+
+  while (mz_host_queue_num_data())
+  {
+    buf[0] = mz_host_queue_peek();
+    count = sprintf(tempbuf, "HOSTQ:%02X\r\n", buf[0]);
+    tud_cdc_write(tempbuf, (uint32_t) count);
+    tud_cdc_write_flush();
+    mz_host_queue_drop();
+    mz_queue_string_as_key(buf);
+  }
+}
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/tusb_config.h pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/tusb_config.h
--- pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/tusb_config.h	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/tusb_config.h	2024-05-24 13:30:10.282213417 +0900
@@ -0,0 +1,143 @@
+/*
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2019 Ha Thach (tinyusb.org)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ */
+
+#ifndef _TUSB_CONFIG_H_
+#define _TUSB_CONFIG_H_
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+//--------------------------------------------------------------------+
+// Board Specific Configuration
+//--------------------------------------------------------------------+
+
+// RHPort number used for device can be defined by board.mk, default to port 0
+#ifndef BOARD_TUD_RHPORT
+#define BOARD_TUD_RHPORT      0
+#endif
+
+// RHPort max operational speed can defined by board.mk
+#ifndef BOARD_TUD_MAX_SPEED
+#define BOARD_TUD_MAX_SPEED   OPT_MODE_DEFAULT_SPEED
+#endif
+
+// RHPort number used for host can be defined by board.mk, default to port 1
+#ifndef BOARD_TUH_RHPORT
+#define BOARD_TUH_RHPORT      1
+#endif
+
+// RHPort max operational speed can defined by board.mk
+#ifndef BOARD_TUH_MAX_SPEED
+#define BOARD_TUH_MAX_SPEED   OPT_MODE_DEFAULT_SPEED
+#endif
+
+//--------------------------------------------------------------------
+// COMMON CONFIGURATION
+//--------------------------------------------------------------------
+
+// defined by compiler flags for flexibility
+#ifndef CFG_TUSB_MCU
+#error CFG_TUSB_MCU must be defined
+#endif
+
+#ifndef CFG_TUSB_OS
+#define CFG_TUSB_OS           OPT_OS_NONE
+#endif
+
+#ifndef CFG_TUSB_DEBUG
+#define CFG_TUSB_DEBUG        0
+#endif
+
+// Enable Device stack, Default is max speed that hardware controller could support with on-chip PHY
+#define CFG_TUD_ENABLED       1
+#define CFG_TUD_MAX_SPEED     BOARD_TUD_MAX_SPEED
+
+// Enable Host stack, Default is max speed that hardware controller could support with on-chip PHY
+#define CFG_TUH_ENABLED       1
+#define CFG_TUH_MAX_SPEED     BOARD_TUH_MAX_SPEED
+
+#if CFG_TUSB_MCU == OPT_MCU_RP2040
+// Use pico-pio-usb as host controller for raspberry rp2040
+#define CFG_TUH_RPI_PIO_USB   1
+#endif
+
+
+// CFG_TUSB_DEBUG is defined by compiler in DEBUG build
+// #define CFG_TUSB_DEBUG           0
+
+/* USB DMA on some MCUs can only access a specific SRAM region with restriction on alignment.
+ * Tinyusb use follows macros to declare transferring memory so that they can be put
+ * into those specific section.
+ * e.g
+ * - CFG_TUSB_MEM SECTION : __attribute__ (( section(".usb_ram") ))
+ * - CFG_TUSB_MEM_ALIGN   : __attribute__ ((aligned(4)))
+ */
+#ifndef CFG_TUSB_MEM_SECTION
+#define CFG_TUSB_MEM_SECTION
+#endif
+
+#ifndef CFG_TUSB_MEM_ALIGN
+#define CFG_TUSB_MEM_ALIGN        __attribute__ ((aligned(4)))
+#endif
+
+//--------------------------------------------------------------------
+// DEVICE CONFIGURATION
+//--------------------------------------------------------------------
+
+#ifndef CFG_TUD_ENDPOINT0_SIZE
+#define CFG_TUD_ENDPOINT0_SIZE    64
+#endif
+
+//------------- CLASS -------------//
+#define CFG_TUD_CDC              1
+
+// CDC FIFO size of TX and RX
+#define CFG_TUD_CDC_RX_BUFSIZE   (TUD_OPT_HIGH_SPEED ? 512 : 64)
+#define CFG_TUD_CDC_TX_BUFSIZE   (TUD_OPT_HIGH_SPEED ? 512 : 64)
+
+// CDC Endpoint transfer buffer size, more is faster
+#define CFG_TUD_CDC_EP_BUFSIZE   (TUD_OPT_HIGH_SPEED ? 512 : 64)
+
+//--------------------------------------------------------------------
+// HOST CONFIGURATION
+//--------------------------------------------------------------------
+
+// Size of buffer to hold descriptors and other data used for enumeration
+#define CFG_TUH_ENUMERATION_BUFSIZE 256
+
+#define CFG_TUH_HUB                 1
+// max device support (excluding hub device)
+#define CFG_TUH_DEVICE_MAX          (CFG_TUH_HUB ? 4 : 1) // hub typically has 4 ports
+
+#define CFG_TUH_HID                  4
+#define CFG_TUH_HID_EPIN_BUFSIZE    64
+#define CFG_TUH_HID_EPOUT_BUFSIZE   64
+
+#ifdef __cplusplus
+ }
+#endif
+
+#endif /* _TUSB_CONFIG_H_ */
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/usb_descriptors.c pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/usb_descriptors.c
--- pico.orig/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/usb_descriptors.c	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/mz/host_hid_to_device_cdc_mz/src/usb_descriptors.c	2024-05-24 13:30:10.282213417 +0900
@@ -0,0 +1,265 @@
+/* 
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2019 Ha Thach (tinyusb.org)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ */
+
+#include "tusb.h"
+
+/* A combination of interfaces must have a unique product id, since PC will save device driver after the first plug.
+ * Same VID/PID with different interface e.g MSC (first), then CDC (later) will possibly cause system error on PC.
+ *
+ * Auto ProductID layout's Bitmap:
+ *   [MSB]         HID | MSC | CDC          [LSB]
+ */
+#define _PID_MAP(itf, n)  ( (CFG_TUD_##itf) << (n) )
+#define USB_PID           (0x4000 | _PID_MAP(CDC, 0) | _PID_MAP(MSC, 1) | _PID_MAP(HID, 2) | \
+                           _PID_MAP(MIDI, 3) | _PID_MAP(VENDOR, 4) )
+
+#define USB_VID   0xCafe
+#define USB_BCD   0x0200
+
+//--------------------------------------------------------------------+
+// Device Descriptors
+//--------------------------------------------------------------------+
+tusb_desc_device_t const desc_device =
+{
+  .bLength            = sizeof(tusb_desc_device_t),
+  .bDescriptorType    = TUSB_DESC_DEVICE,
+  .bcdUSB             = USB_BCD,
+
+  // Use Interface Association Descriptor (IAD) for CDC
+  // As required by USB Specs IAD's subclass must be common class (2) and protocol must be IAD (1)
+  .bDeviceClass       = TUSB_CLASS_MISC,
+  .bDeviceSubClass    = MISC_SUBCLASS_COMMON,
+  .bDeviceProtocol    = MISC_PROTOCOL_IAD,
+
+  .bMaxPacketSize0    = CFG_TUD_ENDPOINT0_SIZE,
+
+  .idVendor           = USB_VID,
+  .idProduct          = USB_PID,
+  .bcdDevice          = 0x0100,
+
+  .iManufacturer      = 0x01,
+  .iProduct           = 0x02,
+  .iSerialNumber      = 0x03,
+
+  .bNumConfigurations = 0x01
+};
+
+// Invoked when received GET DEVICE DESCRIPTOR
+// Application return pointer to descriptor
+uint8_t const * tud_descriptor_device_cb(void)
+{
+  return (uint8_t const *) &desc_device;
+}
+
+//--------------------------------------------------------------------+
+// Configuration Descriptor
+//--------------------------------------------------------------------+
+
+enum
+{
+  ITF_NUM_CDC = 0,
+  ITF_NUM_CDC_DATA,
+  ITF_NUM_TOTAL
+};
+
+#if CFG_TUSB_MCU == OPT_MCU_LPC175X_6X || CFG_TUSB_MCU == OPT_MCU_LPC177X_8X || CFG_TUSB_MCU == OPT_MCU_LPC40XX
+  // LPC 17xx and 40xx endpoint type (bulk/interrupt/iso) are fixed by its number
+  // 0 control, 1 In, 2 Bulk, 3 Iso, 4 In, 5 Bulk etc ...
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x82
+
+#elif CFG_TUSB_MCU == OPT_MCU_SAMG  || CFG_TUSB_MCU ==  OPT_MCU_SAMX7X
+  // SAMG & SAME70 don't support a same endpoint number with different direction IN and OUT
+  //    e.g EP1 OUT & EP1 IN cannot exist together
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x83
+
+#elif CFG_TUSB_MCU == OPT_MCU_CXD56
+  // CXD56 doesn't support a same endpoint number with different direction IN and OUT
+  //    e.g EP1 OUT & EP1 IN cannot exist together
+  // CXD56 USB driver has fixed endpoint type (bulk/interrupt/iso) and direction (IN/OUT) by its number
+  // 0 control (IN/OUT), 1 Bulk (IN), 2 Bulk (OUT), 3 In (IN), 4 Bulk (IN), 5 Bulk (OUT), 6 In (IN)
+  #define EPNUM_CDC_NOTIF   0x83
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x81
+
+#elif CFG_TUSB_MCU == OPT_MCU_FT90X || CFG_TUSB_MCU == OPT_MCU_FT93X
+  // FT9XX doesn't support a same endpoint number with different direction IN and OUT
+  //    e.g EP1 OUT & EP1 IN cannot exist together
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x83
+
+#else
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x82
+
+#endif
+
+#define CONFIG_TOTAL_LEN    (TUD_CONFIG_DESC_LEN + TUD_CDC_DESC_LEN)
+
+// full speed configuration
+uint8_t const desc_fs_configuration[] =
+{
+  // Config number, interface count, string index, total length, attribute, power in mA
+  TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_TOTAL_LEN, 0x00, 100),
+
+  // Interface number, string index, EP notification address and size, EP data address (out, in) and size.
+  TUD_CDC_DESCRIPTOR(ITF_NUM_CDC, 4, EPNUM_CDC_NOTIF, 8, EPNUM_CDC_OUT, EPNUM_CDC_IN, 64),
+};
+
+#if TUD_OPT_HIGH_SPEED
+// Per USB specs: high speed capable device must report device_qualifier and other_speed_configuration
+
+// high speed configuration
+uint8_t const desc_hs_configuration[] =
+{
+  // Config number, interface count, string index, total length, attribute, power in mA
+  TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_TOTAL_LEN, 0x00, 100),
+
+  // Interface number, string index, EP notification address and size, EP data address (out, in) and size.
+  TUD_CDC_DESCRIPTOR(ITF_NUM_CDC, 4, EPNUM_CDC_NOTIF, 8, EPNUM_CDC_OUT, EPNUM_CDC_IN, 512),
+};
+
+// other speed configuration
+uint8_t desc_other_speed_config[CONFIG_TOTAL_LEN];
+
+// device qualifier is mostly similar to device descriptor since we don't change configuration based on speed
+tusb_desc_device_qualifier_t const desc_device_qualifier =
+{
+  .bLength            = sizeof(tusb_desc_device_qualifier_t),
+  .bDescriptorType    = TUSB_DESC_DEVICE_QUALIFIER,
+  .bcdUSB             = USB_BCD,
+
+  .bDeviceClass       = TUSB_CLASS_MISC,
+  .bDeviceSubClass    = MISC_SUBCLASS_COMMON,
+  .bDeviceProtocol    = MISC_PROTOCOL_IAD,
+
+  .bMaxPacketSize0    = CFG_TUD_ENDPOINT0_SIZE,
+  .bNumConfigurations = 0x01,
+  .bReserved          = 0x00
+};
+
+// Invoked when received GET DEVICE QUALIFIER DESCRIPTOR request
+// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete.
+// device_qualifier descriptor describes information about a high-speed capable device that would
+// change if the device were operating at the other speed. If not highspeed capable stall this request.
+uint8_t const* tud_descriptor_device_qualifier_cb(void)
+{
+  return (uint8_t const*) &desc_device_qualifier;
+}
+
+// Invoked when received GET OTHER SEED CONFIGURATION DESCRIPTOR request
+// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete
+// Configuration descriptor in the other speed e.g if high speed then this is for full speed and vice versa
+uint8_t const* tud_descriptor_other_speed_configuration_cb(uint8_t index)
+{
+  (void) index; // for multiple configurations
+
+  // if link speed is high return fullspeed config, and vice versa
+  // Note: the descriptor type is OHER_SPEED_CONFIG instead of CONFIG
+  memcpy(desc_other_speed_config,
+         (tud_speed_get() == TUSB_SPEED_HIGH) ? desc_fs_configuration : desc_hs_configuration,
+         CONFIG_TOTAL_LEN);
+
+  desc_other_speed_config[1] = TUSB_DESC_OTHER_SPEED_CONFIG;
+
+  return desc_other_speed_config;
+}
+
+#endif // highspeed
+
+
+// Invoked when received GET CONFIGURATION DESCRIPTOR
+// Application return pointer to descriptor
+// Descriptor contents must exist long enough for transfer to complete
+uint8_t const * tud_descriptor_configuration_cb(uint8_t index)
+{
+  (void) index; // for multiple configurations
+
+#if TUD_OPT_HIGH_SPEED
+  // Although we are highspeed, host may be fullspeed.
+  return (tud_speed_get() == TUSB_SPEED_HIGH) ?  desc_hs_configuration : desc_fs_configuration;
+#else
+  return desc_fs_configuration;
+#endif
+}
+
+//--------------------------------------------------------------------+
+// String Descriptors
+//--------------------------------------------------------------------+
+
+// array of pointer to string descriptors
+char const* string_desc_arr [] =
+{
+  (const char[]) { 0x09, 0x04 }, // 0: is supported language is English (0x0409)
+  "TinyUSB",                     // 1: Manufacturer
+  "TinyUSB Device",              // 2: Product
+  "123456789012",                // 3: Serials, should use chip ID
+  "TinyUSB CDC",                 // 4: CDC Interface
+};
+
+static uint16_t _desc_str[32];
+
+// Invoked when received GET STRING DESCRIPTOR request
+// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete
+uint16_t const* tud_descriptor_string_cb(uint8_t index, uint16_t langid)
+{
+  (void) langid;
+
+  uint8_t chr_count;
+
+  if ( index == 0)
+  {
+    memcpy(&_desc_str[1], string_desc_arr[0], 2);
+    chr_count = 1;
+  }else
+  {
+    // Note: the 0xEE index string is a Microsoft OS 1.0 Descriptors.
+    // https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/microsoft-defined-usb-descriptors
+
+    if ( !(index < sizeof(string_desc_arr)/sizeof(string_desc_arr[0])) ) return NULL;
+
+    const char* str = string_desc_arr[index];
+
+    // Cap at max char
+    chr_count = (uint8_t) strlen(str);
+    if ( chr_count > 31 ) chr_count = 31;
+
+    // Convert ASCII string into UTF-16
+    for(uint8_t i=0; i<chr_count; i++)
+    {
+      _desc_str[1+i] = str[i];
+    }
+  }
+
+  // first byte is length (including header), second byte is string type
+  _desc_str[0] = (uint16_t) ((TUSB_DESC_STRING << 8 ) | (2*chr_count + 2));
+
+  return _desc_str;
+}
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/pet/CMakeLists.txt pico/pico-sdk/lib/tinyusb/examples/pet/CMakeLists.txt
--- pico.orig/pico-sdk/lib/tinyusb/examples/pet/CMakeLists.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/pet/CMakeLists.txt	2024-05-24 13:30:10.282213417 +0900
@@ -0,0 +1,12 @@
+cmake_minimum_required(VERSION 3.5)
+
+include(${CMAKE_CURRENT_SOURCE_DIR}/../../hw/bsp/family_support.cmake)
+
+project(tinyusb_pet)
+family_initialize_project(tinyusb_pet ${CMAKE_CURRENT_LIST_DIR})
+if (FAMILY STREQUAL "rp2040" AND NOT TARGET tinyusb_pico_pio_usb)
+    message("Skipping dual host/device mode examples as Pico-PIO-USB is not available")
+else()
+    # family_add_subdirectory will filter what to actually add based on selected FAMILY
+    family_add_subdirectory(host_hid_to_device_cdc_pet)
+endif()
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/CMakeLists.txt pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/CMakeLists.txt
--- pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/CMakeLists.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/CMakeLists.txt	2024-05-24 13:30:10.282213417 +0900
@@ -0,0 +1,40 @@
+cmake_minimum_required(VERSION 3.5)
+
+include(${CMAKE_CURRENT_SOURCE_DIR}/../../../hw/bsp/family_support.cmake)
+
+# gets PROJECT name for the example (e.g. <BOARD>-<DIR_NAME>)
+family_get_project_name(PROJECT ${CMAKE_CURRENT_LIST_DIR})
+
+project(${PROJECT})
+
+# Checks this example is valid for the family and initializes the project
+family_initialize_project(${PROJECT} ${CMAKE_CURRENT_LIST_DIR})
+
+add_executable(${PROJECT})
+
+# Example source
+target_sources(${PROJECT} PUBLIC
+        ${CMAKE_CURRENT_SOURCE_DIR}/src/main.c
+        ${CMAKE_CURRENT_SOURCE_DIR}/src/usb_descriptors.c
+        )
+
+# Example include
+target_include_directories(${PROJECT} PUBLIC
+        ${CMAKE_CURRENT_SOURCE_DIR}/src
+        )
+
+# Configure compilation flags and libraries for the example... see the corresponding function
+# in hw/bsp/FAMILY/family.cmake for details.
+family_configure_dual_usb_example(${PROJECT})
+
+# due to warnings from Pico-PIO-USB
+target_compile_options(${PROJECT} PUBLIC
+        -Wno-error=shadow
+        -Wno-error=cast-align
+        -Wno-error=cast-qual
+        -Wno-error=redundant-decls
+        -Wno-error=sign-conversion
+        -Wno-error=conversion
+        -Wno-error=sign-compare
+        -Wno-error=unused-function
+        )
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/Makefile pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/Makefile
--- pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/Makefile	2024-05-24 13:30:10.282213417 +0900
@@ -0,0 +1,19 @@
+include ../../../tools/top.mk
+include ../../make.mk
+
+INC += \
+	src \
+	$(TOP)/hw \
+
+# Example source
+EXAMPLE_SOURCE += $(wildcard src/*.c)
+SRC_C += $(addprefix $(CURRENT_PATH)/, $(EXAMPLE_SOURCE))
+
+CFLAGS += -Wno-error=cast-align -Wno-error=null-dereference
+
+SRC_C += \
+	src/class/hid/hid_host.c \
+	src/host/hub.c \
+	src/host/usbh.c
+
+include ../../rules.mk
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/only.txt pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/only.txt
--- pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/only.txt	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/only.txt	2024-05-24 13:30:10.282213417 +0900
@@ -0,0 +1,3 @@
+board:mimxrt1060_evk
+board:mimxrt1064_evk
+mcu:RP2040
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/main.c pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/main.c
--- pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/main.c	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/main.c	2024-08-08 17:42:19.685037809 +0900
@@ -0,0 +1,2072 @@
+/* 
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2019 Ha Thach (tinyusb.org)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ */
+
+// This example runs both host and device concurrently. The USB host receive
+// reports from HID device and print it out over USB Device CDC interface.
+
+// for PET-2001N with PCG-6500
+#define PET2001N		1
+
+// Array switch debug
+#define PET_KEYCODE_DEBUG	1
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "bsp/board.h"
+#include "tusb.h"
+
+// GPIO for PET
+#include "pico/stdlib.h"
+#include "hardware/gpio.h"
+
+//--------------------------------------------------------------------+
+// MACRO CONSTANT TYPEDEF PROTYPES
+//--------------------------------------------------------------------+
+
+// uncomment if you are using colemak layout
+// #define KEYBOARD_COLEMAK
+
+#ifdef KEYBOARD_COLEMAK
+const uint8_t colemak[128] = {
+  0  ,  0,  0,  0,  0,  0,  0, 22,
+  9  , 23,  7,  0, 24, 17,  8, 12,
+  0  , 14, 28, 51,  0, 19, 21, 10,
+  15 ,  0,  0,  0, 13,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0, 18,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0,
+  0  ,  0,  0,  0,  0,  0,  0,  0
+};
+#endif
+
+static uint8_t const keycode2ascii[256][2] =  {
+    {0     , 0      }, /* 0x00 */ \
+    {0     , 0      }, /* 0x01 */ \
+    {0     , 0      }, /* 0x02 */ \
+    {0     , 0      }, /* 0x03 */ \
+    {'a'   , 'A'    }, /* 0x04 */ \
+    {'b'   , 'B'    }, /* 0x05 */ \
+    {'c'   , 'C'    }, /* 0x06 */ \
+    {'d'   , 'D'    }, /* 0x07 */ \
+    {'e'   , 'E'    }, /* 0x08 */ \
+    {'f'   , 'F'    }, /* 0x09 */ \
+    {'g'   , 'G'    }, /* 0x0a */ \
+    {'h'   , 'H'    }, /* 0x0b */ \
+    {'i'   , 'I'    }, /* 0x0c */ \
+    {'j'   , 'J'    }, /* 0x0d */ \
+    {'k'   , 'K'    }, /* 0x0e */ \
+    {'l'   , 'L'    }, /* 0x0f */ \
+    {'m'   , 'M'    }, /* 0x10 */ \
+    {'n'   , 'N'    }, /* 0x11 */ \
+    {'o'   , 'O'    }, /* 0x12 */ \
+    {'p'   , 'P'    }, /* 0x13 */ \
+    {'q'   , 'Q'    }, /* 0x14 */ \
+    {'r'   , 'R'    }, /* 0x15 */ \
+    {'s'   , 'S'    }, /* 0x16 */ \
+    {'t'   , 'T'    }, /* 0x17 */ \
+    {'u'   , 'U'    }, /* 0x18 */ \
+    {'v'   , 'V'    }, /* 0x19 */ \
+    {'w'   , 'W'    }, /* 0x1a */ \
+    {'x'   , 'X'    }, /* 0x1b */ \
+    {'y'   , 'Y'    }, /* 0x1c */ \
+    {'z'   , 'Z'    }, /* 0x1d */ \
+    {'1'   , '!'    }, /* 0x1e */ \
+    {'2'   , '"'    }, /* 0x1f */ \
+    {'3'   , '#'    }, /* 0x20 */ \
+    {'4'   , '$'    }, /* 0x21 */ \
+    {'5'   , '%'    }, /* 0x22 */ \
+    {'6'   , '&'    }, /* 0x23 */ \
+    {'7'   , '\x27' }, /* 0x24 "'" */ \
+    {'8'   , '('    }, /* 0x25 */ \
+    {'9'   , ')'    }, /* 0x26 */ \
+    {'0'   , 0      }, /* 0x27 */ \
+    {'\r'  , '\r'   }, /* 0x28 */ \
+    {'\x1b', '\x1b' }, /* 0x29 [ESC] */ \
+    {'\b'  , '\b'   }, /* 0x2a [BS] */ \
+    {'\t'  , '\t'   }, /* 0x2b [TAB] */ \
+    {' '   , ' '    }, /* 0x2c [SPACE] */ \
+    {'-'   , '='    }, /* 0x2d */ \
+    {'^'   , '~'    }, /* 0x2e */ \
+    {'@'   , '`'    }, /* 0x2f */ \
+    {'['   , '{'    }, /* 0x30 */ \
+    {0     , 0      }, /* 0x31 */ \
+    {']'   , '}'    }, /* 0x32 */ \
+    {';'   , '+'    }, /* 0x33 */ \
+    {':'   , '*'    }, /* 0x34 */ \
+    {'\x12', '\x12' }, /* 0x35 ZEN/HAN = [RVS/OFF] key = ^R */ \
+    {','   , '<'    }, /* 0x36 */ \
+    {'.'   , '>'    }, /* 0x37 */ \
+    {'/'   , '?'    }, /* 0x38 */ \
+                                  \
+    {0     , 0      }, /* 0x39: [CAPS] = SHIFT Lock */ \
+    {0     , 0      }, /* 0x3a */ \
+    {0     , 0      }, /* 0x3b */ \
+    {0     , 0      }, /* 0x3c */ \
+    {0     , 0      }, /* 0x3d */ \
+    {0     , 0      }, /* 0x3e */ \
+    {0     , 0      }, /* 0x3f */ \
+    {0     , 0      }, /* 0x40 */ \
+    {0     , 0      }, /* 0x41 */ \
+    {'<'   , '<'    }, /* 0x42:[F9]  = < */ \
+    {'>'   , '>'    }, /* 0x43:[F10] = > */ \
+    {0     , 0      }, /* 0x44 [F11] */ \
+    {'_'   , '_'    }, /* 0x45:[F12] = [Back Arrow]=chr$($5C) key on PET */ \
+    {0     , 0      }, /* 0x46 */ \
+    {0     , 0      }, /* 0x47 */ \
+    {0     , 0      }, /* 0x48 */ \
+    {0     , '\x14' }, /* 0x49 Insert */ \
+    {'\x13', 0      }, /* 0x4a Home */ \
+    {0     , 0      }, /* 0x4b */ \
+    {'\x14', 0      }, /* 0x4c Delete */ \
+    {0     , 0      }, /* 0x4d */ \
+    {0     , 0      }, /* 0x4e */ \
+    {'\x1d', 0      }, /* 0x4f right arrow */ \
+    {'\x9d', 0      }, /* 0x50 left arrow */ \
+    {'\x11', 0      }, /* 0x51 down arrow */ \
+    {'\x91', 0      }, /* 0x52 up arrow */ \
+    {0     , 0      }, /* 0x53 */ \
+                                  \
+    {'/'   , '/'    }, /* 0x54 */ \
+    {'*'   , '*'    }, /* 0x55 */ \
+    {'-'   , '-'    }, /* 0x56 */ \
+    {'+'   , '+'    }, /* 0x57 */ \
+    {'\r'  , '\r'   }, /* 0x58 */ \
+    {'1'   , 0      }, /* 0x59 */ \
+    {'2'   , 0      }, /* 0x5a */ \
+    {'3'   , 0      }, /* 0x5b */ \
+    {'4'   , 0      }, /* 0x5c */ \
+    {'5'   , 0      }, /* 0x5d */ \
+    {'6'   , 0      }, /* 0x5e */ \
+    {'7'   , 0      }, /* 0x5f */ \
+    {'8'   , 0      }, /* 0x60 */ \
+    {'9'   , 0      }, /* 0x61 */ \
+    {'0'   , 0      }, /* 0x62 */ \
+    {'.'   , 0      }, /* 0x63 */ \
+    {0     , 0      }, /* 0x64 */ \
+    {'\x10', '\x10' }, /* 0x65:[Application] = PET [Repeat] key */ \
+    {0     , 0      }, /* 0x66 */ \
+    {'='   , '='    }, /* 0x67 */ \
+    				  \
+    {0     , 0      }, /* 0x68 */ \
+    {0     , 0      }, /* 0x69 */ \
+    {0     , 0      }, /* 0x6a */ \
+    {0     , 0      }, /* 0x6b */ \
+    {0     , 0      }, /* 0x6c */ \
+    {0     , 0      }, /* 0x6d */ \
+    {0     , 0      }, /* 0x6e */ \
+    {0     , 0      }, /* 0x6f */ \
+    {0     , 0      }, /* 0x70 */ \
+    {0     , 0      }, /* 0x71 */ \
+    {0     , 0      }, /* 0x72 */ \
+    {0     , 0      }, /* 0x73 */ \
+    {0     , 0      }, /* 0x74 */ \
+    {0     , 0      }, /* 0x75 */ \
+    {0     , 0      }, /* 0x76 */ \
+    {0     , 0      }, /* 0x77 */ \
+    {0     , 0      }, /* 0x78 */ \
+    {0     , 0      }, /* 0x79 */ \
+    {0     , 0      }, /* 0x7a */ \
+    {0     , 0      }, /* 0x7b */ \
+    {0     , 0      }, /* 0x7c */ \
+    {0     , 0      }, /* 0x7d */ \
+    {0     , 0      }, /* 0x7e */ \
+    {0     , 0      }, /* 0x7f */ \
+    {0     , 0      }, /* 0x80 */ \
+    {0     , 0      }, /* 0x81 */ \
+    {0     , 0      }, /* 0x82 */ \
+    {0     , 0      }, /* 0x83 */ \
+    {0     , 0      }, /* 0x84 */ \
+    {0     , 0      }, /* 0x85 */ \
+    {0     , 0      }, /* 0x86 */ \
+    				  \
+    {'\x5c', '_'    }, /* 0x87:[Backslash]/[_] key */ \
+    {0     , 0      }, /* 0x88:[Hiragana/Katakana] */ \
+    {'\x5c', 0      }, /* 0x89:[Yen]/[|] key */ \
+};
+
+
+/* Blink pattern
+ * - 250 ms  : device not mounted
+ * - 1000 ms : device mounted
+ * - 2500 ms : device is suspended
+ */
+enum  {
+  BLINK_NOT_MOUNTED = 250,
+  BLINK_MOUNTED = 1000,
+  BLINK_SUSPENDED = 2500,
+};
+
+static uint32_t blink_interval_ms = BLINK_NOT_MOUNTED;
+
+void led_blinking_task(void);
+
+/*------------- Keyboard LED  -------------*/
+static uint8_t leds = 0;
+static uint8_t prev_leds = 0;
+
+/* NUMLOCK Blink pattern
+ * - 250 ms : GAME mode
+ * - 0 ms   : KANA mode
+ */
+enum  {
+  BLINK_NUMLOCK_LED_NONE = 0,
+  BLINK_NUMLOCK_LED_GAME = 250,
+  BLINK_NUMLOCK_LED_KANA = 0,
+};
+
+static uint32_t blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_NONE;
+
+// Keyboard address and instance (assumes there is only one)
+static uint8_t keybd_dev_addr = 0xFFu;
+static uint8_t keybd_instance;
+
+void keyboard_led_blinking_task(void)
+;
+
+/*------------- PET  -------------*/
+
+/*
+#====================================================================
+# Scan Code (Graphics keyboard)
+#  ------+------------------------
+#   row  |  7  6  5  4  3  2  1  0
+#  +1 +0 |  H  G  F  E  D  C  B  A
+#  ------+------------------------
+#  a  9  | 3D 2E 10 03 3C 20 5B 12
+#        |  =  . ^P ^C  < sp  [ ^R   ^C = STOP, ^R = Reverse on, ^P = [Repeat] key
+#        |
+#  9  8  | 2D 30 00 3E FF 5D 40 00
+#        |  -  0 rs  > --  ] @  ls   rs = right shift, ls = left shift
+#        |
+#  8  7  | 2B 32 FF 3F 2C 4E 56 58
+#        |  +  2 --  ?  ,  n  v  x
+#        |
+#  7  6  | 33 31 0D 3B 4D 42 43 5A
+#        |  3  1 ^M  ;  m  b  c  z   ^M = return
+#        |
+#  6  5  | 2A 35 FF 3A 4B 48 46 53
+#        |  *  5 --  :  k  h  f  s
+#        |
+#  5  4  | 36 34 FF 4C 4A 47 44 41
+#        |  6  4 --  l  j  g  d  a
+#        |
+#  4  3  | 2F 38 9B 50 49 59 52 57
+#        |  /  8 ^[  p  i  y  r  w   ^[ = ESC
+#        |
+#  3  2  | 39 37 5E 4F 55 54 45 51
+#        |  9  7  ^  o  u  t  e  q   ^ = [Upper arrow]
+#        |
+#  2  1  | 14 11 09 29 5C 27 24 22
+#        | ^T ^Q \t  )  \  '  $  "   ^T = DEL, ^Q = cursor down, \t=TAB
+#        |
+#  1  0  | 1d 13 5F 28 26 25 23 21
+#        | ^] ^S  _  (  &  %  #  !   ^] = cursor right, _ = Back arrow, ^S = home
+#  ------+------------------------
+#====================================================================
+*/
+/*
+  key code to switch matrix X-Y and SHIFT table
+   (bit 8  : 1 = pressed, 0 = released, in queue only)
+    bit 7  : Need SHIFT (1 = Generate with SHIFT key)
+    bit 6-4: Y scanline (0-7)
+    bit 3-0: X scanline + 1 (1-a), i.e. valid key has non-zero code on this table
+*/
+#define PET_KEYPRESS	0x100u
+#define PET_ISKEYPRESS(x)	((x & PET_KEYPRESS) ? true : false)
+#define PET_BARE_SYX(x)		((uint16_t)(x & ~PET_KEYPRESS))
+#define PET_SHIFT	0x80u
+#define PET_BARE_YX(x)		((uint16_t)(x & ~PET_KEYPRESS & ~PET_SHIFT))
+#define PET_ISSHIFT(x)	((x & PET_SHIFT) ? 1 : 0)
+#define PET_Y(x)	((x >> 4) & 0x07)
+#define PET_X(x)	((x & 0x0f) - 1)
+#define PET_LSX		8	// Left  shift X
+#define PET_LSY		0	// Left  shift Y
+#define PET_RSX		8	// Right shift X
+#define PET_RSY		5	// Right shift Y
+#define DELETE_KEY_CODE	0x4c	// for CTRL-ALT-DEL
+#define C_KEY_CODE		0x06	// for CTRL-C
+#define CAPS_KEY_CODE		0x39	// for SHIFT Lock
+#define KANA_KEY_CODE		0x88	// for KANA input mode
+#define F1_KEY_CODE		0x3a	// [F1] - [F8]: string send
+#define PET_KEYCODE_RUN_STOP	0x4a	// PET [RUN/STOP] key X-Y
+#define PET_KEYCODE_LS		0x09	// PET [Left SHIFT] key X-Y
+#define PET_KEYCODE_RS		0x59	// PET [Right SHIFT] key X-Y
+#define PET_KEYCODE_REPEAT	0x5a	// PET [Repeat] Key  X-Y
+static uint8_t const keycode2petSYX[256][2] =  {
+    {0             , 0             }, /* 0x00   */ \
+    {0             , 0             }, /* 0x01   */ \
+    {0             , 0             }, /* 0x02   */ \
+    {0             , 0             }, /* 0x03   */ \
+    {0x05          , 0x05|PET_SHIFT}, /* 0x04:a */ \
+    {0x27          , 0x27|PET_SHIFT}, /* 0x05:b */ \
+    {0x17          , 0x17|PET_SHIFT}, /* 0x06:c */ \
+    {0x15          , 0x15|PET_SHIFT}, /* 0x07:d */ \
+    {0x13          , 0x13|PET_SHIFT}, /* 0x08:e */ \
+    {0x16          , 0x16|PET_SHIFT}, /* 0x09:f */ \
+    {0x25          , 0x25|PET_SHIFT}, /* 0x0a:g */ \
+    {0x26          , 0x26|PET_SHIFT}, /* 0x0b:h */ \
+    {0x34          , 0x34|PET_SHIFT}, /* 0x0c:i */ \
+    {0x35          , 0x35|PET_SHIFT}, /* 0x0d:j */ \
+    {0x36          , 0x36|PET_SHIFT}, /* 0x0e:k */ \
+    {0x45          , 0x45|PET_SHIFT}, /* 0x0f:l */ \
+\
+    {0x37          , 0x37|PET_SHIFT}, /* 0x10:m */ \
+    {0x28          , 0x28|PET_SHIFT}, /* 0x11:n */ \
+    {0x43          , 0x43|PET_SHIFT}, /* 0x12:o */ \
+    {0x44          , 0x44|PET_SHIFT}, /* 0x13:p */ \
+    {0x03          , 0x03|PET_SHIFT}, /* 0x14:q */ \
+    {0x14          , 0x14|PET_SHIFT}, /* 0x15:r */ \
+    {0x06          , 0x06|PET_SHIFT}, /* 0x16:s */ \
+    {0x23          , 0x23|PET_SHIFT}, /* 0x17:t */ \
+    {0x33          , 0x33|PET_SHIFT}, /* 0x18:u */ \
+    {0x18          , 0x18|PET_SHIFT}, /* 0x19:v */ \
+    {0x04          , 0x04|PET_SHIFT}, /* 0x1a:w */ \
+    {0x08          , 0x08|PET_SHIFT}, /* 0x1b:x */ \
+    {0x24          , 0x24|PET_SHIFT}, /* 0x1c:y */ \
+    {0x07          , 0x07|PET_SHIFT}, /* 0x1d:z */ \
+    {0x67          , 0x01          }, /* 0x1e:1/! */ \
+    {0x68          , 0x02          }, /* 0x1f:2/" */ \
+\
+    {0x77          , 0x11          }, /* 0x20:3/# */ \
+    {0x65          , 0x12          }, /* 0x21:4/$ */ \
+    {0x66          , 0x21          }, /* 0x22:5/% */ \
+    {0x75          , 0x31          }, /* 0x23:6/& */ \
+    {0x63          , 0x22          }, /* 0x24:7/' */ \
+    {0x64          , 0x41          }, /* 0x25:8/( */ \
+    {0x73          , 0x42          }, /* 0x26:9/) */ \
+    {0x69          , 0x69|PET_SHIFT}, /* 0x27:0 */ \
+    {0x57          , 0x57|PET_SHIFT}, /* 0x28:[RETURN] */ \
+    {0x54          , 0x54|PET_SHIFT}, /* 0x29:[ESC] = Unassigned key Graphics Keyboard */ \
+    {0x72          , 0x72|PET_SHIFT}, /* 0x2a:[BS] = [INST/DEL] key */ \
+    {0x52          , 0x52|PET_SHIFT}, /* 0x2b:[TAB] = Unassigned key Graphics Keyboard */ \
+    {0x2a          , 0x2a|PET_SHIFT}, /* 0x2c:[SPACE] */ \
+    {0x79          , 0x7a          }, /* 0x2d:-/= */ \
+    {0x53          , 0x53|PET_SHIFT}, /* 0x2e:^/~ = [Upper arrow] / */ \
+    {0x19          , 0x22          }, /* 0x2f:@/` = @/' */ \
+\
+    {0x1a          , 0x1a|PET_SHIFT}, /* 0x30:[  */ \
+    {0             , 0             }, /* 0x31:NA */ \
+    {0x29          , 0x29|PET_SHIFT}, /* 0x32:]  */ \
+    {0x47          , 0x78          }, /* 0x33:;/+ */ \
+    {0x46          , 0x76          }, /* 0x34:':'/'*' */ \
+    {0x0a          , 0x0a|PET_SHIFT}, /* 0x35 ZEN/HAN = [RVS/OFF] key */ \
+    {0x38          , 0x3a          }, /* 0x36:,/< */ \
+    {0x6a          , 0x49          }, /* 0x37:./> */ \
+    {0x74          , 0x48          }, /* 0x38:'/'/'?' */ \
+    {0             , 0             }, /* 0x39: [SHIFT]+[CAPS] = SHIFT Lock ON/OFF */ \
+    {0             , 0             }, /* 0x3a:[F1] */ \
+    {0             , 0             }, /* 0x3b:[F2] */ \
+    {0             , 0             }, /* 0x3c:[F3] */ \
+    {0             , 0             }, /* 0x3d:[F4] */ \
+    {0             , 0             }, /* 0x3e:[F5] */ \
+    {0             , 0             }, /* 0x3f:[F6] */ \
+\
+    {0             , 0             }, /* 0x40:[F7] */ \
+    {0             , 0             }, /* 0x41:[F8] */ \
+    {0x3a          , 0x31|PET_SHIFT}, /* 0x42:[F9]  = < for 'TRON' game */ \
+    {0x49          , 0x49|PET_SHIFT}, /* 0x43:[F10] = > for 'TRON' game */ \
+    {0             , 0             }, /* 0x44 [F11] */ \
+    {0x51          , 0x51|PET_SHIFT}, /* 0x45:[F12] = [Back Arrow] key on PET */ \
+    {0             , 0             }, /* 0x46 */ \
+    {0             , 0             }, /* 0x47 */ \
+    {0             , 0             }, /* 0x48 */ \
+    {0x72|PET_SHIFT, 0x72|PET_SHIFT}, /* 0x49 Insert = SHIFT + [DEL/INST] */ \
+    {0x61          , 0x61|PET_SHIFT}, /* 0x4a Home = [HOME/CLR] */ \
+    {0             , 0             }, /* 0x4b */ \
+    {0x72          , 0x72|PET_SHIFT}, /* 0x4c Delete = [DEL/INST] key */ \
+    {0             , 0             }, /* 0x4d */ \
+    {0             , 0             }, /* 0x4e */ \
+    {0x71          , 0x71|PET_SHIFT}, /* 0x4f right arrow */ \
+\
+    {0x71|PET_SHIFT, 0x71          }, /* 0x50 left arrow */ \
+    {0x62          , 0x62|PET_SHIFT}, /* 0x51 down arrow */ \
+    {0x62|PET_SHIFT, 0x62          }, /* 0x52 up arrow */ \
+    {0             , 0             }, /* 0x53 */ \
+    {0x74          , 0x74|PET_SHIFT}, /* 0x54:/ */ \
+    {0x76          , 0x76|PET_SHIFT}, /* 0x55:* */ \
+    {0x79          , 0x79|PET_SHIFT}, /* 0x56:- */ \
+    {0x78          , 0x78|PET_SHIFT}, /* 0x57:+ */ \
+    {0x57          , 0x57|PET_SHIFT}, /* 0x58:[RETURN] */ \
+    {0x67          , 0x67|PET_SHIFT}, /* 0x59:1 */ \
+    {0x68          , 0x68|PET_SHIFT}, /* 0x5a:2 */ \
+    {0x77          , 0x77|PET_SHIFT}, /* 0x5b:3 */ \
+    {0x65          , 0x65|PET_SHIFT}, /* 0x5c:4 */ \
+    {0x66          , 0x66|PET_SHIFT}, /* 0x5d:5 */ \
+    {0x75          , 0x75|PET_SHIFT}, /* 0x5e:6 */ \
+    {0x63          , 0x63|PET_SHIFT}, /* 0x5f:7 */ \
+\
+    {0x64          , 0x64|PET_SHIFT}, /* 0x60:8 */ \
+    {0x73          , 0x73|PET_SHIFT}, /* 0x61:9 */ \
+    {0x69          , 0x69|PET_SHIFT}, /* 0x62:0 */ \
+    {0x6a          , 0x6a|PET_SHIFT}, /* 0x63:. */ \
+    {0             , 0             }, /* 0x64 */ \
+    {0x5a          , 0x5a          }, /* 0x65:[Application] = PET [Repeat] key */ \
+    {0             , 0             }, /* 0x66 */ \
+    {0x7a          , 0x7a|PET_SHIFT}, /* 0x67:= */ \
+    {0             , 0             }, /* 0x68 */ \
+    {0             , 0             }, /* 0x69 */ \
+    {0             , 0             }, /* 0x6a */ \
+    {0             , 0             }, /* 0x6b */ \
+    {0             , 0             }, /* 0x6c */ \
+    {0             , 0             }, /* 0x6d */ \
+    {0             , 0             }, /* 0x6e */ \
+    {0             , 0             }, /* 0x6f */ \
+ \
+    {0             , 0             }, /* 0x70 */ \
+    {0             , 0             }, /* 0x71 */ \
+    {0             , 0             }, /* 0x72 */ \
+    {0             , 0             }, /* 0x73 */ \
+    {0             , 0             }, /* 0x74 */ \
+    {0             , 0             }, /* 0x75 */ \
+    {0             , 0             }, /* 0x76 */ \
+    {0             , 0             }, /* 0x77 */ \
+    {0             , 0             }, /* 0x78 */ \
+    {0             , 0             }, /* 0x79 */ \
+    {0             , 0             }, /* 0x7a */ \
+    {0             , 0             }, /* 0x7b */ \
+    {0             , 0             }, /* 0x7c */ \
+    {0             , 0             }, /* 0x7d */ \
+    {0             , 0             }, /* 0x7e */ \
+    {0             , 0             }, /* 0x7f */ \
+ \
+    {0             , 0             }, /* 0x80 */ \
+    {0             , 0             }, /* 0x81 */ \
+    {0             , 0             }, /* 0x82 */ \
+    {0             , 0             }, /* 0x83 */ \
+    {0             , 0             }, /* 0x84 */ \
+    {0             , 0             }, /* 0x85 */ \
+    {0             , 0             }, /* 0x86 */ \
+    {0x32          , 0x51          }, /* 0x87:[Backslash]/[_] key, '_' = CHR$(0x5f) = Backarrow in PETSCII */ \
+    {0             , 0             }, /* 0x88:[Hiragana/Katakana] */ \
+    {0x32          , 0x29|PET_SHIFT}, /* 0x89:[Yen]/[|] key */ \
+};
+
+// table for KANA shift
+static uint8_t const keycode2petSYX_kana[256][2] =  {
+    {0             , 0             }, /* 0x00   */ \
+    {0             , 0             }, /* 0x01   */ \
+    {0             , 0             }, /* 0x02   */ \
+    {0             , 0             }, /* 0x03   */ \
+    {0x05|PET_SHIFT, 0x05|PET_SHIFT}, /* 0x04:[PET:A] チ */ \
+    {0x46|PET_SHIFT, 0x46|PET_SHIFT}, /* 0x05:[PET::] コ */ \
+    {0x48|PET_SHIFT, 0x48|PET_SHIFT}, /* 0x06:[PET:?] ソ */ \
+    {0x3a|PET_SHIFT, 0x3a|PET_SHIFT}, /* 0x07:[PET:<] シ */ \
+    {0x02|PET_SHIFT, 0x02|PET_SHIFT}, /* 0x08:[PET:"] イ */ \
+    {0x35|PET_SHIFT, 0x35|PET_SHIFT}, /* 0x09:[PET:J] ハ */ \
+    {0x22|PET_SHIFT, 0x22|PET_SHIFT}, /* 0x0a:[PET:'] キ */ \
+    {0x41|PET_SHIFT, 0x41|PET_SHIFT}, /* 0x0b:[PET:(] ク */ \
+    {0x16|PET_SHIFT, 0x16|PET_SHIFT}, /* 0x0c:[PET:F] ニ */ \
+    {0x43|PET_SHIFT, 0x43|PET_SHIFT}, /* 0x0d:[PET:O] マ */ \
+    {0x34|PET_SHIFT, 0x34|PET_SHIFT}, /* 0x0e:[PET:I] ノ */ \
+    {0x08|PET_SHIFT, 0x08|PET_SHIFT}, /* 0x0f:[PET:X] リ */ \
+\
+    {0x06|PET_SHIFT, 0x06|PET_SHIFT}, /* 0x10:[PET:S] モ */ \
+    {0x44|PET_SHIFT, 0x44|PET_SHIFT}, /* 0x11:[PET:P] ミ */ \
+    {0x04|PET_SHIFT, 0x04|PET_SHIFT}, /* 0x12:[PET:W] ラ */ \
+    {0x49|PET_SHIFT, 0x49|PET_SHIFT}, /* 0x13:[PET:>] セ */ \
+    {0x63|PET_SHIFT, 0x63|PET_SHIFT}, /* 0x14:[PET:7] タ */ \
+    {0x38|PET_SHIFT, 0x38|PET_SHIFT}, /* 0x15:[PET:,] ス */ \
+    {0x15|PET_SHIFT, 0x15|PET_SHIFT}, /* 0x16:[PET:D] ト */ \
+    {0x31|PET_SHIFT, 0x31|PET_SHIFT}, /* 0x17:[PET:&] カ */ \
+    {0x13|PET_SHIFT, 0x13|PET_SHIFT}, /* 0x18:[PET:E] ナ */ \
+    {0x36|PET_SHIFT, 0x36|PET_SHIFT}, /* 0x19:[PET:K] ヒ */ \
+    {0x17|PET_SHIFT, 0x17|PET_SHIFT}, /* 0x1a:[PET:C] テ */ \
+    {0x47|PET_SHIFT, 0x47|PET_SHIFT}, /* 0x1b:[PET:;] サ */ \
+    {0x73|PET_SHIFT, 0x73|PET_SHIFT}, /* 0x1c:[PET:9] ン */ \
+    {0x27|PET_SHIFT, 0x27|PET_SHIFT}, /* 0x1d:[PET:B] ツ */ \
+    {0x25|PET_SHIFT, 0x25|PET_SHIFT}, /* 0x1e:[PET:G] ヌ */ \
+    {0x45|PET_SHIFT, 0x45|PET_SHIFT}, /* 0x1f:[PET:L] フ */ \
+\
+    {0x01|PET_SHIFT, 0x01|PET_SHIFT}, /* 0x20:[PET:!] ア */ \
+    {0x11|PET_SHIFT, 0x11|PET_SHIFT}, /* 0x21:[PET:#] ウ */ \
+    {0x12|PET_SHIFT, 0x12|PET_SHIFT}, /* 0x22:[PET:$] エ */ \
+    {0x21|PET_SHIFT, 0x21|PET_SHIFT}, /* 0x23:[PET:%] オ */ \
+    {0x23|PET_SHIFT, 0x23|PET_SHIFT}, /* 0x24:[PET:T] ヤ */ \
+    {0x33|PET_SHIFT, 0x33|PET_SHIFT}, /* 0x25:[PET:U] ユ */ \
+    {0x18|PET_SHIFT, 0x18|PET_SHIFT}, /* 0x26:[PET:V] ヨ */ \
+    {0x32|PET_SHIFT, 0x51|PET_SHIFT}, /* 0x27:[PET:＼]/[PET:←] ワ/ヲ */ \
+    {0x57          , 0x57|PET_SHIFT}, /* 0x28:[RETURN] */ \
+    {0x54          , 0x54|PET_SHIFT}, /* 0x29:[ESC] = Unassigned key Graphics Keyboard */ \
+    {0x72          , 0x72|PET_SHIFT}, /* 0x2a:[BS] = [INST/DEL] key */ \
+    {0x52          , 0x52|PET_SHIFT}, /* 0x2b:[TAB] = Unassigned key Graphics Keyboard */ \
+    {0x2a          , 0x2a|PET_SHIFT}, /* 0x2c:[SPACE] */ \
+    {0x28|PET_SHIFT, 0x28|PET_SHIFT}, /* 0x2d:[PET:N] ホ */ \
+    {0x37|PET_SHIFT, 0x37|PET_SHIFT}, /* 0x2e:[PET:M] ヘ */ \
+    {0x76|PET_SHIFT, 0x76|PET_SHIFT}, /* 0x2f:[PET:*] ゛/ */ \
+\
+    {0x74|PET_SHIFT, 0x69|PET_SHIFT}, /* 0x30:[PET:/][PET:0] ゜/「 */ \
+    {0             , 0             }, /* 0x31 */ \
+    {0x03|PET_SHIFT, 0x7a|PET_SHIFT}, /* 0x32:[PET:Q][PET:=] ム/」  */ \
+    {0x07|PET_SHIFT, 0x07|PET_SHIFT}, /* 0x33:[PET:Z] レ */ \
+    {0x42|PET_SHIFT, 0x42|PET_SHIFT}, /* 0x34:[PET:)] ケ */ \
+    {0x0a          , 0x0a|PET_SHIFT}, /* 0x35 ZEN/HAN = [RVS/OFF] key */ \
+    {0x26|PET_SHIFT, 0x38          }, /* 0x36:[PET:H]/[PET:,] ネ/、 */ \
+    {0x24|PET_SHIFT, 0x6a          }, /* 0x37:[PET:Y]/[PET:.] ル/。 */ \
+    {0x14|PET_SHIFT, 0             }, /* 0x38:[PET:R]/[PET:NA] メ/・ */ \
+    {0             , 0             }, /* 0x39: [SHIFT]+[CAPS] = SHIFT Lock ON/OFF */ \
+    {0             , 0             }, /* 0x3a:[F1] */ \
+    {0             , 0             }, /* 0x3b:[F2] */ \
+    {0             , 0             }, /* 0x3c:[F3] */ \
+    {0             , 0             }, /* 0x3d:[F4] */ \
+    {0             , 0             }, /* 0x3e:[F5] */ \
+    {0             , 0             }, /* 0x3f:[F6] */ \
+\
+    {0             , 0             }, /* 0x40:[F7] */ \
+    {0             , 0             }, /* 0x41:[F8] */ \
+    {0x65|PET_SHIFT, 0x65|PET_SHIFT}, /* 0x42:[F9] [PET:4] 年 */ \
+    {0x66|PET_SHIFT, 0x66|PET_SHIFT}, /* 0x43:[F10][PET:5] 月 */ \
+    {0x75|PET_SHIFT, 0x75|PET_SHIFT}, /* 0x44:[F11][PET:6] 日 */ \
+    {0x51          , 0x51|PET_SHIFT}, /* 0x45:[F12] = [Back Arrow] key on PET */ \
+    {0             , 0             }, /* 0x46 */ \
+    {0             , 0             }, /* 0x47 */ \
+    {0             , 0             }, /* 0x48 */ \
+    {0x72|PET_SHIFT, 0x72|PET_SHIFT}, /* 0x49 Insert = SHIFT + [DEL/INST] */ \
+    {0x61          , 0x61|PET_SHIFT}, /* 0x4a Home = [HOME/CLR] */ \
+    {0             , 0             }, /* 0x4b */ \
+    {0x72          , 0x72|PET_SHIFT}, /* 0x4c Delete = [DEL/INST] key */ \
+    {0             , 0             }, /* 0x4d */ \
+    {0             , 0             }, /* 0x4e */ \
+    {0x71          , 0x71|PET_SHIFT}, /* 0x4f right arrow */ \
+\
+    {0x71|PET_SHIFT, 0x71          }, /* 0x50 left arrow */ \
+    {0x62          , 0x62|PET_SHIFT}, /* 0x51 down arrow */ \
+    {0x62|PET_SHIFT, 0x62          }, /* 0x52 up arrow */ \
+    {0             , 0             }, /* 0x53 */ \
+    {0x74          , 0x74|PET_SHIFT}, /* 0x54:/ */ \
+    {0x76          , 0x76|PET_SHIFT}, /* 0x55:* */ \
+    {0x79          , 0x79|PET_SHIFT}, /* 0x56:- */ \
+    {0x78          , 0x78|PET_SHIFT}, /* 0x57:+ */ \
+    {0x57          , 0x57|PET_SHIFT}, /* 0x58:[RETURN] */ \
+    {0x67          , 0x67|PET_SHIFT}, /* 0x59:1 */ \
+    {0x68          , 0x68|PET_SHIFT}, /* 0x5a:2 */ \
+    {0x77          , 0x77|PET_SHIFT}, /* 0x5b:3 */ \
+    {0x65          , 0x65|PET_SHIFT}, /* 0x5c:4 */ \
+    {0x66          , 0x66|PET_SHIFT}, /* 0x5d:5 */ \
+    {0x75          , 0x75|PET_SHIFT}, /* 0x5e:6 */ \
+    {0x63          , 0x63|PET_SHIFT}, /* 0x5f:7 */ \
+\
+    {0x64          , 0x64|PET_SHIFT}, /* 0x60:8 */ \
+    {0x73          , 0x73|PET_SHIFT}, /* 0x61:9 */ \
+    {0x69          , 0x69|PET_SHIFT}, /* 0x62:0 */ \
+    {0x6a          , 0x6a|PET_SHIFT}, /* 0x63:. */ \
+    {0             , 0             }, /* 0x64 */ \
+    {0x5a          , 0x5a          }, /* 0x65:[Application] = PET [Repeat] key */ \
+    {0             , 0             }, /* 0x66 */ \
+    {0x7a          , 0x7a|PET_SHIFT}, /* 0x67:= */ \
+    {0             , 0             }, /* 0x68 */ \
+    {0             , 0             }, /* 0x69 */ \
+    {0             , 0             }, /* 0x6a */ \
+    {0             , 0             }, /* 0x6b */ \
+    {0             , 0             }, /* 0x6c */ \
+    {0             , 0             }, /* 0x6d */ \
+    {0             , 0             }, /* 0x6e */ \
+    {0             , 0             }, /* 0x6f */ \
+ \
+    {0             , 0             }, /* 0x70 */ \
+    {0             , 0             }, /* 0x71 */ \
+    {0             , 0             }, /* 0x72 */ \
+    {0             , 0             }, /* 0x73 */ \
+    {0             , 0             }, /* 0x74 */ \
+    {0             , 0             }, /* 0x75 */ \
+    {0             , 0             }, /* 0x76 */ \
+    {0             , 0             }, /* 0x77 */ \
+    {0             , 0             }, /* 0x78 */ \
+    {0             , 0             }, /* 0x79 */ \
+    {0             , 0             }, /* 0x7a */ \
+    {0             , 0             }, /* 0x7b */ \
+    {0             , 0             }, /* 0x7c */ \
+    {0             , 0             }, /* 0x7d */ \
+    {0             , 0             }, /* 0x7e */ \
+    {0             , 0             }, /* 0x7f */ \
+ \
+    {0             , 0             }, /* 0x80 */ \
+    {0             , 0             }, /* 0x81 */ \
+    {0             , 0             }, /* 0x82 */ \
+    {0             , 0             }, /* 0x83 */ \
+    {0             , 0             }, /* 0x84 */ \
+    {0             , 0             }, /* 0x85 */ \
+    {0             , 0             }, /* 0x86 */ \
+    {0x64|PET_SHIFT, 0x64|PET_SHIFT}, /* 0x87:[PET:8] ロ key */ \
+    {0             , 0             }, /* 0x88:[Hiragana/Katakana] */ \
+    {0x79          , 0x29|PET_SHIFT}, /* 0x89:[PET:\] －/[|] key */ \
+};
+
+// table for GAME mode (transparent shift mode)
+static uint8_t const keycode2petSYX_game[256] =  {
+    0   , /* 0x00   */ \
+    0   , /* 0x01   */ \
+    0   , /* 0x02   */ \
+    0   , /* 0x03   */ \
+    0x05, /* 0x04:a */ \
+    0x27, /* 0x05:b */ \
+    0x17, /* 0x06:c */ \
+    0x15, /* 0x07:d */ \
+    0x13, /* 0x08:e */ \
+    0x16, /* 0x09:f */ \
+    0x25, /* 0x0a:g */ \
+    0x26, /* 0x0b:h */ \
+    0x34, /* 0x0c:i */ \
+    0x35, /* 0x0d:j */ \
+    0x36, /* 0x0e:k */ \
+    0x45, /* 0x0f:l */ \
+\
+    0x37, /* 0x10:m */ \
+    0x28, /* 0x11:n */ \
+    0x43, /* 0x12:o */ \
+    0x44, /* 0x13:p */ \
+    0x03, /* 0x14:q */ \
+    0x14, /* 0x15:r */ \
+    0x06, /* 0x16:s */ \
+    0x23, /* 0x17:t */ \
+    0x33, /* 0x18:u */ \
+    0x18, /* 0x19:v */ \
+    0x04, /* 0x1a:w */ \
+    0x08, /* 0x1b:x */ \
+    0x24, /* 0x1c:y */ \
+    0x07, /* 0x1d:z */ \
+    0x01, /* 0x1e:1[!] */ \
+    0x02, /* 0x1f:2["] */ \
+\
+    0x11, /* 0x20:3[#] */ \
+    0x12, /* 0x21:4[$] */ \
+    0x21, /* 0x22:5[%] */ \
+    0x31, /* 0x23:6[&] */ \
+    0x22, /* 0x24:7['] */ \
+    0x41, /* 0x25:8[(] */ \
+    0x42, /* 0x26:9[)] */ \
+    0   , /* 0x27:0:N/A */ \
+    0x57, /* 0x28:[RETURN] */ \
+    0x54, /* 0x29:[ESC] = Unassigned key Graphics Keyboard */ \
+    0x72, /* 0x2a:[BS] = [INST/DEL] key */ \
+    0x52, /* 0x2b:[TAB] = Unassigned key Graphics Keyboard */ \
+    0x2a, /* 0x2c:[SPACE] */ \
+    0x7a, /* 0x2d:-[=] */ \
+    0x53, /* 0x2e:^/~ = [Upper arrow] / */ \
+    0x19, /* 0x2f:@/` = @/' */ \
+\
+    0x1a, /* 0x30:[  */ \
+    0   , /* 0x31:NA */ \
+    0x29, /* 0x32:]  */ \
+    0x47, /* 0x33:;/+ = [;] */ \
+    0x46, /* 0x34:':'/'*' = [:] */ \
+    0x0a, /* 0x35 ZEN/HAN = [RVS/OFF] key */ \
+    0x38, /* 0x36:,/< = [,] */ \
+    0x6a, /* 0x37:./> = [.] */ \
+    0x48, /* 0x38:'/'/'?' =[?] */ \
+    0   , /* 0x39: [CAPS] = SHIFT Lock ON/OFF */ \
+    0   , /* 0x3a:[F1] */ \
+    0   , /* 0x3b:[F2] */ \
+    0   , /* 0x3c:[F3] */ \
+    0   , /* 0x3d:[F4] */ \
+    0   , /* 0x3e:[F5] */ \
+    0   , /* 0x3f:[F6] */ \
+\
+    0   , /* 0x40:[F7] */ \
+    0   , /* 0x41:[F8] */ \
+    0x3a, /* 0x42:[F9]  = < for 'TRON' game */ \
+    0x49, /* 0x43:[F10] = > for 'TRON' game */ \
+    0   , /* 0x44 [F11] */ \
+    0x51, /* 0x45:[F12] = [Back Arrow] key on PET */ \
+    0   , /* 0x46 */ \
+    0   , /* 0x47 */ \
+    0   , /* 0x48 */ \
+    0   , /* 0x49 Insert = N/A */ \
+    0x61, /* 0x4a Home = [HOME/CLR] */ \
+    0   , /* 0x4b */ \
+    0x72, /* 0x4c Delete = [DEL/INST] key */ \
+    0   , /* 0x4d */ \
+    0   , /* 0x4e */ \
+    0x71, /* 0x4f right arrow */ \
+\
+    0   , /* 0x50 left arrow = N/A */ \
+    0x62, /* 0x51 down arrow */ \
+    0   , /* 0x52 up arrow = N/A */ \
+    0   , /* 0x53 */ \
+    0x74, /* 0x54:/ */ \
+    0x76, /* 0x55:* */ \
+    0x79, /* 0x56:- */ \
+    0x78, /* 0x57:+ */ \
+    0x57, /* 0x58:[RETURN] */ \
+    0x67, /* 0x59:1 */ \
+    0x68, /* 0x5a:2 */ \
+    0x77, /* 0x5b:3 */ \
+    0x65, /* 0x5c:4 */ \
+    0x66, /* 0x5d:5 */ \
+    0x75, /* 0x5e:6 */ \
+    0x63, /* 0x5f:7 */ \
+\
+    0x64, /* 0x60:8 */ \
+    0x73, /* 0x61:9 */ \
+    0x69, /* 0x62:0 */ \
+    0x6a, /* 0x63:. */ \
+    0   , /* 0x64 */ \
+    0x5a, /* 0x65:[Application] = PET [Repeat] key */ \
+    0   , /* 0x66 */ \
+    0x7a, /* 0x67:= */ \
+    0   , /* 0x68 */ \
+    0   , /* 0x69 */ \
+    0   , /* 0x6a */ \
+    0   , /* 0x6b */ \
+    0   , /* 0x6c */ \
+    0   , /* 0x6d */ \
+    0   , /* 0x6e */ \
+    0   , /* 0x6f */ \
+ \
+    0   , /* 0x70 */ \
+    0   , /* 0x71 */ \
+    0   , /* 0x72 */ \
+    0   , /* 0x73 */ \
+    0   , /* 0x74 */ \
+    0   , /* 0x75 */ \
+    0   , /* 0x76 */ \
+    0   , /* 0x77 */ \
+    0   , /* 0x78 */ \
+    0   , /* 0x79 */ \
+    0   , /* 0x7a */ \
+    0   , /* 0x7b */ \
+    0   , /* 0x7c */ \
+    0   , /* 0x7d */ \
+    0   , /* 0x7e */ \
+    0   , /* 0x7f */ \
+ \
+    0   , /* 0x80 */ \
+    0   , /* 0x81 */ \
+    0   , /* 0x82 */ \
+    0   , /* 0x83 */ \
+    0   , /* 0x84 */ \
+    0   , /* 0x85 */ \
+    0   , /* 0x86 */ \
+    0x32, /* 0x87:[Backslash]/[_] key = [Backslash] */ \
+    0   , /* 0x88:[Hiragana/Katakana] */ \
+    0x32, /* 0x89:[Yen]/[|] key = [Backslash] */ \
+};
+
+
+// F1 - F8 default string
+#define PET_NUM_FKEYS	8
+#define PET_FKEY_MAXLEN	256
+// the string length must be less than PET_FKEY_MAXLEN
+#ifndef PET2001N
+static char const *pet_func_key_string_default[PET_NUM_FKEYS] = {
+  "poke 59468,12\r",						// 1: uppercase/graphics mode
+  "poke 59468,14\r",						// 2: lower/uppercase mode
+  "poke 59520,12:poke 59521,16\r",				// 3: Font set #0
+  "poke 59520,12:poke 59521,48\r",				// 4: Font set #1
+  "open1,8,15,\"cd:\":close1\x9d\x9d\x9d\x9d\x9d\x9d\x9d\x9d",	// 5: chdir
+  "open1,8,15,\"cd_\":close1\r",				// 6: chdir ..
+  "poke 59520,12:poke 59521,0\r",				// 7: Font set #0, Inverse
+  "sys 60928\r",						// 8: Install ROM DOS Wedge
+};
+#else // PET-2001N with PCG
+static char const *pet_func_key_string_default[PET_NUM_FKEYS] = {
+  "poke 59468,12\r",						// 1: uppercase/graphics mode
+  "poke 59468,14\r",						// 2: lower/uppercase mode
+  "sys 40960\r",						// 3: Install BASIC extension at $a000
+  "sys 45056\r",						// 4: Install BASIC extension at $b000
+  "open1,8,15,\"cd:\":close1\x9d\x9d\x9d\x9d\x9d\x9d\x9d\x9d",	// 5: chdir
+  "open1,8,15,\"cd_\":close1\r",				// 6: chdir ..
+  "poke 59459,255:poke 59471,0\r",				// 7: PCG init: Port-A=All-out / All-Zero
+  "sys 36864\r",						// 8: Install ROM DOS Wedge at $9000
+};
+#endif
+
+// ASCII to HID keycode + modifier code table (fill later)
+static uint8_t ascii2keycode[PET_FKEY_MAXLEN]= {0};
+static uint8_t ascii2modifier[PET_FKEY_MAXLEN]= {0};
+
+// SHIFT LOCK / kana+game mode
+static bool shift_lock = false;
+static enum {
+  PET_KBMODE_NORMAL = 0,
+  PET_KBMODE_KANA,
+  PET_KBMODE_GAME,
+} pet_kb_mode = PET_KBMODE_NORMAL;
+
+// PET's last SHIFT Key state
+static bool pet_last_shift_state = false;
+
+// Function key definition mode
+static bool    fkey_def_mode = false;
+static uint16_t fkey_def_keynum  = 0;
+
+// Function key buffer
+typedef struct {
+  size_t length;		// Number of keycodes in this entry
+  bool initial_shift_lock;	// initial shift_lock value of the fkey assume
+  bool initial_pet_kb_mode;	// initial pet_kb_mode value of the fkey assume
+  uint8_t modifier[PET_FKEY_MAXLEN];	// HID modifier
+  uint8_t keycode[PET_FKEY_MAXLEN];	// HID keycode
+} pet_func_key_store_t;
+static pet_func_key_store_t pet_func_key_store[PET_NUM_FKEYS] = {0};
+
+
+
+// Wait time for debounce
+#define PET_KBIF_RESET_MS		10
+#define PET_KBIF_STROBE_MS		1
+#define PET_KBIF_DEBOUNCE_MS		16	// 14 NG, 15:OK, 16: safer
+#define PET_KBIF_RELEASE_DEBOUNCE_MS	1
+#define PET_KBIF_WAIT_BETWEEN_THE_SAME_KEY_MS	PET_KBIF_DEBOUNCE_MS
+#define PET_KBIF_CTRL_ALT_DEL_MS	500
+
+// Pin assignments
+#define PET_PIO_RESET_PIN	6
+#define PET_PIO_DATA_PIN	7
+#define PET_PIO_STROBE_PIN	8
+#define PET_PIO_AX0_PIN		9
+#define PET_PIO_AX1_PIN		10
+#define PET_PIO_AX2_PIN		11
+#define PET_PIO_AX3_PIN		12
+#define PET_PIO_AY0_PIN		13
+#define PET_PIO_AY1_PIN		14
+#define PET_PIO_AY2_PIN		15
+#define PET_PIO_PET_RESET_PIN	19
+
+// fill ascii2*[] table
+static void pet_fill_ascii2hid(void)
+{
+  for (uint16_t c = 1; c < 256; c++)
+  {
+    for (uint16_t k = 4; k < 256; k++)
+    {
+      for (uint16_t s = 0; s < 2; s++)
+      {
+        if (keycode2ascii[k][s] == (uint8_t)c)
+        {
+          ascii2keycode[c]  = (uint8_t)k;
+          ascii2modifier[c] = s ? KEYBOARD_MODIFIER_LEFTSHIFT : 0;
+          k = 256;	// found
+          break;
+        }
+      }
+    }
+  }
+}
+
+// Store function key buffer default
+// must be after pet_fill_ascii2hid()
+static void pet_func_ket_init(void)
+{
+  for (int i = 0; i < PET_NUM_FKEYS; i++)
+  {
+    const char *s = pet_func_key_string_default[i];
+    size_t l = strlen(s);
+    pet_func_key_store[i].length = l;
+    pet_func_key_store[i].initial_shift_lock = false;
+    pet_func_key_store[i].initial_pet_kb_mode  = PET_KBMODE_NORMAL;
+
+    for (size_t n = 0; n < l; n++)
+    {
+      pet_func_key_store[i].keycode[n]  = ascii2keycode[(uint8_t)s[n]];
+      pet_func_key_store[i].modifier[n] = ascii2modifier[(uint8_t)s[n]];
+    }
+  }
+}
+
+
+// PET key sending task
+static enum  {
+  PET_TASK_STATE_RESET = 0,
+  PET_TASK_STATE_RESET_ASSERTED,
+  PET_TASK_STATE_GETKEY,
+  PET_TASK_STATE_KEY_STROBE_ASSERTED,
+  PET_TASK_STATE_KEY_STROBE_DEASSERTED,
+  PET_TASK_STATE_KEY_WAIT_DEBOUNCE,
+  PET_TASK_STATE_KEY_WAIT_RELEASE_DEBOUNCE,
+  PET_TASK_STATE_CTRL_ALT_DEL,
+  PET_TASK_STATE_CTRL_ALT_DEL_ASSERTED,
+  PET_TASK_STATE_WAITING_BETWEEN_THE_SAME_KEY,
+} pet_key_sending_task_state = PET_TASK_STATE_RESET;
+static uint32_t pet_task_start_ms = 0;
+void pet_sendkey_task(void);
+
+
+// Key queue for PET
+#define PET_KEY_QUEUE_LEN	((uint16_t)256)
+static uint16_t pet_key_queue[PET_KEY_QUEUE_LEN] =  { 0 };
+static uint16_t pet_key_queue_read = 0;
+static uint16_t pet_key_queue_write = 0;
+
+// return number of data in queue
+uint16_t pet_key_queue_num_data(void)
+{
+  return (uint16_t)((pet_key_queue_write + PET_KEY_QUEUE_LEN - pet_key_queue_read) % PET_KEY_QUEUE_LEN);
+}
+
+// put key into queue
+void pet_key_queue_put(uint16_t syx)
+{
+  if ((uint16_t)((pet_key_queue_write + 1) % PET_KEY_QUEUE_LEN) != pet_key_queue_write)
+  {
+    pet_key_queue[pet_key_queue_write] = syx;
+    pet_key_queue_write = (uint16_t)((pet_key_queue_write + 1) % PET_KEY_QUEUE_LEN);
+  }
+  else
+  {
+    // TODO when queue is full
+    pet_key_sending_task_state = PET_TASK_STATE_RESET;
+  }
+}
+
+// peek queue
+uint16_t pet_key_queue_peek(void)
+{
+  if (pet_key_queue_read == pet_key_queue_write) return 0;	// No key in queue
+  return pet_key_queue[pet_key_queue_read];			// Peek queue
+}
+
+// drop queue
+void pet_key_queue_drop(void)
+{
+  if (pet_key_queue_read == pet_key_queue_write) return;	// No key in queue
+  // advance queue read pointer
+  pet_key_queue_read = (uint16_t)((pet_key_queue_read + 1) % PET_KEY_QUEUE_LEN);
+}
+
+
+// Reset
+// Initialize
+static void pet_switch_init(void)
+{
+  gpio_init(PET_PIO_RESET_PIN);
+  gpio_init(PET_PIO_DATA_PIN);
+  gpio_init(PET_PIO_STROBE_PIN);
+  gpio_init(PET_PIO_AX0_PIN);
+  gpio_init(PET_PIO_AX1_PIN);
+  gpio_init(PET_PIO_AX2_PIN);
+  gpio_init(PET_PIO_AX3_PIN);
+  gpio_init(PET_PIO_AY0_PIN);
+  gpio_init(PET_PIO_AY1_PIN);
+  gpio_init(PET_PIO_AY2_PIN);
+  gpio_init(PET_PIO_PET_RESET_PIN);
+
+  gpio_set_dir(PET_PIO_RESET_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_DATA_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_STROBE_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_AX0_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_AX1_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_AX2_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_AX3_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_AY0_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_AY1_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_AY2_PIN, GPIO_OUT);
+  gpio_set_dir(PET_PIO_PET_RESET_PIN, GPIO_OUT);
+
+  gpio_put(PET_PIO_RESET_PIN, 0);
+  gpio_put(PET_PIO_DATA_PIN, 0);
+  gpio_put(PET_PIO_STROBE_PIN, 0);
+  gpio_put(PET_PIO_AX0_PIN, 0);
+  gpio_put(PET_PIO_AX1_PIN, 0);
+  gpio_put(PET_PIO_AX2_PIN, 0);
+  gpio_put(PET_PIO_AX3_PIN, 0);
+  gpio_put(PET_PIO_AY0_PIN, 0);
+  gpio_put(PET_PIO_AY1_PIN, 0);
+  gpio_put(PET_PIO_AY2_PIN, 0);
+  gpio_put(PET_PIO_PET_RESET_PIN, 0);
+
+  // init queue
+  pet_key_queue_read = 0;
+  pet_key_queue_write = 0;
+  
+  // init SHIFT LOCK
+  shift_lock = false;
+  pet_kb_mode = PET_KBMODE_NORMAL;
+  pet_last_shift_state = false;
+
+  // init LED
+  leds = 0;
+  prev_leds = 0;
+  blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_NONE;
+  if (keybd_dev_addr != 0xFFu)
+  {
+    tuh_hid_set_report(keybd_dev_addr, keybd_instance, 0, HID_REPORT_TYPE_OUTPUT, &leds, sizeof(leds));
+  }
+
+  // init fkey
+  pet_func_ket_init();
+  fkey_def_mode = false;
+
+  // Assert Reset of switch array IC
+  gpio_put(PET_PIO_RESET_PIN, 1);
+
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_RESET_ASSERTED;
+  pet_task_start_ms = board_millis();
+}
+
+
+void pet_switch_all_relase(void)
+{
+  // Release all keys
+  // Assert Reset of switch array IC
+  gpio_put(PET_PIO_RESET_PIN, 1);
+
+  // init
+  pet_key_queue_read = 0;
+  pet_key_queue_write = 0;
+  shift_lock = false;
+  pet_last_shift_state = false;
+  fkey_def_mode = false;
+
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_RESET_ASSERTED;
+  pet_task_start_ms = board_millis();
+}
+
+
+static void pet_switch_deassert_reset(void)
+{
+  // Deassert Reset of switch array IC
+  gpio_put(PET_PIO_RESET_PIN, 0);
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_GETKEY;
+  pet_task_start_ms = board_millis();
+}
+
+// Switch ON/OFF
+void pet_switch_set(uint8_t x, uint8_t y, bool onoff)
+{
+  if (x > 5) x += 2;	// No switch on X=6 and X=7
+
+  gpio_put(PET_PIO_AX0_PIN, x & 1);
+  gpio_put(PET_PIO_AX1_PIN, (x & 2) ? 1 : 0);
+  gpio_put(PET_PIO_AX2_PIN, (x & 4) ? 1 : 0);
+  gpio_put(PET_PIO_AX3_PIN, (x & 8) ? 1 : 0);
+  gpio_put(PET_PIO_AY0_PIN, y & 1);
+  gpio_put(PET_PIO_AY1_PIN, (y & 2) ? 1 : 0);
+  gpio_put(PET_PIO_AY2_PIN, (y & 4) ? 1 : 0);
+  gpio_put(PET_PIO_DATA_PIN, (onoff) ? 1 : 0);
+  gpio_put(PET_PIO_STROBE_PIN, 1);
+
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_KEY_STROBE_ASSERTED;
+  pet_task_start_ms = board_millis();
+}
+
+void pet_switch_deassert_strobe(void)
+{
+  gpio_put(PET_PIO_STROBE_PIN, 0);
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_KEY_STROBE_DEASSERTED;
+  pet_task_start_ms = board_millis();
+}
+
+// debounce
+void pet_switch_start_waiting_debounce(void)
+{
+  // Change task state
+  pet_key_sending_task_state =  gpio_get(PET_PIO_DATA_PIN) ? PET_TASK_STATE_KEY_WAIT_DEBOUNCE : PET_TASK_STATE_KEY_WAIT_RELEASE_DEBOUNCE;
+  pet_task_start_ms = board_millis();
+}
+
+// get next key
+void pet_switch_get_next_key(void)
+{
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_GETKEY;
+  pet_task_start_ms = board_millis();
+}
+
+// wait between the same key pressed again
+void pet_switch_start_waiting_between_the_same_key(void)
+{
+  // Change task state
+  pet_key_sending_task_state =  PET_TASK_STATE_WAITING_BETWEEN_THE_SAME_KEY;
+  pet_task_start_ms = board_millis();
+}
+
+static void pet_switch_ctrl_alt_del(void)
+{
+  // Assert CTRL-ALT-DEL
+  gpio_put(PET_PIO_PET_RESET_PIN, 1);
+  // Assert Reset of switch array IC
+  gpio_put(PET_PIO_RESET_PIN, 1);
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_CTRL_ALT_DEL_ASSERTED;
+  pet_task_start_ms = board_millis();
+}
+
+static void pet_switch_deassert_ctrl_alt_del(void)
+{
+  // Dessert Reset of switch array IC
+  gpio_put(PET_PIO_RESET_PIN, 0);
+  // Dessert CTRL-ALT-DEL
+  gpio_put(PET_PIO_PET_RESET_PIN, 0);
+  // init queue
+  pet_key_queue_read = 0;
+  pet_key_queue_write = 0;
+
+  // init SHIFT LOCK
+  shift_lock = false;
+  pet_kb_mode = PET_KBMODE_NORMAL;
+  pet_last_shift_state = false;
+
+  // init LED
+  leds = 0;
+  prev_leds = 0;
+  blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_NONE;
+  if (keybd_dev_addr != 0xFFu)
+  {
+    tuh_hid_set_report(keybd_dev_addr, keybd_instance, 0, HID_REPORT_TYPE_OUTPUT, &leds, sizeof(leds));
+  }
+
+
+  // init fkey
+  pet_func_ket_init();
+  fkey_def_mode = false;
+
+  // Change task state
+  pet_key_sending_task_state = PET_TASK_STATE_GETKEY;
+  pet_task_start_ms = board_millis();
+}
+
+
+/*------------- MAIN -------------*/
+int main(void)
+{
+  board_init();
+  pet_fill_ascii2hid();
+  pet_func_ket_init();
+
+  printf("PETKB + TinyUSB Host HID <-> Device CDC Example\r\n");
+
+  // init device and host stack on configured roothub port
+  tud_init(BOARD_TUD_RHPORT);
+  tuh_init(BOARD_TUH_RHPORT);
+
+  while (1)
+  {
+    tud_task(); // tinyusb device task
+    tuh_task(); // tinyusb host task
+    led_blinking_task();
+    pet_sendkey_task();
+    keyboard_led_blinking_task();
+  }
+
+  return 0;
+}
+
+//--------------------------------------------------------------------+
+// Device CDC
+//--------------------------------------------------------------------+
+
+// Invoked when device is mounted
+void tud_mount_cb(void)
+{
+  blink_interval_ms = BLINK_MOUNTED;
+}
+
+// Invoked when device is unmounted
+void tud_umount_cb(void)
+{
+  blink_interval_ms = BLINK_NOT_MOUNTED;
+}
+
+// Invoked when usb bus is suspended
+// remote_wakeup_en : if host allow us  to perform remote wakeup
+// Within 7ms, device must draw an average of current less than 2.5 mA from bus
+void tud_suspend_cb(bool remote_wakeup_en)
+{
+  (void) remote_wakeup_en;
+  blink_interval_ms = BLINK_SUSPENDED;
+}
+
+// Invoked when usb bus is resumed
+void tud_resume_cb(void)
+{
+  blink_interval_ms = BLINK_MOUNTED;
+}
+
+// Invoked when CDC interface received data from host
+void tud_cdc_rx_cb(uint8_t itf)
+{
+  (void) itf;
+
+  char buf[64];
+  uint32_t count = tud_cdc_read(buf, sizeof(buf));
+
+  // TODO control LED on keyboard of host stack
+  (void) count;
+}
+
+//--------------------------------------------------------------------+
+// Host HID
+//--------------------------------------------------------------------+
+
+// Invoked when device with hid interface is mounted
+// Report descriptor is also available for use. tuh_hid_parse_report_descriptor()
+// can be used to parse common/simple enough descriptor.
+// Note: if report descriptor length > CFG_TUH_ENUMERATION_BUFSIZE, it will be skipped
+// therefore report_desc = NULL, desc_len = 0
+void tuh_hid_mount_cb(uint8_t dev_addr, uint8_t instance, uint8_t const* desc_report, uint16_t desc_len)
+{
+  (void)desc_report;
+  (void)desc_len;
+
+  // Interface protocol (hid_interface_protocol_enum_t)
+  const char* protocol_str[] = { "None", "Keyboard", "Mouse" };
+  uint8_t const itf_protocol = tuh_hid_interface_protocol(dev_addr, instance);
+
+  uint16_t vid, pid;
+  tuh_vid_pid_get(dev_addr, &vid, &pid);
+
+  char tempbuf[256];
+  int count = sprintf(tempbuf, "[%04x:%04x][%u] HID Interface%u, Protocol = %s\r\n", vid, pid, dev_addr, instance, protocol_str[itf_protocol]);
+  tud_cdc_write(tempbuf, (uint32_t) count);
+  tud_cdc_write_flush();
+
+  // Receive report from boot keyboard & mouse only
+  // tuh_hid_report_received_cb() will be invoked when report is available
+  if (itf_protocol == HID_ITF_PROTOCOL_KEYBOARD || itf_protocol == HID_ITF_PROTOCOL_MOUSE)
+  {
+    if ( !tuh_hid_receive_report(dev_addr, instance) )
+    {
+      tud_cdc_write_str("Error: cannot request report\r\n");
+    }
+  }
+
+  // When HID Keyboard attached
+  if (itf_protocol == HID_ITF_PROTOCOL_KEYBOARD)
+  {
+    // Init LED
+    leds = 0;
+    prev_leds = 0;
+    keybd_dev_addr = dev_addr;
+    keybd_instance = instance;
+    tuh_hid_set_report(keybd_dev_addr, keybd_instance, 0, HID_REPORT_TYPE_OUTPUT, &leds, sizeof(leds));
+    // Reset PET I/F
+    pet_key_sending_task_state = PET_TASK_STATE_RESET_ASSERTED;
+  }
+}
+
+// Invoked when device with hid interface is un-mounted
+void tuh_hid_umount_cb(uint8_t dev_addr, uint8_t instance)
+{
+  char tempbuf[256];
+  int count = sprintf(tempbuf, "[%u] HID Interface%u is unmounted\r\n", dev_addr, instance);
+  tud_cdc_write(tempbuf, (uint32_t) count);
+  tud_cdc_write_flush();
+
+  // Reset PET I/F
+  pet_key_sending_task_state = PET_TASK_STATE_RESET_ASSERTED;
+
+  keybd_dev_addr = 0xFFu;
+
+  // Init KB LED
+  leds = 0;
+  prev_leds = 0;
+  blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_NONE;
+
+  // init SHIFT LOCK
+  shift_lock = false;
+  pet_kb_mode = PET_KBMODE_NORMAL;
+  pet_last_shift_state = false;
+}
+
+// look up new key in previous keys
+static inline bool find_key_in_report(hid_keyboard_report_t const *report, uint8_t keycode)
+{
+  for(uint8_t i=0; i<6; i++)
+  {
+    if (report->keycode[i] == keycode)  return true;
+  }
+
+  return false;
+}
+
+
+// convert hid keycode to ascii and print via usb device CDC (ignore non-printable)
+static void process_kbd_report(uint8_t dev_addr, hid_keyboard_report_t const *report)
+{
+  (void) dev_addr;
+  static hid_keyboard_report_t prev_report = { 0, 0, {0} }; // previous report to check key released
+  bool flush = false;
+  static uint8_t last_modifier = 0;
+
+
+  // Check modifier change
+  if (last_modifier != report->modifier)
+  {
+    char tempbuf[256];
+    int count = sprintf(tempbuf, "Modifier: %02x -> %02x\r\n", last_modifier, report->modifier);
+    tud_cdc_write(tempbuf, (uint32_t) count);
+    flush = true;
+
+    // GAME mode
+    if (pet_kb_mode == PET_KBMODE_GAME)
+    {
+      if ((last_modifier ^ report->modifier) & KEYBOARD_MODIFIER_LEFTSHIFT)
+      {
+        // LS changed
+        bool press = report->modifier & KEYBOARD_MODIFIER_LEFTSHIFT;
+        press = (press || shift_lock);
+        pet_key_queue_put(PET_KEYCODE_LS | (press ? PET_KEYPRESS : 0));
+      }
+      if ((last_modifier ^ report->modifier) & KEYBOARD_MODIFIER_RIGHTSHIFT)
+      {
+        // RS changed
+        bool press = report->modifier & KEYBOARD_MODIFIER_RIGHTSHIFT;
+        pet_key_queue_put(PET_KEYCODE_RS | (press ? PET_KEYPRESS : 0));
+      }
+    }
+  }
+  last_modifier = report->modifier;
+
+
+  for(uint8_t i=0; i<6; i++)
+  {
+    uint8_t keycode = report->keycode[i];
+    if ( keycode )
+    {
+      if ( find_key_in_report(&prev_report, keycode) )
+      {
+        // exist in previous report means the current key is holding
+      }
+      else
+      {
+        // not existed in previous report means the current key is pressed
+
+        // remap the key code for Colemak layout
+        #ifdef KEYBOARD_COLEMAK
+        uint8_t colemak_key_code = colemak[keycode];
+        if (colemak_key_code != 0) keycode = colemak_key_code;
+        #endif
+
+        bool       is_shift = report->modifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT);
+        bool const is_ctrl  = report->modifier & (KEYBOARD_MODIFIER_LEFTCTRL | KEYBOARD_MODIFIER_RIGHTCTRL);
+        bool const is_alt   = report->modifier & (KEYBOARD_MODIFIER_LEFTALT  | KEYBOARD_MODIFIER_RIGHTALT);
+        bool const is_del   = (keycode == DELETE_KEY_CODE);
+        bool const is_c     = (keycode == C_KEY_CODE);
+        bool const is_caps  = (keycode == CAPS_KEY_CODE);
+        bool const is_kana  = (keycode == KANA_KEY_CODE);
+
+        // Check fkey def mode: [CTRL]+[F1-8]
+        // disabled in GAME mode
+        if (pet_kb_mode != PET_KBMODE_GAME && is_ctrl && (keycode >= F1_KEY_CODE && keycode <= (F1_KEY_CODE + PET_NUM_FKEYS - 1)))
+        {
+          uint16_t keynum = keycode - F1_KEY_CODE;
+
+          if (!fkey_def_mode)
+          {
+            // enter fkey definition mode
+            char tempbuf[256];
+            int count = sprintf(tempbuf, "Enter [F%d] definition mode\r\n", keynum + 1);
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+
+            fkey_def_mode = true;
+            fkey_def_keynum  = keynum;
+            pet_func_key_store[fkey_def_keynum].length = 0;
+            pet_func_key_store[fkey_def_keynum].initial_shift_lock = shift_lock;
+            pet_func_key_store[fkey_def_keynum].initial_pet_kb_mode  = pet_kb_mode;
+          }
+          else
+          {
+            // exit from fkey definition mode
+            char tempbuf[256];
+            int count = sprintf(tempbuf, "Exit [F%d] definition mode\r\n", fkey_def_keynum + 1);
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+
+            fkey_def_mode = false;
+          }
+          // once enter / exit the mode, this key is done and wait for the next key
+          continue;
+        }
+
+        // if fkey_def_mode, record the keycode and modifier
+        if (fkey_def_mode)
+        {
+            if (pet_func_key_store[fkey_def_keynum].length < PET_FKEY_MAXLEN)
+            {
+              pet_func_key_store[fkey_def_keynum].keycode[pet_func_key_store[fkey_def_keynum].length]  = keycode;
+              pet_func_key_store[fkey_def_keynum].modifier[pet_func_key_store[fkey_def_keynum].length] = report->modifier;
+              pet_func_key_store[fkey_def_keynum].length++;
+            }
+            if (pet_func_key_store[fkey_def_keynum].length >= PET_FKEY_MAXLEN)
+            {
+              // exit from fkey definition mode
+              char tempbuf[256];
+              int count = sprintf(tempbuf, "Exit [F%d] definition mode due to buffer full\r\n", fkey_def_keynum + 1);
+              tud_cdc_write(tempbuf, (uint32_t) count);
+              flush = true;
+
+              fkey_def_mode = false;
+            }
+        }
+
+        // Check KANA and GAME mode ON/OFF
+        if (is_kana)
+        {
+          pet_last_shift_state = false;
+          if (is_ctrl)
+          {
+            // CTRL + KANA = GAME mode on / off
+            pet_switch_all_relase();
+            pet_kb_mode = (pet_kb_mode == PET_KBMODE_GAME) ? PET_KBMODE_NORMAL : PET_KBMODE_GAME;
+            // All key relase when entering/leaving GAME mode
+          }
+          else
+          {
+            // KANA mode on / off
+            if (pet_kb_mode == PET_KBMODE_GAME) pet_switch_all_relase();
+            pet_kb_mode = (pet_kb_mode == PET_KBMODE_KANA) ? PET_KBMODE_NORMAL : PET_KBMODE_KANA;
+          }
+
+          char tempbuf[256];
+          int count = sprintf(tempbuf, "PET: KB MODE = %s\r\n", (pet_kb_mode == PET_KBMODE_KANA) ? "KANA" : (pet_kb_mode == PET_KBMODE_GAME) ? "GAME" : "NORM");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+        }
+
+        // Check CAPS = SHIFT LOCK ON/OFF check
+        else if (is_caps)
+        {
+          shift_lock = !shift_lock;
+          if (pet_kb_mode == PET_KBMODE_GAME)
+          {
+            bool press = is_shift;
+            press = (press || shift_lock);
+            pet_key_queue_put(PET_KEYCODE_LS | (press ? PET_KEYPRESS : 0));
+          }
+          else if (!shift_lock)
+          {
+            pet_key_queue_put(PET_KEYCODE_LS);
+          }
+
+          char tempbuf[256];
+          int count = sprintf(tempbuf, "PET: SHIFT LOCK = %s\r\n", shift_lock ? "ON" : "OFF");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+        }
+        if (shift_lock)
+        {
+          is_shift = true;
+        }
+
+        uint8_t ch = keycode2ascii[keycode][is_shift ? 1 : 0];
+        if (ch && !(ch & 0x80) && !is_ctrl)
+        {
+          tud_cdc_write("CHAR: ", 6);
+          if (ch == '\r') tud_cdc_write("[RETURN]", 8);
+          else if (ch == '\t') tud_cdc_write("[TAB]", 5);
+          else if (ch == '\b') tud_cdc_write("[BS]", 4);
+          else if (ch == ' ') tud_cdc_write("[SP]", 4);
+          else if (ch < 0x20u || ch >= 0x80u)
+          {
+            char tempbuf[256];
+            int count = sprintf(tempbuf, "[%02x]", ch);
+            tud_cdc_write(tempbuf, (uint32_t) count);
+            flush = true;
+          }
+          else tud_cdc_write(&ch, 1);
+          tud_cdc_write("\r\n", 2);
+          flush = true;
+        }
+        else
+        {
+          char tempbuf[256];
+          int count = sprintf(tempbuf, "HID: keycode = %02x, modifier = %02x\r\n", keycode, report->modifier);
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+        }
+
+        // PET -----------------------------
+
+        // Check CTRL-ALT-DEL
+        if (is_ctrl && is_alt && is_del)
+        {
+          pet_key_sending_task_state = PET_TASK_STATE_CTRL_ALT_DEL;
+        }
+
+        // [F1] - [F8]
+        // function key
+        // [ =============================================================
+        else if (pet_kb_mode != PET_KBMODE_GAME && keycode >= F1_KEY_CODE && keycode <= (F1_KEY_CODE + PET_NUM_FKEYS - 1))
+        {
+          // Function keys are disabled in GAME mode
+          uint16_t keynum = keycode - F1_KEY_CODE;
+          size_t l = pet_func_key_store[keynum].length;
+
+          shift_lock = pet_func_key_store[keynum].initial_shift_lock;
+          pet_kb_mode  =  pet_func_key_store[keynum].initial_pet_kb_mode;
+
+          char tempbuf[256];
+          int count = sprintf(tempbuf, "[F%d],sh:%s,kb:%s\r\n", keynum + 1, shift_lock ? "ON" : "OFF", (pet_kb_mode == PET_KBMODE_KANA) ? "KANA" : (pet_kb_mode == PET_KBMODE_GAME) ? "GAME" : "NORM");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          flush = true;
+
+          for (size_t n = 0; n < l; n++)
+          {
+            // Emulate key press
+            uint8_t fkeycode  = pet_func_key_store[keynum].keycode[n];
+            uint8_t fmodifier = pet_func_key_store[keynum].modifier[n];
+            bool       fis_shift = fmodifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT);
+            bool const fis_ctrl  = fmodifier & (KEYBOARD_MODIFIER_LEFTCTRL | KEYBOARD_MODIFIER_RIGHTCTRL);
+            bool const fis_alt   = fmodifier & (KEYBOARD_MODIFIER_LEFTALT  | KEYBOARD_MODIFIER_RIGHTALT);
+            // bool const fis_del   = (fkeycode == DELETE_KEY_CODE);
+            bool const fis_c     = (fkeycode == C_KEY_CODE);
+            bool const fis_caps  = (fkeycode == CAPS_KEY_CODE);
+            bool const fis_kana  = (fkeycode == KANA_KEY_CODE);
+            uint16_t syx;
+            switch (pet_kb_mode)
+            {
+              case PET_KBMODE_KANA:
+                syx = keycode2petSYX_kana[fkeycode][fis_shift ? 1 : 0];
+                break;
+              case PET_KBMODE_GAME:
+                syx = keycode2petSYX_game[fkeycode];
+                break;
+              case PET_KBMODE_NORMAL:
+              default:
+                syx = keycode2petSYX[fkeycode][fis_shift ? 1 : 0];
+                break;
+            }
+
+            // Check KANA and GAME mode ON/OFF
+            if (fis_kana)
+            {
+              if (fis_ctrl)
+              {
+                // CTRL + KANA = GAME mode on / off
+                pet_kb_mode = (pet_kb_mode == PET_KBMODE_GAME) ? PET_KBMODE_NORMAL : PET_KBMODE_GAME;
+              }
+              else
+              {
+                // KANA mode on / off
+                pet_kb_mode = (pet_kb_mode == PET_KBMODE_KANA) ? PET_KBMODE_NORMAL : PET_KBMODE_KANA;
+              }
+
+              count = sprintf(tempbuf, "PET: KB MODE = %s\r\n", (pet_kb_mode == PET_KBMODE_KANA) ? "KANA" : (pet_kb_mode == PET_KBMODE_GAME) ? "GAME" : "NORM");
+              tud_cdc_write(tempbuf, (uint32_t) count);
+              flush = true;
+            }
+
+            // Check CAPS = SHIFT LOCK ON/OFF check
+            else if (fis_caps)
+            {
+              if (!(shift_lock = !shift_lock))
+              {
+                // Release SHIFT on PET
+                pet_key_queue_put(PET_KEYCODE_LS);
+              }
+              count = sprintf(tempbuf, "PET: SHIFT LOCK = %s\r\n", shift_lock ? "ON" : "OFF");
+              tud_cdc_write(tempbuf, (uint32_t) count);
+              flush = true;
+            }
+            if (shift_lock)
+            {
+              fis_shift = true;
+            }
+
+            // Check CTRL-C / SHIFT-CTRL-C
+            if (fis_ctrl && fis_c)
+            {
+              if (!fis_shift)
+              {
+                // Queue [RUN/STOP] key pressed
+                syx = PET_KEYCODE_RUN_STOP;
+              }
+              else
+              {
+                // Queue [SHIFT] + [RUN/STOP] key pressed
+                syx = PET_KEYCODE_RUN_STOP | PET_SHIFT;
+              }
+            }
+
+            if (syx)
+            {
+              bool sft = (syx & PET_SHIFT) || (fis_alt && (pet_kb_mode == PET_KBMODE_NORMAL));	// ALT = Force SHIFT for Graphic char input
+              syx = PET_BARE_YX(syx);						// bare code
+              if (syx == PET_KEYCODE_REPEAT)
+              {
+                // [Repeat] key's SHIFT state must be the same as the last pressed key's SHIFT state
+                sft = pet_last_shift_state;
+              }
+              else
+              {
+                pet_last_shift_state = sft;
+              }
+              // press-release emulation
+              if (sft) pet_key_queue_put(PET_KEYCODE_LS | PET_KEYPRESS);
+              pet_key_queue_put(syx | PET_KEYPRESS);
+              pet_key_queue_put(syx);
+              if (sft) pet_key_queue_put(PET_KEYCODE_LS);
+            }
+          }
+        }
+        // ] =============================================================
+
+        else
+        {
+          uint16_t syx;
+          switch (pet_kb_mode)
+          {
+            case PET_KBMODE_KANA:
+              syx = keycode2petSYX_kana[keycode][is_shift ? 1 : 0];
+              break;
+            case PET_KBMODE_GAME:
+              syx = keycode2petSYX_game[keycode];
+              break;
+            case PET_KBMODE_NORMAL:
+            default:
+              syx = keycode2petSYX[keycode][is_shift ? 1 : 0];
+              break;
+          }
+
+          // Check CTRL-C / SHIFT-CTRL-C
+          if (is_ctrl && is_c)
+          {
+            if (!is_shift)
+            {
+              // Queue [RUN/STOP] key pressed
+              syx = PET_KEYCODE_RUN_STOP;
+            }
+            else
+            {
+              // Queue [SHIFT] + [RUN/STOP] key pressed
+              syx = PET_KEYCODE_RUN_STOP | PET_SHIFT;
+            }
+          }
+
+
+          if (syx == PET_KEYCODE_REPEAT)
+          {
+            // [Repeat] key's SHIFT state must be the same as the last pressed key's SHIFT state
+            if (pet_last_shift_state) syx |= PET_SHIFT;
+          }
+
+          if (syx)
+          {
+            if (pet_kb_mode == PET_KBMODE_GAME)
+            {
+              // simply queue bare key press
+              syx = PET_BARE_YX(syx);						// bare code
+              if (syx) pet_key_queue_put(syx | PET_KEYPRESS);
+            }
+            else
+            {
+              if (syx & PET_SHIFT || (is_alt && (pet_kb_mode == PET_KBMODE_NORMAL)))	// ALT = Force SHIFT for Graphic char input
+              {
+                pet_last_shift_state = true;
+                // First, queue only SHIFT
+                pet_key_queue_put(PET_KEYCODE_LS | PET_KEYPRESS);
+                // Clear SHIFT bit and queue the bare key press
+                syx = PET_BARE_YX(syx);
+              }
+              else
+              {
+                pet_last_shift_state = false;
+              }
+              // queue bare key press
+              pet_key_queue_put(syx | PET_KEYPRESS);
+            }
+          }
+        }
+      }
+    }
+  }
+  // Handle released key
+  for(uint8_t i=0; i<6; i++)
+  {
+    uint8_t keycode = prev_report.keycode[i];
+    if ( keycode )
+    {
+      if (find_key_in_report(report, keycode) && (pet_kb_mode != PET_KBMODE_GAME && prev_report.modifier == report->modifier))
+      {
+        // exist in current report means the previous key is still holding
+        // kaokun: however, modifier may changed, e.g. the following sequence:
+        // [Press Shift] - [Press a] - [Release Shift] - [release a]
+        // we have to release the modifier-changed key other than in GAME mode.
+      }
+      else
+      {
+        // not existed in current report means the previous key is released, or the modifier changed
+
+        // remap the key code for Colemak layout
+        #ifdef KEYBOARD_COLEMAK
+        uint8_t colemak_key_code = colemak[keycode];
+        if (colemak_key_code != 0) keycode = colemak_key_code;
+        #endif
+
+        bool       is_shift = prev_report.modifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT);
+        bool const is_ctrl  = prev_report.modifier & (KEYBOARD_MODIFIER_LEFTCTRL | KEYBOARD_MODIFIER_RIGHTCTRL);
+        bool const is_alt   = prev_report.modifier & (KEYBOARD_MODIFIER_LEFTALT  | KEYBOARD_MODIFIER_RIGHTALT);
+        bool const is_c     = (keycode == C_KEY_CODE);
+
+        if (shift_lock)
+        {
+          is_shift = true;
+        }
+
+        // PET
+        uint16_t syx;
+        switch (pet_kb_mode)
+        {
+          case PET_KBMODE_KANA:
+            syx = keycode2petSYX_kana[keycode][is_shift ? 1 : 0];
+            break;
+          case PET_KBMODE_GAME:
+            syx = keycode2petSYX_game[keycode];
+            break;
+          case PET_KBMODE_NORMAL:
+          default:
+            syx = keycode2petSYX[keycode][is_shift ? 1 : 0];
+            break;
+        }
+
+        // Check CTRL-C / SHIFT-CTRL-C
+        if (is_ctrl && is_c)
+        {
+          if (!is_shift)
+          {
+            // Queue [RUN/STOP] key released
+            syx = PET_KEYCODE_RUN_STOP;
+          }
+          else
+          {
+            // Queue [SHIFT] + [RUN/STOP] key released
+            syx = PET_KEYCODE_RUN_STOP | PET_SHIFT;
+          }
+        }
+
+        if (syx)
+        {
+          if (pet_kb_mode == PET_KBMODE_GAME)
+          {
+            // simply queue bare key release
+            syx = PET_BARE_YX(syx);						// bare code
+            if (syx) pet_key_queue_put(syx);
+          }
+          else
+          {
+            if (syx == PET_KEYCODE_REPEAT)
+            {
+              // [Repeat] key's SHIFT state must be the same as the last pressed key's SHIFT state
+              if (pet_last_shift_state) syx |= PET_SHIFT;
+            }
+
+            // First, queue only bare code
+            pet_key_queue_put(syx & (uint16_t)~PET_SHIFT);
+            if (syx & PET_SHIFT || (is_alt && (pet_kb_mode != PET_KBMODE_NORMAL)))		// ALT = Force SHIFT for Graphic char input
+            {
+              // Then release SHIFT
+              pet_key_queue_put(PET_KEYCODE_LS);
+              pet_last_shift_state = false;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // Change LED
+  leds = 0;
+  if (shift_lock) leds = leds | KEYBOARD_LED_CAPSLOCK;
+  if (pet_kb_mode == PET_KBMODE_KANA)
+  {
+    leds = leds | KEYBOARD_LED_KANA | KEYBOARD_LED_NUMLOCK;
+    blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_KANA;
+  }
+  if (pet_kb_mode == PET_KBMODE_GAME)
+  {
+    leds = leds | KEYBOARD_LED_SCROLLLOCK | KEYBOARD_LED_NUMLOCK;
+    blink_numlock_led_interval_ms = BLINK_NUMLOCK_LED_GAME;
+  }
+
+  if (flush) tud_cdc_write_flush();
+  prev_report = *report;
+}
+
+// send mouse report to usb device CDC
+static void process_mouse_report(uint8_t dev_addr, hid_mouse_report_t const * report)
+{
+  //------------- button state  -------------//
+  //uint8_t button_changed_mask = report->buttons ^ prev_report.buttons;
+  char l = report->buttons & MOUSE_BUTTON_LEFT   ? 'L' : '-';
+  char m = report->buttons & MOUSE_BUTTON_MIDDLE ? 'M' : '-';
+  char r = report->buttons & MOUSE_BUTTON_RIGHT  ? 'R' : '-';
+
+  char tempbuf[32];
+  int count = sprintf(tempbuf, "[%u] %c%c%c %d %d %d\r\n", dev_addr, l, m, r, report->x, report->y, report->wheel);
+
+  tud_cdc_write(tempbuf, (uint32_t) count);
+  tud_cdc_write_flush();
+}
+
+// Invoked when received report from device via interrupt endpoint
+void tuh_hid_report_received_cb(uint8_t dev_addr, uint8_t instance, uint8_t const* report, uint16_t len)
+{
+  (void) len;
+  uint8_t const itf_protocol = tuh_hid_interface_protocol(dev_addr, instance);
+
+  switch(itf_protocol)
+  {
+    case HID_ITF_PROTOCOL_KEYBOARD:
+      process_kbd_report(dev_addr, (hid_keyboard_report_t const*) report );
+      keybd_dev_addr = dev_addr;
+      keybd_instance = instance;
+    break;
+
+    case HID_ITF_PROTOCOL_MOUSE:
+      process_mouse_report(dev_addr, (hid_mouse_report_t const*) report );
+    break;
+
+    default: break;
+  }
+
+  // continue to request to receive report
+  if ( !tuh_hid_receive_report(dev_addr, instance) )
+  {
+    tud_cdc_write_str("Error: cannot request report\r\n");
+  }
+}
+
+//--------------------------------------------------------------------+
+// Blinking Task
+//--------------------------------------------------------------------+
+void led_blinking_task(void)
+{
+  static uint32_t start_ms = 0;
+  static bool led_state = false;
+
+  // Blink every interval ms
+  if ( board_millis() - start_ms < blink_interval_ms) return; // not enough time
+  start_ms += blink_interval_ms;
+
+  board_led_write(led_state);
+  led_state = 1 - led_state; // toggle
+}
+
+// HID Keyboard LED
+void keyboard_led_blinking_task(void)
+{
+  static uint32_t start_ms = 0;
+  const bool is_numlock = leds & KEYBOARD_LED_NUMLOCK;
+  static bool led_state = false;
+  static uint8_t my_leds;
+
+  if (keybd_dev_addr == 0xFFu) return;
+
+  my_leds = leds;
+  if (is_numlock && (blink_numlock_led_interval_ms != BLINK_NUMLOCK_LED_NONE))
+  {
+    if (board_millis() - start_ms >= blink_numlock_led_interval_ms)
+    {
+      // Blink every interval ms
+      start_ms = board_millis();
+      led_state = 1 - led_state; // toggle
+    }
+    if (led_state)
+    {
+      my_leds = (uint8_t)(my_leds | KEYBOARD_LED_NUMLOCK);
+    }
+    else
+    {
+      my_leds = (uint8_t)(my_leds & ~KEYBOARD_LED_NUMLOCK);
+    }
+  }
+  if (prev_leds != my_leds)
+  {
+    if (!tuh_hid_set_report(keybd_dev_addr, keybd_instance, 0, HID_REPORT_TYPE_OUTPUT, &my_leds, sizeof(my_leds)))
+    {
+      char tempbuf[256];
+      int count = sprintf(tempbuf, "HID KB LED %02x fail\r\n", my_leds);
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+ 
+      prev_leds = 0xFFu;	// for retry
+    }
+    else
+    {
+      char tempbuf[256];
+      int count = sprintf(tempbuf, "HID KB LED %02x Success\r\n", my_leds);
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+ 
+      prev_leds = my_leds;
+    }
+  }
+}
+
+//--------------------------------------------------------------------+
+// PET key sending task
+//--------------------------------------------------------------------+
+void pet_sendkey_task(void)
+{
+  switch(pet_key_sending_task_state)
+  {
+    char tempbuf[256];
+    int count;
+    static uint16_t last_on_syx = 0;
+
+    case PET_TASK_STATE_RESET:
+      count = sprintf(tempbuf, "PET: initializing switch array\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      pet_switch_init();
+      break;
+
+    case PET_TASK_STATE_RESET_ASSERTED:
+      if (board_millis() - pet_task_start_ms < PET_KBIF_RESET_MS) break;
+      pet_switch_deassert_reset();
+      count = sprintf(tempbuf, "PET: switch array ready\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      last_on_syx = 0;
+      break;
+
+    case PET_TASK_STATE_GETKEY:
+      if (!pet_key_queue_num_data()) break;			// queue empty
+  
+      uint16_t syx  = pet_key_queue_peek();			// Peek queue
+      uint16_t bare_yx = PET_BARE_YX(syx);
+      bool onoff    = PET_ISKEYPRESS(syx);
+      uint8_t x     = PET_X(syx);
+      uint8_t y     = PET_Y(syx);
+
+      if (!syx) {
+        // current syx is processed
+        pet_key_queue_drop();
+        break;
+      }
+
+      if (onoff && syx == last_on_syx)
+      {
+        // the same key is pressed. need extra delay
+        pet_switch_start_waiting_between_the_same_key();
+        break;
+      }
+
+      // current syx is being processed
+      pet_key_queue_drop();
+
+      // avoid SHIFT bounce, ON->OFF->ON
+      if ((!onoff) && (bare_yx == PET_KEYCODE_LS || bare_yx == PET_KEYCODE_RS) && pet_key_queue_num_data())
+      {
+        // Current: Key off, the key is SHIFT and there is next data
+        uint16_t next_syx = pet_key_queue_peek();	// Peek next data
+        uint16_t next_bare_yx  = PET_BARE_YX(next_syx);
+        bool next_onoff = PET_ISKEYPRESS(next_syx);
+        if (next_onoff && (next_bare_yx == PET_KEYCODE_LS || next_bare_yx == PET_KEYCODE_RS))
+        {
+          // Next key: key on, the key is SHIFT
+          pet_key_queue_drop();	// drop the next key
+          // and no process for current SHIFT OFF
+          break;
+        }
+      }
+
+#ifdef PET_KEYCODE_DEBUG
+      count = sprintf(tempbuf, "PET: Array (%d, %d) = %s\r\n", x, y, (onoff) ? "ON" : "OFF");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+#endif
+
+      // Switch array control
+      pet_switch_set(x, y, onoff);
+      if (onoff && !(bare_yx == PET_KEYCODE_LS || bare_yx == PET_KEYCODE_RS))
+      {
+        // save the last pressed key other than [SHIFT]
+        last_on_syx = syx;
+      }
+
+      // OFF->OFF->OFF->... does not need debounce time
+      while ((!onoff) && pet_key_queue_num_data())
+      {
+        // Current: Key off and there is next data
+        uint16_t next_syx = pet_key_queue_peek();	// Peek next data
+        onoff = PET_ISKEYPRESS(next_syx);
+        if (!onoff)
+        {
+          x = PET_X(next_syx);
+          y = PET_Y(next_syx);
+      
+#ifdef PET_KEYCODE_DEBUG
+          count = sprintf(tempbuf, "PET: Array (%d, %d) = %s\r\n", x, y, (onoff) ? "ON" : "OFF");
+          tud_cdc_write(tempbuf, (uint32_t) count);
+          tud_cdc_write_flush();
+#endif
+          // Release the next key also
+          pet_switch_set(x, y, onoff);
+          // current syx is being processed
+          pet_key_queue_drop();
+        }
+      }
+  
+      break;
+
+    case PET_TASK_STATE_KEY_STROBE_ASSERTED:
+      if (board_millis() - pet_task_start_ms < PET_KBIF_STROBE_MS) break;
+      pet_switch_deassert_strobe();
+      break;
+
+    case PET_TASK_STATE_KEY_STROBE_DEASSERTED:
+      if (board_millis() - pet_task_start_ms < PET_KBIF_STROBE_MS) break;
+      pet_switch_start_waiting_debounce();
+      break;
+
+    case PET_TASK_STATE_KEY_WAIT_DEBOUNCE:
+      if (board_millis() - pet_task_start_ms < PET_KBIF_DEBOUNCE_MS) break;
+      pet_switch_get_next_key();
+      break;
+
+    case PET_TASK_STATE_KEY_WAIT_RELEASE_DEBOUNCE:
+      if (board_millis() - pet_task_start_ms < PET_KBIF_RELEASE_DEBOUNCE_MS) break;
+      pet_switch_get_next_key();
+      break;
+
+    case PET_TASK_STATE_CTRL_ALT_DEL:
+      last_on_syx = 0;
+      count = sprintf(tempbuf, "PET: Asserting CTRL-ALT-DEL\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      pet_switch_ctrl_alt_del();
+      break;
+
+    case PET_TASK_STATE_CTRL_ALT_DEL_ASSERTED:
+      if (board_millis() - pet_task_start_ms < PET_KBIF_CTRL_ALT_DEL_MS) break;
+      pet_switch_deassert_ctrl_alt_del();
+      count = sprintf(tempbuf, "PET: Deassert CTRL-ALT-DEL\r\n");
+      tud_cdc_write(tempbuf, (uint32_t) count);
+      tud_cdc_write_flush();
+      last_on_syx = 0;
+      break;
+
+    case PET_TASK_STATE_WAITING_BETWEEN_THE_SAME_KEY:
+      if (board_millis() - pet_task_start_ms < PET_KBIF_WAIT_BETWEEN_THE_SAME_KEY_MS) break;
+      pet_switch_get_next_key();
+      last_on_syx = 0;
+      break;
+
+    default:
+      pet_key_sending_task_state = PET_TASK_STATE_RESET;
+      break;
+  }
+}
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/tusb_config.h pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/tusb_config.h
--- pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/tusb_config.h	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/tusb_config.h	2024-05-24 13:30:10.283213421 +0900
@@ -0,0 +1,143 @@
+/*
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2019 Ha Thach (tinyusb.org)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ */
+
+#ifndef _TUSB_CONFIG_H_
+#define _TUSB_CONFIG_H_
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+//--------------------------------------------------------------------+
+// Board Specific Configuration
+//--------------------------------------------------------------------+
+
+// RHPort number used for device can be defined by board.mk, default to port 0
+#ifndef BOARD_TUD_RHPORT
+#define BOARD_TUD_RHPORT      0
+#endif
+
+// RHPort max operational speed can defined by board.mk
+#ifndef BOARD_TUD_MAX_SPEED
+#define BOARD_TUD_MAX_SPEED   OPT_MODE_DEFAULT_SPEED
+#endif
+
+// RHPort number used for host can be defined by board.mk, default to port 1
+#ifndef BOARD_TUH_RHPORT
+#define BOARD_TUH_RHPORT      1
+#endif
+
+// RHPort max operational speed can defined by board.mk
+#ifndef BOARD_TUH_MAX_SPEED
+#define BOARD_TUH_MAX_SPEED   OPT_MODE_DEFAULT_SPEED
+#endif
+
+//--------------------------------------------------------------------
+// COMMON CONFIGURATION
+//--------------------------------------------------------------------
+
+// defined by compiler flags for flexibility
+#ifndef CFG_TUSB_MCU
+#error CFG_TUSB_MCU must be defined
+#endif
+
+#ifndef CFG_TUSB_OS
+#define CFG_TUSB_OS           OPT_OS_NONE
+#endif
+
+#ifndef CFG_TUSB_DEBUG
+#define CFG_TUSB_DEBUG        0
+#endif
+
+// Enable Device stack, Default is max speed that hardware controller could support with on-chip PHY
+#define CFG_TUD_ENABLED       1
+#define CFG_TUD_MAX_SPEED     BOARD_TUD_MAX_SPEED
+
+// Enable Host stack, Default is max speed that hardware controller could support with on-chip PHY
+#define CFG_TUH_ENABLED       1
+#define CFG_TUH_MAX_SPEED     BOARD_TUH_MAX_SPEED
+
+#if CFG_TUSB_MCU == OPT_MCU_RP2040
+// Use pico-pio-usb as host controller for raspberry rp2040
+#define CFG_TUH_RPI_PIO_USB   1
+#endif
+
+
+// CFG_TUSB_DEBUG is defined by compiler in DEBUG build
+// #define CFG_TUSB_DEBUG           0
+
+/* USB DMA on some MCUs can only access a specific SRAM region with restriction on alignment.
+ * Tinyusb use follows macros to declare transferring memory so that they can be put
+ * into those specific section.
+ * e.g
+ * - CFG_TUSB_MEM SECTION : __attribute__ (( section(".usb_ram") ))
+ * - CFG_TUSB_MEM_ALIGN   : __attribute__ ((aligned(4)))
+ */
+#ifndef CFG_TUSB_MEM_SECTION
+#define CFG_TUSB_MEM_SECTION
+#endif
+
+#ifndef CFG_TUSB_MEM_ALIGN
+#define CFG_TUSB_MEM_ALIGN        __attribute__ ((aligned(4)))
+#endif
+
+//--------------------------------------------------------------------
+// DEVICE CONFIGURATION
+//--------------------------------------------------------------------
+
+#ifndef CFG_TUD_ENDPOINT0_SIZE
+#define CFG_TUD_ENDPOINT0_SIZE    64
+#endif
+
+//------------- CLASS -------------//
+#define CFG_TUD_CDC              1
+
+// CDC FIFO size of TX and RX
+#define CFG_TUD_CDC_RX_BUFSIZE   (TUD_OPT_HIGH_SPEED ? 512 : 64)
+#define CFG_TUD_CDC_TX_BUFSIZE   (TUD_OPT_HIGH_SPEED ? 512 : 64)
+
+// CDC Endpoint transfer buffer size, more is faster
+#define CFG_TUD_CDC_EP_BUFSIZE   (TUD_OPT_HIGH_SPEED ? 512 : 64)
+
+//--------------------------------------------------------------------
+// HOST CONFIGURATION
+//--------------------------------------------------------------------
+
+// Size of buffer to hold descriptors and other data used for enumeration
+#define CFG_TUH_ENUMERATION_BUFSIZE 256
+
+#define CFG_TUH_HUB                 1
+// max device support (excluding hub device)
+#define CFG_TUH_DEVICE_MAX          (CFG_TUH_HUB ? 4 : 1) // hub typically has 4 ports
+
+#define CFG_TUH_HID                  4
+#define CFG_TUH_HID_EPIN_BUFSIZE    64
+#define CFG_TUH_HID_EPOUT_BUFSIZE   64
+
+#ifdef __cplusplus
+ }
+#endif
+
+#endif /* _TUSB_CONFIG_H_ */
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/usb_descriptors.c pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/usb_descriptors.c
--- pico.orig/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/usb_descriptors.c	1970-01-01 09:00:00.000000000 +0900
+++ pico/pico-sdk/lib/tinyusb/examples/pet/host_hid_to_device_cdc_pet/src/usb_descriptors.c	2024-05-24 13:30:10.283213421 +0900
@@ -0,0 +1,265 @@
+/* 
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2019 Ha Thach (tinyusb.org)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ */
+
+#include "tusb.h"
+
+/* A combination of interfaces must have a unique product id, since PC will save device driver after the first plug.
+ * Same VID/PID with different interface e.g MSC (first), then CDC (later) will possibly cause system error on PC.
+ *
+ * Auto ProductID layout's Bitmap:
+ *   [MSB]         HID | MSC | CDC          [LSB]
+ */
+#define _PID_MAP(itf, n)  ( (CFG_TUD_##itf) << (n) )
+#define USB_PID           (0x4000 | _PID_MAP(CDC, 0) | _PID_MAP(MSC, 1) | _PID_MAP(HID, 2) | \
+                           _PID_MAP(MIDI, 3) | _PID_MAP(VENDOR, 4) )
+
+#define USB_VID   0xCafe
+#define USB_BCD   0x0200
+
+//--------------------------------------------------------------------+
+// Device Descriptors
+//--------------------------------------------------------------------+
+tusb_desc_device_t const desc_device =
+{
+  .bLength            = sizeof(tusb_desc_device_t),
+  .bDescriptorType    = TUSB_DESC_DEVICE,
+  .bcdUSB             = USB_BCD,
+
+  // Use Interface Association Descriptor (IAD) for CDC
+  // As required by USB Specs IAD's subclass must be common class (2) and protocol must be IAD (1)
+  .bDeviceClass       = TUSB_CLASS_MISC,
+  .bDeviceSubClass    = MISC_SUBCLASS_COMMON,
+  .bDeviceProtocol    = MISC_PROTOCOL_IAD,
+
+  .bMaxPacketSize0    = CFG_TUD_ENDPOINT0_SIZE,
+
+  .idVendor           = USB_VID,
+  .idProduct          = USB_PID,
+  .bcdDevice          = 0x0100,
+
+  .iManufacturer      = 0x01,
+  .iProduct           = 0x02,
+  .iSerialNumber      = 0x03,
+
+  .bNumConfigurations = 0x01
+};
+
+// Invoked when received GET DEVICE DESCRIPTOR
+// Application return pointer to descriptor
+uint8_t const * tud_descriptor_device_cb(void)
+{
+  return (uint8_t const *) &desc_device;
+}
+
+//--------------------------------------------------------------------+
+// Configuration Descriptor
+//--------------------------------------------------------------------+
+
+enum
+{
+  ITF_NUM_CDC = 0,
+  ITF_NUM_CDC_DATA,
+  ITF_NUM_TOTAL
+};
+
+#if CFG_TUSB_MCU == OPT_MCU_LPC175X_6X || CFG_TUSB_MCU == OPT_MCU_LPC177X_8X || CFG_TUSB_MCU == OPT_MCU_LPC40XX
+  // LPC 17xx and 40xx endpoint type (bulk/interrupt/iso) are fixed by its number
+  // 0 control, 1 In, 2 Bulk, 3 Iso, 4 In, 5 Bulk etc ...
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x82
+
+#elif CFG_TUSB_MCU == OPT_MCU_SAMG  || CFG_TUSB_MCU ==  OPT_MCU_SAMX7X
+  // SAMG & SAME70 don't support a same endpoint number with different direction IN and OUT
+  //    e.g EP1 OUT & EP1 IN cannot exist together
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x83
+
+#elif CFG_TUSB_MCU == OPT_MCU_CXD56
+  // CXD56 doesn't support a same endpoint number with different direction IN and OUT
+  //    e.g EP1 OUT & EP1 IN cannot exist together
+  // CXD56 USB driver has fixed endpoint type (bulk/interrupt/iso) and direction (IN/OUT) by its number
+  // 0 control (IN/OUT), 1 Bulk (IN), 2 Bulk (OUT), 3 In (IN), 4 Bulk (IN), 5 Bulk (OUT), 6 In (IN)
+  #define EPNUM_CDC_NOTIF   0x83
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x81
+
+#elif CFG_TUSB_MCU == OPT_MCU_FT90X || CFG_TUSB_MCU == OPT_MCU_FT93X
+  // FT9XX doesn't support a same endpoint number with different direction IN and OUT
+  //    e.g EP1 OUT & EP1 IN cannot exist together
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x83
+
+#else
+  #define EPNUM_CDC_NOTIF   0x81
+  #define EPNUM_CDC_OUT     0x02
+  #define EPNUM_CDC_IN      0x82
+
+#endif
+
+#define CONFIG_TOTAL_LEN    (TUD_CONFIG_DESC_LEN + TUD_CDC_DESC_LEN)
+
+// full speed configuration
+uint8_t const desc_fs_configuration[] =
+{
+  // Config number, interface count, string index, total length, attribute, power in mA
+  TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_TOTAL_LEN, 0x00, 100),
+
+  // Interface number, string index, EP notification address and size, EP data address (out, in) and size.
+  TUD_CDC_DESCRIPTOR(ITF_NUM_CDC, 4, EPNUM_CDC_NOTIF, 8, EPNUM_CDC_OUT, EPNUM_CDC_IN, 64),
+};
+
+#if TUD_OPT_HIGH_SPEED
+// Per USB specs: high speed capable device must report device_qualifier and other_speed_configuration
+
+// high speed configuration
+uint8_t const desc_hs_configuration[] =
+{
+  // Config number, interface count, string index, total length, attribute, power in mA
+  TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_TOTAL_LEN, 0x00, 100),
+
+  // Interface number, string index, EP notification address and size, EP data address (out, in) and size.
+  TUD_CDC_DESCRIPTOR(ITF_NUM_CDC, 4, EPNUM_CDC_NOTIF, 8, EPNUM_CDC_OUT, EPNUM_CDC_IN, 512),
+};
+
+// other speed configuration
+uint8_t desc_other_speed_config[CONFIG_TOTAL_LEN];
+
+// device qualifier is mostly similar to device descriptor since we don't change configuration based on speed
+tusb_desc_device_qualifier_t const desc_device_qualifier =
+{
+  .bLength            = sizeof(tusb_desc_device_qualifier_t),
+  .bDescriptorType    = TUSB_DESC_DEVICE_QUALIFIER,
+  .bcdUSB             = USB_BCD,
+
+  .bDeviceClass       = TUSB_CLASS_MISC,
+  .bDeviceSubClass    = MISC_SUBCLASS_COMMON,
+  .bDeviceProtocol    = MISC_PROTOCOL_IAD,
+
+  .bMaxPacketSize0    = CFG_TUD_ENDPOINT0_SIZE,
+  .bNumConfigurations = 0x01,
+  .bReserved          = 0x00
+};
+
+// Invoked when received GET DEVICE QUALIFIER DESCRIPTOR request
+// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete.
+// device_qualifier descriptor describes information about a high-speed capable device that would
+// change if the device were operating at the other speed. If not highspeed capable stall this request.
+uint8_t const* tud_descriptor_device_qualifier_cb(void)
+{
+  return (uint8_t const*) &desc_device_qualifier;
+}
+
+// Invoked when received GET OTHER SEED CONFIGURATION DESCRIPTOR request
+// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete
+// Configuration descriptor in the other speed e.g if high speed then this is for full speed and vice versa
+uint8_t const* tud_descriptor_other_speed_configuration_cb(uint8_t index)
+{
+  (void) index; // for multiple configurations
+
+  // if link speed is high return fullspeed config, and vice versa
+  // Note: the descriptor type is OHER_SPEED_CONFIG instead of CONFIG
+  memcpy(desc_other_speed_config,
+         (tud_speed_get() == TUSB_SPEED_HIGH) ? desc_fs_configuration : desc_hs_configuration,
+         CONFIG_TOTAL_LEN);
+
+  desc_other_speed_config[1] = TUSB_DESC_OTHER_SPEED_CONFIG;
+
+  return desc_other_speed_config;
+}
+
+#endif // highspeed
+
+
+// Invoked when received GET CONFIGURATION DESCRIPTOR
+// Application return pointer to descriptor
+// Descriptor contents must exist long enough for transfer to complete
+uint8_t const * tud_descriptor_configuration_cb(uint8_t index)
+{
+  (void) index; // for multiple configurations
+
+#if TUD_OPT_HIGH_SPEED
+  // Although we are highspeed, host may be fullspeed.
+  return (tud_speed_get() == TUSB_SPEED_HIGH) ?  desc_hs_configuration : desc_fs_configuration;
+#else
+  return desc_fs_configuration;
+#endif
+}
+
+//--------------------------------------------------------------------+
+// String Descriptors
+//--------------------------------------------------------------------+
+
+// array of pointer to string descriptors
+char const* string_desc_arr [] =
+{
+  (const char[]) { 0x09, 0x04 }, // 0: is supported language is English (0x0409)
+  "TinyUSB",                     // 1: Manufacturer
+  "TinyUSB Device",              // 2: Product
+  "123456789012",                // 3: Serials, should use chip ID
+  "TinyUSB CDC",                 // 4: CDC Interface
+};
+
+static uint16_t _desc_str[32];
+
+// Invoked when received GET STRING DESCRIPTOR request
+// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete
+uint16_t const* tud_descriptor_string_cb(uint8_t index, uint16_t langid)
+{
+  (void) langid;
+
+  uint8_t chr_count;
+
+  if ( index == 0)
+  {
+    memcpy(&_desc_str[1], string_desc_arr[0], 2);
+    chr_count = 1;
+  }else
+  {
+    // Note: the 0xEE index string is a Microsoft OS 1.0 Descriptors.
+    // https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/microsoft-defined-usb-descriptors
+
+    if ( !(index < sizeof(string_desc_arr)/sizeof(string_desc_arr[0])) ) return NULL;
+
+    const char* str = string_desc_arr[index];
+
+    // Cap at max char
+    chr_count = (uint8_t) strlen(str);
+    if ( chr_count > 31 ) chr_count = 31;
+
+    // Convert ASCII string into UTF-16
+    for(uint8_t i=0; i<chr_count; i++)
+    {
+      _desc_str[1+i] = str[i];
+    }
+  }
+
+  // first byte is length (including header), second byte is string type
+  _desc_str[0] = (uint16_t) ((TUSB_DESC_STRING << 8 ) | (2*chr_count + 2));
+
+  return _desc_str;
+}
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.c pico/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.c
--- pico.orig/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.c	2024-05-24 13:24:10.697849439 +0900
+++ pico/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.c	2024-05-25 15:46:11.605216486 +0900
@@ -32,6 +32,11 @@
 #include "hardware/structs/ioqspi.h"
 #include "hardware/structs/sio.h"
 
+// kaokun: pico w LED support
+#ifdef RASPBERRYPI_PICO_W
+  #include "pico/cyw43_arch.h"
+#endif
+
 #include "bsp/board.h"
 #include "board.h"
 
@@ -143,6 +148,10 @@ void board_init(void)
   gpio_init(LED_PIN);
   gpio_set_dir(LED_PIN, GPIO_OUT);
 #endif
+// kaokun: pico w LED support
+#ifdef RASPBERRYPI_PICO_W
+  cyw43_arch_init();
+#endif
 
   // Button
 #ifndef BUTTON_BOOTSEL
@@ -178,6 +187,10 @@ void board_led_write(bool state)
 #ifdef LED_PIN
   gpio_put(LED_PIN, state ? LED_STATE_ON : (1-LED_STATE_ON));
 #endif
+// kaokun: pico w LED support
+#ifdef RASPBERRYPI_PICO_W
+  cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, state ? 1 : 0);
+#endif
 }
 
 uint32_t board_button_read(void)
diff '--exclude=.git' -uprN pico.orig/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.cmake pico/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.cmake
--- pico.orig/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.cmake	2024-05-24 13:24:10.697849439 +0900
+++ pico/pico-sdk/lib/tinyusb/hw/bsp/rp2040/family.cmake	2024-05-25 15:41:49.229125639 +0900
@@ -33,18 +33,38 @@ if (NOT TARGET _rp2040_family_inclusion_
 			${TOP}/src/common/tusb_fifo.c
 			)
 
-	target_include_directories(tinyusb_common_base INTERFACE
+	#------------------------------------
+        # kaokun: pico w LED support
+	#------------------------------------
+        if (PICO_CYW43_SUPPORTED) # set by PICO_BOARD=pico_w
+		target_include_directories(tinyusb_common_base INTERFACE
 			${TOP}/src
 			${TOP}/src/common
+			${TOP}/src/rp2_common
 			${TOP}/hw
 			)
 
-	target_link_libraries(tinyusb_common_base INTERFACE
+		target_link_libraries(tinyusb_common_base INTERFACE
 			hardware_structs
 			hardware_irq
 			hardware_resets
 			pico_sync
+			pico_cyw43_arch_none
 			)
+	else()
+		target_include_directories(tinyusb_common_base INTERFACE
+			${TOP}/src
+			${TOP}/src/common
+			${TOP}/hw
+			)
+
+		target_link_libraries(tinyusb_common_base INTERFACE
+			hardware_structs
+			hardware_irq
+			hardware_resets
+			pico_sync
+			)
+	endif()
 
 	set(TINYUSB_DEBUG_LEVEL 0)
 	if (CMAKE_BUILD_TYPE STREQUAL "Debug")
